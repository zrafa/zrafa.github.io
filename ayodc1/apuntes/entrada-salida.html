<html>
<style>
@import url(http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic,700italic);

/* Set up basic page design */

@page { 
  /* size: letter; */
  size: a4;

  @footnotes {
    border-top: thin solid black; 
    border-clip: 100px;
    padding: 0;
    margin: 0.6em 0 0 0;
    padding: 0.3em 0 0 0;
  }
  @bottom-center {
    content: counter(page);
  }
}

article { 
  /* columns: 2; */
  columns: 1;
  column-gap: 0.25in; 
  /* font: 11pt "PT Serif", serif; */
  font-family: Lato, "Roboto Condensed", sans-serif;
  hyphens: auto;             /* turn on hyphenation */
  text-align: justify;       /* and justification */
  counter-reset: figure;
}

/* basic settings on commonly used elements */

code {
  	font-family: 8pt, monospace;
  font-size: 70%;
}
html, body, div, header, p, blockquote, ul, ol, li, pre { 
 	margin-left: 5%;
	padding: 0; 
  	font-family: Lato, "Roboto Condensed", sans-serif;
}

p{
	/* margin-left:3em;
	margin-right:0.5em; */
	margin-left:0em;
	margin-right:0em;
  	font-family: Lato, "Roboto Condensed", sans-serif;

}
b { 
  /* background-color: #eeeefF; */
  font-style: italic;
  font-family: bold 12pt Lato, "Roboto Condensed", sans-serif;
}
li { margin-left: 1.5em }

header { 
  font: bold 12pt "PT Serif", serif; 
  margin: 1em 0 0.3em;
  page-break-after: avoid; break-after: avoid;
  margin: 0 0 0em -10%;
}


#toc, #ix, li { list-style-type: none; margin: 0; padding: 0 }
#toc a:after { content: leader('.') target-counter(attr(href), page) }

#ix span.entry:after { content: leader('.') }



p { text-indent: 1.5em }
header + p { text-indent: 0 }
cite { font-style: normal }
pre { margin: 0.5em 0; padding: 0.3em; background: #eee }
ul { margin: 0.8em 0 }

/* sections-specific styling */

section.lead { 
  column-span: all; 
  text-align: center;
  /* margin: 2em 0; */
 	margin-left: -10%;
  font-style: italic;
}

aside {
  background: #ddf;
  text-align: justify;       /* and justification */
  padding: 0.6em 1.3em 0.6em 1.3em; 
  font-family: Lato, "Roboto Condensed", sans-serif;
/*  width: 100%; */
  margin-left: 0%;
  box-sizing: border-box;
  float: none;
  hyphens: manual;
}



section.lead h1 { 
	font: bold 14pt "PT Serif", serif; 
	text-align: center 

} /* used for article title */

section.lead .authors {
  display: table;
  margin: 0 auto; 
}

section.lead .vcard {
  display: table-cell;
  text-align: center;
  font: 11pt "PT Serif", serif;
}

section.lead a {
  display: block;
  padding: 0 1em;
  color: black;
  text-decoration: none;
}

section.abstract header {
  text-align: center;
}

section.refs p {
  margin: 0.5em 0;
  text-indent: 0;
}

section.refs .author { 
  font-variant: small-caps;
}

section.refs ol, table ol {
  margin: 0; padding: 0;
}

section.refs li, table li {
  list-style-type: none;
  margin-left: 1.5em;
  text-indent: -1.5em;
}

table { border-collapse: collapse; margin: 1em 0; width: 100%; }

table td {
  border: thin solid black;
  padding: 0.2em;
}

/* counters */

section:first-of-type { counter-reset: section }
section.nonum { counter-reset: none }

section { counter-increment: section }
section.nonum { counter-increment: none }

header:before { content: counters(section, ".") " " }
section.nonum header:before { content: none }

/* footnotes */

::footnote-call {
  content: "[" counter(footnote, lower-latin) "]";
  font-size: 83%;
  vertical-align: super;
  line-height: none
}

::footnote-marker {
  content: "[" counter(footnote, lower-latin) "]";
  list-style-position: inside;
  margin: 0; padding: 0 0.3em 0 0;
}

.foot {
  float: prince-column-footnote;
  font-size: 90%;
  footnote-style-position: outside;
  margin: 0.3em 0 0 1.3em; padding: 0; text-indent: 0;
}

/* page floats */

.column-top { float: column-top; margin-bottom: 2em }
.column-bottom { float: column-bottom;  margin-top: 2em }
.top { float: top;  margin-bottom: 2em }
.bottom { float: bottom;  margin-top: 2em }
top figcaption, .bottom figcaption { margin-left: 2em; margin-right: 2em }

.sidenote {
  float: left;
  clear: left;
  margin: 0 0 0em -20%;
  width: 18%;
  font-size: 0.9em;
/*  font-style: normal; */
  text-indent: 0;
  text-align: right;
  page-break-inside: avoid;
  color:#4C50AF;
/*  font: 8pt;  */
  font-style:italic;
}


figure { 
  counter-increment: figure;
  font-size: 0.9em;
/*  min-width: 300px; */
  max-width: 640px;
/*  min-height: 300px; */
  max-height: 480px;
  text-align: left;
  width: 90%;
  float: center;
  margin: 0.4in;
}

figcaption:before { 
  font-weight: bold;
  content: "Figure " counter(figure) ": " 
}

@media screen {
  body {
    margin: 3em;
  }





p.sidenote + p, p.caption, p.art { text-indent: 0 }


p.date {
    text-align: right;
}

  article { 
    columns: 1;
    font: 16px/1.3 "PT Serif", serif;
    width: 100%;
  }
  .top, .bottom, .column-top, .column-bottom {
    float: right; 
    width: 55%;
    margin-right: -60%;
  }
  /* aside { float: none; width: auto; margin: 1em 0 } */
  aside { float: none; width: auto; margin: 0em 0em 0em 0em }
}


#customers {
    font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

#customers td, #customers th {
    border: 1px solid #ddd;
    padding: 8px;
  font: 10pt "PT Serif", serif;
}

#customers tr:nth-child(even){
background-color: #f2f2f2;
  font: 10pt "PT Serif", serif;
}

#customers tr:hover {
background-color: #ddd;
  font: 10pt "PT Serif", serif;
}

#customers th {
    /* font: 8pt */
    padding-top: 12px;
    padding-bottom: 12px;
    text-align: left;
    /* background-color: #4CAF50; */
    background-color: #4C50AF;
    color: white;
  font: 10pt "PT Serif", serif;
}
</style>

<!-- body onload="makeref(); maketf();"-->
<body onload="maketoc();">

<article>


<section class=lead>
<h1>Entrada y Salida (E/S) </h1>

<div class=authors>

<div class="vcard">
<i>
 <a class="url fn" href="http://github.com/zrafa">Rafael Ignacio Zurita</a>
 <a class="url org" href="mailto:rafa@fi.uncoma.edu.ar">rafa@fi.uncoma.edu.ar</a>
</div>

<div class="vcard">
 <a class="url fn" href="http://faiweb.uncoma.edu.ar">Rodolfo del Castillo</a>
 <a class="url org" href="mailto:rdc@fi.uncoma.edu.ar">rdc@fi.uncoma.edu.ar</a>
</i>

</div>

</div>
<p class="author">Apunte de cátedra
<span class="foot">
Obra derivada con permiso escrito (detalles de las obras originales y permisos en la última sección) de articulos de Alan Clements, para las materias de arquitecturas de computadoras, de la universidad de Teesside, Inglaterra; y de Computer Programming and Architecture the VAX-11, Henry Levy, Digital Press (1980). 
</span>

</section>

<section class='abstract nonum'>

<header>Resumen</header>

<!-- toc -->

<p>En las unidades anteriores hemos examinado la estructura interna y operación de una unidad de procesamiento central (CPU). 
De cualquier manera, para que una computadora tenga un valor real para las personas, debe poder comunicarse de alguna manera con sus usuarios.
Despues de todo, no tiene ningún sentido en diseñar y crear una super computadora del tamaño de un clip, y que pueda resolver
la ultima duda existencial de la vida, el universo, y todo lo demás, si no puede, de alguna manera, decirnos la respuesta.
En este apunte se presentan los caminos y mecanismos por los cuales la información entra y sale de una computadora, y los dispositivos o periféricos conectados a la computadora para llevar a cabo este propósito (por ejemplo, una impresora y el monitor led).

</section>

<section>

<header>Subsistema de Entrada y Salida</header>

<p>La organización básica de una computadora consiste de un procesador, la memoria, y el subsitema de entrada y salida (E/S).
El <b>subsistema de entrada y salida</b> está compuesto de dispositivos de E/S (o periféricos) y controladores de dispositivos, interconectados al procesador y memoria mediantes buses del sistema. 
<p>
<span class="sidenote"><span class=ix>entrada y salida</span></span>
La <b>entrada y salida</b> son señales o datos recibidos y enviados por el sistema, y
permite a la computadora 
comunicarse con el mundo exterior, tal vez con una persona (usuario) o con otro sistema (procesador). 
Por ejemplo, mediante la entrada y salida la computadora puede cargar programas y datos en la memoria 
(por ejemplo desde un medio de almacenamiento como el disco rígido), presentar datos a sus usuarios (en una pantalla), 
recibir entrada (desde un teclado y mouse), o enviar datos a otros sistemas mediante la red.
<p>
Existe una amplia variedad de periféricos que pueden ser parte de un subsistema de entrada y salida.
Los dispositivos mas comunes en una PC son los discos rígidos, teclado, mouse, monitor, impresora, escaner, camara, microfono, parlantes, leds, placas de red, lectoras de CD/DVD/SD, gamepads, etc.
Un otro ejemplo son los smartphones, en donde existen tambien muchos perifericos, como lo son la pantalla, el táctil sobre la pantalla, botones, sensores de huellas digitales, luz del flash, leds, camaras, gps, acelerometros, modem de comunicaciones, parlante, microfono, radio wireless, radio FM, etc.

<p>
Debido a que todos los dispositivos son lentos comparados con la velocidad de ejecución de la CPU
los sistemas están diseñados para solapar el procesamiento con la E/S.
Esto significa, por ejemplo, que si el procesador inicia una operación de E/S en un dispositivo puede seguidamente
continuar ejecutando instrucciones de un programa. Luego, el procesador verificará 
(en un momento conveniente) si la operación se completó; o alternativamente el dispositivo 
puede enviar una señal al procesador cuando se haya completado la operación.

<p>
Las diferentes velocidades entre procesador, memoria y periféricos, influencian, tambien, la organización de estos componentes dentro de la computadora, por lo que es usual que varios  
buses sean utilizados para interconectarlos.
Antiguas minicomputadoras tuvieron dos o más buses, uno para conectar la memoria
a la CPU, y otro para conectar los dispositivos de E/S a la CPU.
Un posterior refinamiento, por ejemplo en la PDP-11 Unibus, utilizó un 
unico bus para todas las transferencias entre periféricos de E/S, memoria
y la CPU. Las computadoras personales PC de arquitectura x86 tuvieron 
tambien
distintas organizaciones de conexión. En la Figura 1
se presenta un diagrama de bloques de una PC tipica de los años 2000.

<!--figure class=column-top-->
<figure>
<a href="imagenes/norte-sur2.png"><img style="width: 100%" src="imagenes/norte-sur2.png"></a>
<figcaption>Estructura de CPU, memoria, chipsets y buses de una PC típica en el año 2000.</figcaption>
</figure>


<p>
<span class="sidenote"><span class=ix>bus del sistema</span></span>
Haya uno o mas buses en el sistema el propósito es siempre el mismo: acarrear señales de control, datos y direcciones entre los componentes conectados al bus. En la Figura 2 puede observarse un esquema general de este objetivo.
Las señales de dirección permiten a un programa seleccionar entre diferentes dispositivos de E/S conectados al sistema, mientras que las líneas de datos accarean la información actual que se está transfiriendo.
Las señales de control especifican qué tipo de operación se desea realizar (leer, escribir, señalar un interrupción, etc).

Además, no es necesario que todos los buses sean del mismo tamaño si el sistema tiene mas de uno. Por ejemplo, el bus de memoria del antiguo procesador 8086 tiene 20 líneas de dirección y 16 líneas de datos, mientras que el bus de E/S tiene 16 líneas de dirección y 8 o 16 líneas de datos.

Sea cual sea la organización de interconexión es en el bus del sistema en donde la información de la computadora fluye. 
Cualquier componente conectado puede colocar información en el bus, y cualquier otro puede tomar información.
Por lo que la utilización de un bus en las computadoras establece una organización sencilla para el pasaje de información entre las diferentes unidades funcionales inter conectadas.

<!--figure class=column-top-->
<figure>
<a href="imagenes/entrada-salida2.png"><img style="width: 100%" src="imagenes/entrada-salida2.png"></a>
<figcaption>Componentes de una computadoras interconectados por un bus.</figcaption>
</figure>

</section>

<section>

<header>Periféricos, controladores e Interfaces</header>

<p>
<span class="sidenote"><span class=ix>dispositivo de E/S</span></span>
Un <b>dispositivo de E/S (o periférico de E/S)</b> es un equipamiento hardware que realiza alguna función de comunicación con el mundo exterior para la computadora.
<p>
<span class="sidenote"><span class=ix>controlador de E/S</span></span>
Un <b>controlador de E/S</b> dirige la operación del periférico de acuerdo a comandos recibidos desde el procesador. Tambien, convierte los datos recibidos por el sistema en el formato requerido por el dispositivo, y viceversa.
<p>
Usualmente el periférico en sí se encuentra fuera de la parte visible de la CPU (chip/motherboard), 
mientras que casi siempre, el controlador se encuentra junto con el procesador y la memoria.
Muchos periféricos diferentes tienen el objetivo de convertir datos del mundo exterior de la computadora a datos
que esta pueda procesar, estos son por ej.: teclados, escáneres, joysticks, sensores, etc; otros periféricos
convierten datos de la computadora dentro de formas que se utilicen en el mundo exterior: monitores,
impresoras, etc.
El propósito de algunos es simplemente almacenar gran cantidad de datos para utilizarlos mas adelante:
discos rígidos, pen drives, memorias flash, cintas magnéticas, etc.

<aside>
<b>¿Es el controlador parte del periférico?</b> Algunas veces la línea divisoria entre el periférico y su controlador es confusa.
Como ejemplo, observe el teclado y su controlador en la Figura 3. El circuito decodificador del teclado (keyboard scan) convierte una depresión de una
tecla en un número de 7bits. Además, la interfaz (controlador) conectada al bus ubica este número en 
el bus de datos si el procesador lo requiere. Pareciera que el periférico consiste del bloque 
decodificador y de los bloques de interfaz con el bus (controlador).
En un sistema típico, el decodificador se encuentra empaquetado con el teclado mismo, y la mayoría
de los diseñadores de computadoras dicen que el bloque decodificador es parte del teclado
y el controlador consiste sólo del bloque de interfaz conectado al bus (dentro de la computadora).
Afortunadamente la línea divisoria no tiene importancia en programas
de E/S que controlen un teclado, más importante es el modelo de programación 
de E/S que un programa utiliza.
</aside>

<!--figure class=column-top-->
<figure>
<a href="imagenes/keyboard2.png"><img style="width: 80%" src="imagenes/keyboard2.png"></a>
<figcaption>Diagrama de bloques de un teclado y su controlador.</figcaption>
</figure>

<p>
<span class="sidenote"><span class=ix>puertos de E/S</span></span>
La <b>interfaz de E/S (o puertos de E/S)</b> es una parte del controlador del dispositivo (ver Figura 4).
Está compuesto por registros de estado, control y datos; y son accedidos (generalmente) por el procesador durante operaciones
de entrada y salida.
Los registros de estado proveen información del estado del dispositivo de E/S a la CPU. Estos registros son frecuentemente de sólo-lectura, lo que significa que la CPU puede leerlos, pero no cambiar su contenido.
Los registros de control son utilizados por la CPU para configurar y controlar el dispositivo. Los bits en estos registros podrían llegar a ser de sólo-escritura, lo que significa que la CPU los puede alterar, pero no leerlos. Igualmente, en muchos sistemas y dispositivos estos pueden ser tambien de lectura y escritura.
Los registros de datos son utilizados para leer o enviar datos desde y hace el dispositivo de E/S.

<p>En algunas circunstancias, un registro podría tener más de una de las categorías anteriores, por ejemplo, un registro podría tener ciertos bits para configurar el dispositivo, y otros bits para obtener información del estado.
Dispositivos sencillos como el teclado y ratón pueden ser representados con sólo unos pocos registros, mientras que dispositivos más complejos como los discos y adaptadores gráficos podrían tener docenas de registros.

El modelo de programación de E/S del dispositivo (su documentacion, hoja de datos, etc) describe todos los registros asociados con el dispositivo, su contenido, y la forma de utilizarlos.

<!--figure class=column-top-->
<figure>
<a href="imagenes/figura4.png"><img style="width: 100%" src="imagenes/figura4.png"></a>
<figcaption>Componentes del controlador del dispositivo.</figcaption>
</figure>

<p>
Por ejemplo, el dispositivo UART conectado al CBUS de la placa de desarrollo Malta (cpu MIPS)
contiene 8 registros de 8 bits cada uno.
Si conectado a este periférico se encuentra una terminal (pantalla y teclado)
el registro RXTX del UART contendrá el código ASCII de cada tecla presionada en la terminal.
Para leer un dato desde el teclado, un programa debe ejecutar alguna instrucción
que transfiera el contenido de RXTX dentro de un registro del procesador.
Una vez que el dato se encuentra en el procesador este puede ser manipulado
con otros datos.
<p>
Aunque si bien el controlador del UART escribe datos provenientes del teclado de la terminal en RXTX,
el procesador puede transferir tambien a ese registro del UART un código ASCII. Si lo hace, la interfaz
del dispositivo enviará el dato a la terminal, que una vez recepcionado, lo mostrará en pantalla. 
Por lo tanto, el UART es un dispositivo de entrada y salida.
<p>Desafortunadamente, el mecanismo anterior no es tan sencillo de programar debido principalmente a la gran diferencia de velocidad entre la CPU y el dispositivo UART. Si el procesador
necesita enviar un dato a pantalla a través del registro RXTX, debe verificar primero
(al menos) el estado del dispositivo, para conocer si el periférico está en condiciones de recibir nuevos datos (o si está ocupado, por ejemplo, procesando algún dato anterior).
Para esto, un programa debería ejecutar alguna instrucción que transfiera el contenido
del registro LSSTAT (Line Status Register) a un registro del procesador, para procesar su contenido.
Si el contenido de este registro indica que el periférico está en condiciones de aceptar datos, el programa puede entonces
transferir el código ASCII al registro RXTX, para mostrarlo en la pantalla.

</section>

<section>

<header>Programación de E/S</header>

En la programación de la E/S se debe utilizar alguna técnica soportada por el hardware
para transferir datos hacia (y desde)
los dispositivos (hacia los registros de la interfaz del controlador del dispositivo).
Los datos pueden ir desde el dispositivo hacia el procesador, o hacia la memoria;
o si el dispositivo es de salida los datos serán transferidos desde 
la CPU o la memoria
hacia la interfaz del controlador del dispositivo (registros).

<p>
Las tres estrategias (técnicas) utilizadas en la acualidad son: <b>E/S programada (polling), E/S mediante interrupciones, y E/S mediante acceso directo a memoria (DMA).</b>
La estrategia utilizada debe estar soportada por los modelos de programación de la computadora y los dispositivos en particular.

<p>
Para comenzar una operación de "entrada" el programa debe iniciar una transferencia de datos
desde el dispositivo (desde su interfaz). Por ejemplo, un programador podría 
escribir, en una máquina miniMIPS, la instrucción <code>lb $t3, 0xffff0004($zero)</code>
la cual lee el código ASCII desde el <b>registro de datos</b> de la interfaz del teclado, y lo coloca
en el registro de la CPU t3. 
En este caso, el programador utilizó una instrucción "cargar byte",
la cual es la misma instrucción que se utiliza 
en MIPS para cargar en registros de la CPU datos que estén en la memoria RAM.
Además, en vez de utilizar una dirección de memoria RAM, el programador utilizó la dirección
efectiva 0xffff0004, la cual es la dirección del registro de datos del teclado en miniMIPS.
<span class="sidenote"><span class=ix>E/S mapeada en memoria</span></span>
A este tipo de acceso se le denomina <b>E/S mapeada en memoria</b>, ya que el procesador trata a la <b>interfaz del controlador
de un dispositivo</b> (registros del controlador) como una extensión de la memoria. 

Esta estructura es utilizada en la mayoría de los procesadores modernos.
<p>
La Figura 5 (b) muestra la organización del hardware de una computadora con E/S mapeada en memoria. 
Parte del espacio de memoria normal de la CPU está dedicado a los dispositivos de E/S, por lo que cada registro de E/S (puerto) tiene una dirección 
de memoria
en el espacio direccionable del procesador.
Además, las arquitecturas que utilizan E/S mapeada en memoria pueden utilizar las mismas instrucciones de acceso a memoria, por lo que no se necesitan instrucciones especiales (ni se utilizan codigo de operaciones especificos en el campo de operacion de una instruccion).
Como desventaja se suele mencionar que parte del espacio direccionable es utilizado, por lo que se reduce el tamaño de la memoria física que el sistema puede tener. Esto, aunque si bien es correcto, no es tan importante en las arquitecturas modernas con espacios direccionables de 32 y 64 bits.


 
<!--figure class=column-top-->
<figure>
<a href="imagenes/figura52.png"><img style="width: 100%" src="imagenes/figura52.png"></a>
<figcaption>(a) E/S aislada. (b) E/S mapeada en memoria.</figcaption>
</figure>



<span class="sidenote"><span class=ix>E/S aislada</span></span>
<p>Algunos microprocesadores tienen en cambio otro mecanismo, llamado comunmente <b>E/S aislada (isolated I/O)</b>, las cuales utiliza instrucciones especiales para 
realizar entrada y salida. 
Por ejemplo en los procesadores intel x86 y en los antiguos procesadores
z8000 el conjunto de instrucciones de cada arquitectura presentaban dos instrucciones especiales para acceder a los registros de cada dispositivo: in y out en x86 e inb y outb en el z8000.
En estas arquitecturas, cuando el procesador ejecuta la instrucción <code>OUT 0xFF01</code> (ejemplo hipotético), el contenido
del acumulador (o registro especial de la CPU) es colocado en el bus de datos. Al mismo tiempo,
el número 0xFF01 es ubicado en los bits menos significativos del bus de direcciones, y un 
pulso (señal de control) es generado en la línea de escritura de E/S (I/O write).
Cada interfaz de cada dispositivo en el sistema monitorea las líneas del bus de dirección.
Cuando una interfaz de E/S observa  su propia dirección junto con una señal de escritura o lectura (de registro), la interfaz actúa en consecuencia y realiza la ejecución de la tranferencia de dato de E/S.

<p>En la E/S aislada, la memoria principal y los dispositivos se encuentran en diferentes buses, por lo 
que el espacio direccionable por referencias a memoria e instrucciones de E/S son diferentes, aunque ellos
pudieran reconocer la misma dirección numérica. Es decir, por ejemplo, la dirección 0xFF01 podría 
ser una dirección de memoria principal, y a la vez ser una dirección de un registro de un 
un dispositivo. El tipo de instrucción es la que determina si es uno u otro.
Debido a esto es que se suele denominar E/S aislada (espacio de direcciones diferentes para memoria y E/S).


</section>

<section>

<header>Licencia, obras originales, permisos y bibliografía</header>

<br><b>Licencia de uso</b> 
<p>Se permite copiar, distribuir y modificar este apunte; unicamente para fines académicos. Se permite copiar y distribuir copias modificadas con el mismo fin. Se solicita
mantener la información de los autores de este apunte y de las  obras
originales.

<br>
<br>
<b>Obras originales y permisos</b>
<p>Para ver el listado de obras originales y permisos escritos de los autores visite:
<a href="http://www.scm.tees.ac.uk/users/a.clements/">
http://www.scm.tees.ac.uk/users/a.clements/</a> 
<br>
<br>

<b>Bibliografía extra</b>
<ul>
<li>- Artículo "What Every Programmer Should Know About Memory", Ulrich Drepper, Red Hat, Inc, drepper@redhat.com, 2007.
</ul>

</section>

<section>
<div class="page-break">
<header>Indice</header>
</div>

<ol id=ref></ol>

</section>
</article>
<script>
Prince.trackBoxes = true;
Prince.addEventListener("complete", makeix, false);



function getText(e)
{
    var text = "";

    for (var x = e.firstChild; x != null; x = x.nextSibling)
    {
	if (x.nodeType == x.TEXT_NODE)
	{
	    text += x.data;
	}
	else if (x.nodeType == x.ELEMENT_NODE)
	{
	    text += getText(x);
	}
    }

    return text;
}

function getElementsByClassName(oElm, strTagName, strClassName){
	var arrElements = (strTagName == "*" && oElm.all)? oElm.all : oElm.getElementsByTagName(strTagName);
	var arrReturnElements = new Array();
	strClassName = strClassName.replace(/\-/g, "\\-");
	var oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$)");
	var oElement;
	for(var i=0; i<arrElements.length; i++){
		oElement = arrElements[i];
		if(oRegExp.test(oElement.className)){
			arrReturnElements.push(oElement);
		}
	}
	return (arrReturnElements)
}


function makeref()  // turn references into endnotes
{

// get element that will hold list of references

  var refcontainer = document.getElementById('ref');
  var ids = new Array();
  var ent = new Array();
  var refnum = 0;

// find all elements that contain index entries, go through them sequentially

//  ref = getElementsByClassName(document, "*", "ref");
  ref = document.getElementsByTagName("cite");
  for(var i=0; i < ref.length; i++) {
    ref[i].setAttribute("id", "ref"+i);

// store the reference in a string in an associative array

//    var str = getText(ref[i]);
    var str = ref[i].innerHTML;

// check to see if the entry is there already, if not add it

    var refnum = ent.indexOf(str);
    if (refnum < 0) {
      ent.push(str);
    } 
    refnum = ent.indexOf(str) + 1;

//  replace content of original element 

    ref[i].innerHTML = '[' + refnum + ']';
  }

// go through list of index entries, create one li element per entry

  for (var i=0; i<ent.length; i++) {
    var li = document.createElement("li");
    refnum=i+1;
    li.innerHTML = '['+refnum+'] '+ent[i];
    refcontainer.appendChild(li); 
  }
}

function maketf()    // make table footnotes
{

// get element that will hold list table footnotes

  var tfcontainer = document.getElementById('tf');
  var ids = new Array();
  var ent = new Array();
  var tfnum = 0;

// find all elements that contain index entries, go through them sequentially

  tf = getElementsByClassName(document, "*", "tablefoot");
  var tfstr="";
  for(var i=0; i < tf.length; i++) {
    tf[i].setAttribute("id", "tf"+i);

// store the reference in a string in an associative array

//    var str = getText(ref[i]);
    var str = tf[i].innerHTML;

// check to see if the entry is there already, if not add it

    var tfnum = ent.indexOf(str);
    if (tfnum < 0) {
      ent.push(str);
    } 
    tfnum = ent.indexOf(str) + 1;
    tfstr = tfstr + '*';

//  replace content of original element 

    tf[i].innerHTML = tfstr + ' ';
  }

// go through list of index entries, create one li element per entry

  tfstr = "";
  for (var i=0; i<ent.length; i++) {
    var li = document.createElement("li");
    tfnum=i+1;
    tfstr = tfstr + '*';
    li.innerHTML = tfstr+' '+ent[i];
    tfcontainer.appendChild(li); 
  }
}

function maketoc()
{
    var hs = document.getElementsByTagName("h2");
    var toc = document.getElementById('toc');
    for(var i=0; i<hs.length; i++)
    {
        var text = document.createTextNode(getText(hs[i]));
        hs[i].setAttribute("id", "ch"+i);
        var link = document.createElement("a");
        link.setAttribute("href", "#ch"+i);
        link.appendChild(text);
        var li = document.createElement("li");
        li.appendChild(link);
        toc.appendChild(li); 
    }
}


function makeix()
{
  var ixcontainer = document.getElementById('ix');
  var ids = new Array();
  var ent = new Array();

// find all elements that contain index entries, go through them sequentially

  ix = getElementsByClassName(document, "*", "ix");
  for(var i=0; i<ix.length; i++)
    {
        ix[i].setAttribute("id", "ix"+i);

// store the reference in a string in an associative array

        var str = getText(ix[i]);
        if (ids[str]) {
          ids[str] = ids[str]+",ix"+i;
        } else {
          ids[str] = "ix"+i;
        }

// check to see if the index entry is there already, if not add it

        if ((ent.join("")).indexOf(str) < 0)
          { ent.push(str) }
    }

// the ent array now contains list of index entries, sort it!


  ent.sort();

  var str="<ul id=ix>";

// go through list of index entries, create one li element per entry

  for (var i=0; i<ent.length; i++)
    {
       str = str+"<li><span class=entry>"+ent[i]+"</span>";

       var idsa = ids[ent[i]].split(",");

//     idsa is an array which contains strings like "ix0","ix4" 

       var prevpage = 0;
       var collapsing = "";
       var divider = "";

       for (var j=0; j<idsa.length; j++)
        {
           var e = document.getElementById(idsa[j]);
           var eboxes = e.getPrinceBoxes(); 
           if (eboxes.length > 0) {
              var box = eboxes[0];
              var page = box.pageNum;

//            page now has the name numer of the index entry

              if (page > prevpage) {  //


                 if (prevpage==0) { // first index for this entry
                   str=str+"<span id=#"+idsa[j]+">"+page+"</span>";
                   prevpage = page;
                 } else if (page > (prevpage + 1)) { // e.g. prevpage = 1; page = 3
                   if (collapsing) { // now we must terminate collapse
                     str=str+"-<span id=#"+idsa[j]+">"+prevpage+"</span>"; 
                     collapsing = 0; // not collapsing any more
                   } else {
                     str=str+", <span id=#"+idsa[j]+">"+page+"</span>"; 
                     prevpage = page;
                   }
                 } else { // e.g.  prevpage = 43  and page = 44, who knows what is next?
                   str=str+"<!-- collapsing "+page+" -->";
                   collapsing = "-"; // true
                   prevpage = page;
                 }
              } else {
                 str=str+"<!--skipping id=#"+idsa[j]+" on page "+page+"-->";
              }
           }
        }

        // if we are collapsing at the end, terminate 


     if (collapsing) {
           str=str+"-<span id=#"+idsa[j-1]+">"+page+"</span>"; //
        }
    }
  str=str+"</ul>"; 
  console.log(str);
}


</script>

</html>
﻿

