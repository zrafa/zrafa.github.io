<html>
<style>
@import url(http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic,700italic);

/* Set up basic page design */

@page { 
  /* size: letter; */
  size: a4;

  @footnotes {
    border-top: thin solid black; 
    border-clip: 100px;
    padding: 0;
    margin: 0.6em 0 0 0;
    padding: 0.3em 0 0 0;
  }
  @bottom-center {
    content: counter(page);
  }
}

article { 
  /* columns: 2; */
  columns: 1;
  column-gap: 0.25in; 
  /* font: 11pt "PT Serif", serif; */
  font-family: Lato, "Roboto Condensed", sans-serif;
  hyphens: auto;             /* turn on hyphenation */
  text-align: justify;       /* and justification */
  counter-reset: figure;
}

/* basic settings on commonly used elements */

code {
  	font-family: 8pt, monospace;
  font-size: 70%;
}
html, body, div, header, p, blockquote, ul, ol, li, pre { 
 	margin-left: 5%;
	padding: 0; 
  	font-family: Lato, "Roboto Condensed", sans-serif;
}

p{
	/* margin-left:3em;
	margin-right:0.5em; */
	margin-left:0em;
	margin-right:0em;
  	font-family: Lato, "Roboto Condensed", sans-serif;

}
b { 
  /* background-color: #eeeefF; */
  font-style: italic;
  font-family: bold 12pt Lato, "Roboto Condensed", sans-serif;
}
li { margin-left: 1.5em }

header { 
  font: bold 12pt "PT Serif", serif; 
  margin: 1em 0 0.3em;
  page-break-after: avoid; break-after: avoid;
  margin: 0 0 0em -10%;
}


#toc, #ix, li { list-style-type: none; margin: 0; padding: 0 }
#toc a:after { content: leader('.') target-counter(attr(href), page) }

#ix span.entry:after { content: leader('.') }



p { text-indent: 1.5em }
header + p { text-indent: 0 }
cite { font-style: normal }
pre { margin: 0.5em 0; padding: 0.3em; background: #eee }
ul { margin: 0.8em 0 }

/* sections-specific styling */

section.lead { 
  column-span: all; 
  text-align: center;
  /* margin: 2em 0; */
 	margin-left: -10%;
  font-style: italic;
}

aside {
  background: #ddf;
  text-align: justify;       /* and justification */
  padding: 0.6em 1.3em 0.6em 1.3em; 
  font-family: Lato, "Roboto Condensed", sans-serif;
/*  width: 100%; */
  margin-left: 0%;
  box-sizing: border-box;
  float: none;
  hyphens: manual;
}



section.lead h1 { 
	font: bold 14pt "PT Serif", serif; 
	text-align: center 

} /* used for article title */

section.lead .authors {
  display: table;
  margin: 0 auto; 
}

section.lead .vcard {
  display: table-cell;
  text-align: center;
  font: 11pt "PT Serif", serif;
}

section.lead a {
  display: block;
  padding: 0 1em;
  color: black;
  text-decoration: none;
}

section.abstract header {
  text-align: center;
}

section.refs p {
  margin: 0.5em 0;
  text-indent: 0;
}

section.refs .author { 
  font-variant: small-caps;
}

section.refs ol, table ol {
  margin: 0; padding: 0;
}

section.refs li, table li {
  list-style-type: none;
  margin-left: 1.5em;
  text-indent: -1.5em;
}

table { border-collapse: collapse; margin: 1em 0; width: 100%; }

table td {
  border: thin solid black;
  padding: 0.2em;
}

/* counters */

section:first-of-type { counter-reset: section }
section.nonum { counter-reset: none }

section { counter-increment: section }
section.nonum { counter-increment: none }

header:before { content: counters(section, ".") " " }
section.nonum header:before { content: none }

/* footnotes */

::footnote-call {
  content: "[" counter(footnote, lower-latin) "]";
  font-size: 83%;
  vertical-align: super;
  line-height: none
}

::footnote-marker {
  content: "[" counter(footnote, lower-latin) "]";
  list-style-position: inside;
  margin: 0; padding: 0 0.3em 0 0;
}

.foot {
  float: prince-column-footnote;
  font-size: 90%;
  footnote-style-position: outside;
  margin: 0.3em 0 0 1.3em; padding: 0; text-indent: 0;
}

/* page floats */

.column-top { float: column-top; margin-bottom: 2em }
.column-bottom { float: column-bottom;  margin-top: 2em }
.top { float: top;  margin-bottom: 2em }
.bottom { float: bottom;  margin-top: 2em }
top figcaption, .bottom figcaption { margin-left: 2em; margin-right: 2em }

.sidenote {
  float: left;
  clear: left;
  margin: 0 0 0em -20%;
  width: 18%;
  font-size: 0.9em;
/*  font-style: normal; */
  text-indent: 0;
  text-align: right;
  page-break-inside: avoid;
  color:#4C50AF;
/*  font: 8pt;  */
  font-style:italic;
}


figure { 
  counter-increment: figure;
  font-size: 0.9em;
/*  min-width: 300px; */
  max-width: 640px;
/*  min-height: 300px; */
  max-height: 480px;
  text-align: left;
  width: 90%;
  float: center;
  margin: 0.4in;
}

figcaption:before { 
  font-weight: bold;
  content: "Figure " counter(figure) ": " 
}

@media screen {
  body {
    margin: 3em;
  }





p.sidenote + p, p.caption, p.art { text-indent: 0 }


p.date {
    text-align: right;
}

  article { 
    columns: 1;
    font: 16px/1.3 "PT Serif", serif;
    width: 100%;
  }
  .top, .bottom, .column-top, .column-bottom {
    float: right; 
    width: 55%;
    margin-right: -60%;
  }
  /* aside { float: none; width: auto; margin: 1em 0 } */
  aside { float: none; width: auto; margin: 0em 0em 0em 0em }
}


#customers {
    font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

#customers td, #customers th {
    border: 1px solid #ddd;
    padding: 8px;
  font: 10pt "PT Serif", serif;
}

#customers tr:nth-child(even){
background-color: #f2f2f2;
  font: 10pt "PT Serif", serif;
}

#customers tr:hover {
background-color: #ddd;
  font: 10pt "PT Serif", serif;
}

#customers th {
    /* font: 8pt */
    padding-top: 12px;
    padding-bottom: 12px;
    text-align: left;
    /* background-color: #4CAF50; */
    background-color: #4C50AF;
    color: white;
  font: 10pt "PT Serif", serif;
}
</style>

<!-- body onload="makeref(); maketf();"-->
<body onload="maketoc();">

<article>


<section class=lead>
<h1>Entrada y Salida (E/S) </h1>

<div class=authors>

<div class="vcard">
<i>
 <a class="url fn" href="http://github.com/zrafa">Rafael Ignacio Zurita</a>
 <a class="url org" href="mailto:rafa@fi.uncoma.edu.ar">rafa@fi.uncoma.edu.ar</a>
</div>

<div class="vcard">
 <a class="url fn" href="http://faiweb.uncoma.edu.ar">Rodolfo del Castillo</a>
 <a class="url org" href="mailto:rdc@fi.uncoma.edu.ar">rdc@fi.uncoma.edu.ar</a>
</i>

</div>

</div>
<p class="author">Apunte de cátedra
<span class="foot">
Obra derivada con permiso escrito (detalles de las obras originales y permisos en la última sección) de articulos de Alan Clements, para las materias de arquitecturas de computadoras, de la universidad de Teesside, Inglaterra; y de Computer Programming and Architecture the VAX-11, Henry Levy, Digital Press (1980). 
</span>

</section>

<section class='abstract nonum'>

<header>Resumen</header>

<!-- toc -->

<p>En las unidades anteriores hemos examinado la estructura interna y operación de una unidad de procesamiento central (CPU). 
De cualquier manera, para que una computadora tenga un valor real para las personas, debe poder comunicarse de alguna manera con sus usuarios.
Despues de todo, no tiene ningún sentido en diseñar y crear una super computadora del tamaño de un clip, y que pueda resolver
la ultima duda existencial de la vida, el universo, y todo lo demás, si no puede, de alguna manera, decirnos la respuesta.
En este apunte se presentan los caminos y mecanismos por los cuales la información entra y sale de una computadora, y los dispositivos o periféricos conectados a la computadora para llevar a cabo este propósito (por ejemplo, una impresora y el monitor led).

</section>

<section>

<header>Subsistema de Entrada y Salida</header>

<p>La organización básica de una computadora consiste de un procesador, la memoria, y el subsitema de entrada y salida (E/S).
El subsistema de entrada y salida está compuesto de dispositivos de E/S (o periféricos) y controladores de dispositivos, interconectados al procesador y memoria mediantes buses del sistema. 
<p>
La "entrada y salida" son señales o datos recibidos y enviados por el sistema, y
permite a la computadora 
comunicarse con el mundo exterior, tal vez con una persona (usuario) o con otro sistema (procesador). 
Por ejemplo, mediante la entrada y salida la computadora puede cargar programas y datos en la memoria 
(por ejemplo desde un medio de almacenamiento como el disco rígido), presentar datos a sus usuarios (en una pantalla), 
recibir entrada (desde un teclado y mouse), o enviar datos a otros sistemas mediante la red.
<p>
Existe una amplia variedad de periféricos que pueden ser parte de un subsistema de entrada y salida.
Los dispositivos mas comunes en una PC son los discos rígidos, teclado, mouse, monitor, impresora, escaner, camara, microfono, parlantes, leds, placas de red, lectoras de CD/DVD/SD, gamepads, etc.
Un otro ejemplo son los smartphones, en donde existen tambien muchos perifericos, como lo son la pantalla, el táctil sobre la pantalla, botones, sensores de huellas digitales, luz del flash, leds, camaras, gps, acelerometros, modem de comunicaciones, parlante, microfono, radio wireless, radio FM, etc.

<p>
Debido a que todos los dispositivos son lentos comparados con la velocidad de ejecución de la CPU
los sistemas están diseñados para solapar el procesamiento con la E/S.
Esto significa, por ejemplo, que si el procesador inicia una operación de E/S en un dispositivo puede seguidamente
continuar ejecutando instrucciones de un programa. Luego, el procesador verificará 
(en un momento conveniente) si la operación se completó; o alternativamente el dispositivo 
puede enviar una señal al procesador cuando se haya completado la operación.

<p>
Las diferentes velocidades entre procesador, memoria y periféricos, influencian, tambien, la organización de estos componentes dentro de la computadora, por lo que es usual que varios  
buses sean utilizados para interconectarlos.
Antiguas minicomputadoras tuvieron dos o más buses, uno para conectar la memoria
a la CPU, y otro para conectar los dispositivos de E/S a la CPU.
Un posterior refinamiento, por ejemplo en la PDP-11 Unibus, utilizó un 
unico bus para todas las transferencias entre periféricos de E/S, memoria
y la CPU. Las computadoras personales PC de arquitectura x86 tuvieron tambien, con el tiempo,
distintas organizaciones de conexión. Por ejemplo, en la Figura 1
se presenta un diagrama de bloques de una PC tipica de los años 2000 (a), y una organización actual en (b).

<p>
Haya uno o mas buses en el sistema el propósito es siempre el mismo: acarrear señales de control, datos y direcciones entre los componentes conectados al bus. En la Figura 2 puede observarse un esquema general de este objetivo.
Las señales de dirección permiten a un programa seleccionar entre diferentes dispositivos de E/S conectados al sistema, mientras que las líneas de datos accarean la información actual que se está transfiriendo.
Las señales de control especifican qué tipo de operación se desea realizar (leer, escribir, señalar un interrupción, etc).

Además, no es necesario que todos los buses sean del mismo tamaño si el sistema tiene mas de uno. Por ejemplo, el bus de memoria del antiguo procesador 8086 tiene 20 líneas de dirección y 16 líneas de datos, mientras que el bus de E/S tiene 16 líneas de dirección y 8 o 16 líneas de datos.

Sea cual sea la organización de interconexión es en el bus del sistema en donde la información de la computadora fluye. 
Cualquier componente conectado puede colocar información en el bus, y cualquier otro puede tomar información.
Por lo que la utilización de un bus en las computadoras establece una organización sencilla para el pasaje de información entre las diferentes unidades funcionales inter conectadas.


</section>

<section>

<header>Periféricos e Interfaces</header>

Un dispositivo periférico (o dispositivo de E/S) realiza alguna función para la computadora.
Una interface de E/S (o interface del dispositivo) controla la operación de un periférico de acuerdo a comandos del procesador. 
La interface es parte del controlador de dispositivo, el cual convierte también los datos dentro del formato que sea requerido por el dispositivo, y viceversa.
<p>
Usualmente el periférico en sí se encuentra fuera de la parte visible de la CPU (chip/motherboard), 
mientras que casi siempre, la interface se encuentra junto con el procesador y la memoria.
Muchos periféricos diferentes tienen el objetivo de convertir datos del mundo exterior de la computadora a datos
que esta pueda procesar, estos son por ej.: teclados, escáneres, joysticks, etc; otros periféricos
convierten datos de la computadora dentro de formas que se utilicen en el mundo exterior: monitores,
impresoras, etc.
El propósito de algunos es simplemente almacenar gran cantidad de datos para utilizarlos mas adelante:
discos rígidos, pen drives, memorias flash, cintas magnéticas, etc.

<p>
Algunas veces la línea divisoria entre el periférico y la interface es confusa.
Como se muestra en el ejemplo de la FIg 10-2 el circuito decodificador del teclado convierte una depresión de una
tecla en un número de 7bits. La interface conectada al bus ubica este número en 
el bus de E/S si el procesador lo requiere. Pareciera que el controlador consiste del bloque 
decodificador y de los bloques de interface con el bus. 
En un sistema típico, el decodificador se encuentra empaquetado con el teclado mismo, y la mayoría
de los diseñadores de computadoras dicen que el bloque decodificador es parte del teclado
y el controlador consiste sólo del bloque de interface conectado al bus.
Afortunadamente la línea divisoria no tiene importancia en programas
de E/S que controlen un teclado, más importante es el modelo de programación 
de E/S que un programa utiliza.

<aside>
<b>Controlador y su interface vs Interface y puertos:</b> Dependiendo de la bibliografía utilizada, la terminología tambien puede ser confusa.
Algunos autores utilizan el concepto <b>controlador de dispositivo</b> para 
especificar al componente de hardware que se ncuentra entre el periférico y el bus del sistema. En esta terminología se suele utilizar el término <b> interfaz de E/S</b> para hacer referencia a los registros de datos, estado y control del dispositivo.
En cambio, otros autores utilizan la terminología <b>interface del dispositivo</b> para referirse al controlador de dispositivo recién mencionado; y el término <b>puertos de E/S</b> para mencionar a los registros de datos, estado y control.
<p>Ambas terminologías hacen referencia a lo mismo. En la Figura 3 se presenta graficamente esta diferencia.
</aside>

<p>
La interfaz de E/S (o puerto) es una parte del controlador del dispositivo (ver Figura 4).
Está compuesto por los registros de estado, control y datos del dispositivo, y son accedidos (generalmente) por el procesador durante operaciones
de entrada y salida.
El modelo de programación de E/S del dispositivo (su documentacion, hoja de datos, etc) describe todos los registros asociados con el dispositivo y la forma de utilizarlos.
<p>
Por ejemplo, el dispositivo UART conectado al CBUS de la placa de desarrollo Malta (cpu MIPS)
contiene 8 registros de 8 bits cada uno (Figura 4).
Si conectado a este periférico se encuentra una terminal (pantalla y teclado)
el registro RXTX del UART contendrá el código ASCII de cada tecla presionada en la terminal.
Para leer un dato desde el teclado, un programa debe ejecutar alguna instrucción
que transfiera el contenido de RXTX dentro de un registro del procesador.
Una vez que el dato se encuentra en el procesador este puede ser manipulado
con otros datos.
<p>
Aunque si bien el controlador del UART escribe datos provenientes del teclado de la terminal en RXTX,
el procesador puede transferir tambien a ese registro del UART un código ASCII. Si lo hace, la interfaz
del dispositivo enviará el dato a la terminal, que una vez recepcionado, lo mostrará en pantalla. 
Por lo tanto, el UART es un dispositivo de entrada y salida.
<p>Desafortunadamente, el mecanismo anterior no es tan sencillo de programar. Si el procesador
necesita enviar un dato a pantalla a través del registro RXTX, debe verificar primero
(al menos) el estado del dispositivo, para conocer si el periférico está en condiciones de recibir nuevos datos.
Para esto, un programa debería ejecutar alguna instrucción que transfiera el contenido
del registro LSSTAT (Line Status Register) a un registro del procesador, para procesar su contenido.
Si el contenido de este registro indica que el periférico está en condiciones de aceptar datos, el programa puede entonces
transferir el código ASCII al registro RXTX, para mostrarlo en la pantalla.

</section>

<section>

<header>Programación de E/S</header>

En la programación de la E/S se debe utilizar alguna técnica soportada por el hardware
para transferir datos hacia (y desde)
los dispositivos (hacia los registros de la interfaz del controlador del dispositivo).
Los datos pueden ir desde el dispositivo hacia el procesador, o hacia la memoria;
o si el dispositivo es de salida los datos serán transferidos desde 
la CPU o la memoria
hacia la interfaz del controlador del dispositivo (registros).

<p>
Las tres estrategias (técnicas) utilizadas en la acualidad son: <b>E/S programada (polling), E/S mediante interrupciones, y E/S mediante acceso directo a memoria (DMA).</b>
La estrategia utilizada debe estar soportada por los modelos de programación de la computadora y los dispositivos en particular.

<p>
Para comenzar una operación de "entrada" el programa debe iniciar una transferencia de datos
desde el dispositivo (desde su interfaz). Por ejemplo, un programador podría 
escribir, en una máquina miniMIPS, la instrucción <code>lb $t3, 0xffff0004($zero)</code>
la cual lee el código ASCII desde el <b>registro de datos</b> de la interfaz del teclado, y lo coloca
en el registro de la CPU t3. 
En este caso, el programador utilizó una instrucción "cargar byte",
la cual es la misma instrucción que se utiliza 
en MIPS para cargar en registros de la CPU datos que estén en la memoria RAM.
Además, en vez de utilizar una dirección de memoria RAM, el programador utilizó la dirección
efectiva 0xffff0004, la cual es la dirección del registro de datos del teclado en miniMIPS.
A este tipo de acceso se le denomina <b>E/S mapeada en memoria</b>, ya que el procesador trata a la <b>interfaz del controlador
de un dispositivo</b> (registros del controlador) como una extensión de la memoria. 

Esta estructura es utilizada en la mayoría de los procesadores modernos.
La Figura X muestra la organización del hardware de una computadora con E/S mapeada en memoria. 
Parte del espacio de memoria normal de la CPU está dedicado a los dispositivos de E/S, por lo que cada registro de E/S (puerto) tiene una dirección 
de memoria
en el espacio direccionable del procesador.
Además, las arquitecturas que utilizan E/S mapeada en memoria pueden utilizar las mismas instrucciones de acceso a memoria, por lo que no se necesitan instrucciones especiales (ni se utilizan codigo de operaciones especificos en el campo de operacion de una instruccion).
Como desventaja se suele mencionar que parte del espacio direccionable es utilizado, por lo que se reduce el tamaño de la memoria física que el sistema puede tener. Esto, aunque si bien es correcto, no es tan importante en las arquitecturas modernas con espacios direccionables de 32 y 64 bits.


 


<p>Algunos microprocesadores tienen en cambio otro mecanismo, llamado comunmente <b>E/S aislada (isolated I/O)</b>, las cuales utiliza instrucciones especiales para 
realizar entrada y salida. 
Por ejemplo en los procesadores intel x86 y en los antiguos procesadores
z8000 el conjunto de instrucciones de cada arquitectura presentaban dos instrucciones especiales para acceder a los registros de cada dispositivo: in y out en x86 e inb y outb en el z8000.
En estas arquitecturas, por ejemplo, cuando el procesaodr ejecuta la instrucción <code>OUT 0xFF01</code>, el contenido
del acumulador (o registro especial de la CPU) es colocado en el bus de datos. Al mismo tiempo,
el número 0xFF01 es ubicado en los bits menos significativos del bus de direcciones, y un 
pulso (señal de control) es generado en la línea de escritura de E/S (I/O write).
Cada interfaz de cada dispositivo en el sistema monitorea las líneas del bus de dirección.
Cuando una interfaz de E/S observa  su propia dirección junto con una señal de escritura o lectura (de registro), la interfaz actúa en consecuencia y realiza la ejecución de la tranferencia de dato de E/S.

<p>En la E/S aislada, la memoria principal y los dispositivos se encuentran en diferentes buses, por lo 
que el espacio direccionable por referencias a memoria e instrucciones de E/S son diferentes, aunque ellos
pudieran reconocer la misma dirección numérica. Es decir, por ejemplo, la dirección 0xFF01 podría 
ser una dirección de memoria principal, y a la vez ser una dirección de un registro de un 
un dispositivo. El tipo de instrucción es la que determina si es uno u otro.
Debido a esto es que se suele denominar E/S aislada (espacio de direcciones diferentes para memoria y E/S).


</section>

<section>

<header>Licencia, obras originales, permisos y bibliografía</header>

<br><b>Licencia de uso</b> 
<p>Se permite copiar, distribuir y modificar este apunte; unicamente para fines académicos. Se permite copiar y distribuir copias modificadas con el mismo fin. Se solicita
mantener la información de los autores de este apunte y de las  obras
originales.

<br>
<br>
<b>Obras originales y permisos</b>
<p>Este apunte es un trabajo derivado 
(con permiso escrito) de las siguientes obras (ordenadas
de la mas utilizada a la menos utilizada): 

<ul>
<li>- Apuntes de cátedra del Profesor Alan Clements 
<a href="http://www.scm.tees.ac.uk/users/a.clements/">
http://www.scm.tees.ac.uk/users/a.clements/</a> 
Lamentablemente el sitio no está ya 
mas disponible, pero puede ser alcanzado utilizando 
<a href="http://www.archive.org">
http://www.archive.org</a>.
<li>- Libro "Computer Programming and Architecture the VAX-11", Henry Levy, Digital Press, 1980. 
</ul>

<p><b>Alan Clements</b> fue profesor de las materias "Sistemas de computadoras",
"Organización de computadoras" y "Arquitectura de computadoras",
en la Universidad de Teesside, Inglaterra (actualmente está retirado). Es también el autor de los siguientes libros:

<ul>
<li>-Microprocessor Systems Design: 68000 Family Hardware, Software and Interfacing. ISBN 978-0534948221. 1997
<li>-Computer Organization & Architecture : Themes and Variations. ISBN 978-1111987046, 2012.
</ul>

<p>Permiso escrito:
<code>
<br>
<br>From: Alan Clements <alanclements@ntlworld.com>
<br>Date: Wed, 5 Jul 2017 16:48:40 +0100
<br>Message-ID: <CAOa+wOKJtQJtZouFioSrvvarpxGzTsKoFU9Co-AJEHhS1xV99g@mail.gmail.com>
<br>Subject: Re: About permission of notes and articles
<br>To: Rafael Ignacio Zurita <rafa@fi.uncoma.edu.ar>
<br>
<br>--94eb2c072bc01bcd8c055393eff3
<br>Content-Type: text/plain; charset="UTF-8"
<br>Content-Transfer-Encoding: quoted-printable
<br>
<br>Hola Rafael,
<br>
<br>Thank you for writing to me.
<br>
<br>The academic address was at Teesside university. I have now retired and,
<br>sadly, can't use that address any more.
<br>
<br>This is my main address and am perfectly happy for you to write to me at
<br>this address.
<br>
<br>Por supuesto, you can use my material from the web and translate it into
<br>Spanish. I would be delighted for you to translate it into Spanish.
<br>
<br>If there is anything I can do to help, please let me know.
<br>
<br>[...]
<br>
<br>Best wishes
<br>
<br>Alan
<br>
</code>

<p><b>Hank Levy</b> trabajó en los años 70 y 80 en la arquitectura de 
computadora VAX, en Digital Equipment Corporation (DEC).
Actualmente es profesor e investigador en la Universidad de 
Washington (https://www.cs.washington.edu/people/faculty/levy),
y es el autor del libro utilizado. .


<p>Permiso escrito:

<code>
<br>
<br>From: Hank Levy <levy@cs.washington.edu>
<br>Date: Sun, 14 May 2017 20:34:40 -0700
<br>Message-ID: <ce5a06d63ae8289b85c35ba69eb6458d@mail.gmail.com>
<br>Subject: RE: About rights of the Computer Programming and Architecture 2nd Edition The Vax book
<br>To: Rafael Ignacio Zurita <rafa@fi.uncoma.edu.ar>
<br>Content-Type: text/plain; charset="UTF-8"
<br>
<br>
<br>Hi Rafael,
<br>
<br>Wow -- that's very nice.   The book is no longer in print and I don't have
<br>any problem with you using it however you want.   So....I hereby give
<br>you permission to translate parts of the book to use for your class for
<br>students.
<br>
<br>Best of luck!
<br>
<br>hank
<br>
</code>

<br>
<br>
<b>Bibliografía extra</b>
<ul>
<li>- Artículo "What Every Programmer Should Know About Memory", Ulrich Drepper, Red Hat, Inc, drepper@redhat.com, 2007.
</ul>

</section>

<section>
<div class="page-break">
<header>Indice</header>
</div>

<ol id=ref></ol>

</section>
</article>
<script>
Prince.trackBoxes = true;
Prince.addEventListener("complete", makeix, false);



function getText(e)
{
    var text = "";

    for (var x = e.firstChild; x != null; x = x.nextSibling)
    {
	if (x.nodeType == x.TEXT_NODE)
	{
	    text += x.data;
	}
	else if (x.nodeType == x.ELEMENT_NODE)
	{
	    text += getText(x);
	}
    }

    return text;
}

function getElementsByClassName(oElm, strTagName, strClassName){
	var arrElements = (strTagName == "*" && oElm.all)? oElm.all : oElm.getElementsByTagName(strTagName);
	var arrReturnElements = new Array();
	strClassName = strClassName.replace(/\-/g, "\\-");
	var oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$)");
	var oElement;
	for(var i=0; i<arrElements.length; i++){
		oElement = arrElements[i];
		if(oRegExp.test(oElement.className)){
			arrReturnElements.push(oElement);
		}
	}
	return (arrReturnElements)
}


function makeref()  // turn references into endnotes
{

// get element that will hold list of references

  var refcontainer = document.getElementById('ref');
  var ids = new Array();
  var ent = new Array();
  var refnum = 0;

// find all elements that contain index entries, go through them sequentially

//  ref = getElementsByClassName(document, "*", "ref");
  ref = document.getElementsByTagName("cite");
  for(var i=0; i < ref.length; i++) {
    ref[i].setAttribute("id", "ref"+i);

// store the reference in a string in an associative array

//    var str = getText(ref[i]);
    var str = ref[i].innerHTML;

// check to see if the entry is there already, if not add it

    var refnum = ent.indexOf(str);
    if (refnum < 0) {
      ent.push(str);
    } 
    refnum = ent.indexOf(str) + 1;

//  replace content of original element 

    ref[i].innerHTML = '[' + refnum + ']';
  }

// go through list of index entries, create one li element per entry

  for (var i=0; i<ent.length; i++) {
    var li = document.createElement("li");
    refnum=i+1;
    li.innerHTML = '['+refnum+'] '+ent[i];
    refcontainer.appendChild(li); 
  }
}

function maketf()    // make table footnotes
{

// get element that will hold list table footnotes

  var tfcontainer = document.getElementById('tf');
  var ids = new Array();
  var ent = new Array();
  var tfnum = 0;

// find all elements that contain index entries, go through them sequentially

  tf = getElementsByClassName(document, "*", "tablefoot");
  var tfstr="";
  for(var i=0; i < tf.length; i++) {
    tf[i].setAttribute("id", "tf"+i);

// store the reference in a string in an associative array

//    var str = getText(ref[i]);
    var str = tf[i].innerHTML;

// check to see if the entry is there already, if not add it

    var tfnum = ent.indexOf(str);
    if (tfnum < 0) {
      ent.push(str);
    } 
    tfnum = ent.indexOf(str) + 1;
    tfstr = tfstr + '*';

//  replace content of original element 

    tf[i].innerHTML = tfstr + ' ';
  }

// go through list of index entries, create one li element per entry

  tfstr = "";
  for (var i=0; i<ent.length; i++) {
    var li = document.createElement("li");
    tfnum=i+1;
    tfstr = tfstr + '*';
    li.innerHTML = tfstr+' '+ent[i];
    tfcontainer.appendChild(li); 
  }
}

function maketoc()
{
    var hs = document.getElementsByTagName("h2");
    var toc = document.getElementById('toc');
    for(var i=0; i<hs.length; i++)
    {
        var text = document.createTextNode(getText(hs[i]));
        hs[i].setAttribute("id", "ch"+i);
        var link = document.createElement("a");
        link.setAttribute("href", "#ch"+i);
        link.appendChild(text);
        var li = document.createElement("li");
        li.appendChild(link);
        toc.appendChild(li); 
    }
}


function makeix()
{
  var ixcontainer = document.getElementById('ix');
  var ids = new Array();
  var ent = new Array();

// find all elements that contain index entries, go through them sequentially

  ix = getElementsByClassName(document, "*", "ix");
  for(var i=0; i<ix.length; i++)
    {
        ix[i].setAttribute("id", "ix"+i);

// store the reference in a string in an associative array

        var str = getText(ix[i]);
        if (ids[str]) {
          ids[str] = ids[str]+",ix"+i;
        } else {
          ids[str] = "ix"+i;
        }

// check to see if the index entry is there already, if not add it

        if ((ent.join("")).indexOf(str) < 0)
          { ent.push(str) }
    }

// the ent array now contains list of index entries, sort it!


  ent.sort();

  var str="<ul id=ix>";

// go through list of index entries, create one li element per entry

  for (var i=0; i<ent.length; i++)
    {
       str = str+"<li><span class=entry>"+ent[i]+"</span>";

       var idsa = ids[ent[i]].split(",");

//     idsa is an array which contains strings like "ix0","ix4" 

       var prevpage = 0;
       var collapsing = "";
       var divider = "";

       for (var j=0; j<idsa.length; j++)
        {
           var e = document.getElementById(idsa[j]);
           var eboxes = e.getPrinceBoxes(); 
           if (eboxes.length > 0) {
              var box = eboxes[0];
              var page = box.pageNum;

//            page now has the name numer of the index entry

              if (page > prevpage) {  //


                 if (prevpage==0) { // first index for this entry
                   str=str+"<span id=#"+idsa[j]+">"+page+"</span>";
                   prevpage = page;
                 } else if (page > (prevpage + 1)) { // e.g. prevpage = 1; page = 3
                   if (collapsing) { // now we must terminate collapse
                     str=str+"-<span id=#"+idsa[j]+">"+prevpage+"</span>"; 
                     collapsing = 0; // not collapsing any more
                   } else {
                     str=str+", <span id=#"+idsa[j]+">"+page+"</span>"; 
                     prevpage = page;
                   }
                 } else { // e.g.  prevpage = 43  and page = 44, who knows what is next?
                   str=str+"<!-- collapsing "+page+" -->";
                   collapsing = "-"; // true
                   prevpage = page;
                 }
              } else {
                 str=str+"<!--skipping id=#"+idsa[j]+" on page "+page+"-->";
              }
           }
        }

        // if we are collapsing at the end, terminate 


     if (collapsing) {
           str=str+"-<span id=#"+idsa[j-1]+">"+page+"</span>"; //
        }
    }
  str=str+"</ul>"; 
  console.log(str);
}


</script>

</html>
﻿

