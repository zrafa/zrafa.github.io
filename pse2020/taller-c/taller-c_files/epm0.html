<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Eduardo Grosclaude" />
  <meta name="date" content="2014-12-09" />
  <title>Taller de Lenguaje C</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./pandoc.css" type="text/css" />
</head>
<style> ul { font-family: "Arial"; } </style>
<style> p { font-family: Tahoma,Calibri,Verdana ; font-size:18px } </style>

<!--body-->
<body background="http://ditext.com/sellars/epm-n.html" bgcolor="#ffffff" text="
#000000" link="#0000ff" vlink="#800080" alink="#ff0000">



<div id="header">
<p><strong>Programación de Sistemas Embebidos<br>
Facultad de Informática<br>
Universidad Nacional del Comahue</strong></p>

<img src="img/1eL3wpz.jpg" alt="Tux Programming" width="180" height="180" style="padding:20px; float:left">
<br>
<h1 class="title">Taller de Lenguaje C</h1>
<h2 class="author">Eduardo Grosclaude</h2>
<h3 class="date">2014-12-09</h3>
<br>
<br>
<br>
<br>
<h1 id="sec:tc-introduccion">Introducción al Lenguaje C</h1>
<p>El lenguaje de programación C fue creado en 1972 por investigadores de Bell Telephone Laboratories, con el objetivo de reescribir un sistema operativo, el UNIX, en un lenguaje de alto nivel, para poder adaptarlo (es decir, <em>portarlo</em>) a diferentes arquitecturas. Por este motivo sus creadores se propusieron metas de diseño especiales, tales como:</p>
<ul>
<li><p>Poder utilizar todos los recursos del hardware ().</p></li>
<li><p>Obtener código generado eficiente en uso de memoria y en tiempo de ejecución (programas pequeños y veloces).</p></li>
<li><p>Compilador portable (implementable en cualquier arquitectura).</p></li>
</ul>
<p>Actualmente existen implementaciones de C para todas las arquitecturas y sistemas operativos, y es el lenguaje más utilizado para la <strong>programación de sistemas</strong>. Por su gran eficiencia resulta ideal para la programación de <strong>sistemas operativos</strong>, <strong>drivers de dispositivos</strong>, <strong>herramientas de programación</strong>. El 95% del sistema operativo UNIX está escrito en C, así como gran parte de los modernos sistemas y ambientes operativos, y los programas de administración o aplicación que corren sobre ellos.</p>
<h2 id="características-del-lenguaje">Características del lenguaje</h2>
<p>C es un lenguaje compilado. Sintácticamente, presenta similitudes formales con C++, con Java, y aun con Pascal, pero las diferencias en otros aspectos son muy importantes. A pesar de permitir <strong>operaciones de bajo nivel</strong>, tiene las <strong>estructuras de control</strong>, y permite la <strong>estructuración de datos</strong>, propias de los lenguajes procedurales de alto nivel.</p>
<h3 id="paradigma-procedural">Paradigma procedural</h3>
<p>El lenguaje C <strong>no es un lenguaje orientado a objetos</strong>, sino que adhiere al paradigma tradicional de <strong>programación imperativa o procedural</strong>. No soporta la orientación a objetos propiamente dicha, al no proporcionar herramientas fundamentales, como la herencia. Sin embargo, algunas características del lenguaje permiten que un proyecto de programación se beneficie, de todas maneras, con la aplicación de algunos principios de la orientación a objetos, tales como el ocultamiento de información y el encapsulamiento de responsabilidades. El lenguaje <strong>C++</strong>, orientado a objetos, <strong>no es</strong> una versión más avanzada del lenguaje o un compilador de C con más capacidades, sino que <strong>se trata de un lenguaje completamente diferente</strong>.</p>
<h3 id="minimalidad">Minimalidad</h3>
<p>Un programa en C es, por lo general, más <strong>sintético</strong> que en otros lenguajes procedurales; la idea central que atraviesa todo el lenguaje es la minimalidad. La definición del lenguaje consta de muy pocos elementos, y tiene muy pocas <strong>palabras reservadas</strong>.</p>
<p>Como rasgo distintivo, en C no existen, rigurosamente hablando, funciones o procedimientos de uso general del programador. Por ejemplo, <strong>no tiene funciones de entrada/salida</strong>; la definición del lenguaje apenas alcanza a <strong>las estructuras de control y los operadores</strong>. La idea de definir un lenguaje sin funciones es, por un lado, hacer posible que el compilador sea <strong>pequeño, fácil de escribir e inmediatamente portable</strong>; y por otro, permitir que sea el usuario quien defina sus propias funciones cuando el problema de programación a resolver tenga requerimientos especiales. El usuario puede escribir sus propios procedimientos (llamados <strong>funciones</strong> aunque no devuelvan valores). Aunque existe la noción de <strong>bloque</strong> de sentencias (sentencias encerradas entre llaves), el lenguaje se dice <strong><em>no</em> estructurado en bloques</strong> porque no pueden definirse funciones dentro de otras.</p>
<h3 id="versatilidad-a-un-precio">Versatilidad, a un precio</h3>
<p>El lenguaje entrega completamente el control de la máquina subyacente al programador, no realizando controles en tiempo de ejecución. Es decir, no verifica condiciones de error comunes como <strong><em>overflow</em> de variables</strong>, <strong>errores de entrada/salida</strong>, o <strong>consistencia de argumentos</strong> en llamadas a funciones. Ofrece una gran libertad sintáctica al programador. No es fuertemente tipado. Cuando es necesario, se realizan <strong>conversiones automáticas de tipo</strong> en las asignaciones, a veces <strong>con efectos laterales inconvenientes</strong> si no se tiene precaución. Una función que recibe determinados parámetros formales puede ser invocada con argumentos reales de otro tipo.</p>
<p>Se ha dicho que estas características posibilitan la realización de proyectos complejos con más facilidad que otros lenguajes como Pascal o Ada, más estrictos; aunque al mismo tiempo, así resulta más difícil detectar errores de programación en tiempo de compilación. Como resultado, es frecuente que el principiante, y aun el experto, cometan errores de programación que no se hacen evidentes enseguida, ocasionando problemas y costos de desarrollo. En este sentido, según los partidarios de la tipificación estricta, C no es un buen lenguaje. Gran parte del esfuerzo de desarrollo del estándar ANSI se dedicó a dotar al C de elementos para mejorar esta deficiencia.</p>
<p>Una característica especial del lenguaje C es que el <strong>pasaje de argumentos a funciones</strong> se realiza siempre <strong>por valor</strong>. ¿Qué ocurre cuando una función debe <strong>modificar</strong> datos que recibe como argumentos? La única salida es pasarle –por valor– la dirección del dato a modificar. Las consecuencias de este hecho son más fuertes de lo que parece a primera vista, ya que surge la necesidad de todo un conjunto de técnicas de <strong>manejo de punteros</strong> que no siempre son bien comprendidas por los programadores poco experimentados, y abre la puerta a sutiles y escurridizos errores de programación. Quizás este punto, junto con el de la ausencia de comprobaciones en tiempo de ejecución, sean los que le dan al C fama de .</p>
<h3 id="portabilidad">Portabilidad</h3>
<p>Los <strong>tipos de datos</strong> no tienen un tamaño determinado por la definición del lenguaje, sino que diferentes implementaciones pueden adoptar diferentes convenciones. Paradójicamente, esta característica obedece al objetivo de lograr la <strong>portabilidad</strong> de los programas en C. El programador está obligado a no hacer ninguna suposición sobre los tamaños de los <strong>objetos de datos</strong>, ya que lo contrario haría al software dependiente de una arquitectura determinada ().</p>
<h3 id="biblioteca-standard">Biblioteca Standard</h3>
<p>Pese a no estar formalmente definidas funciones de entrada/salida en el lenguaje, se ha establecido un conjunto mínimo de funciones, llamado la <strong>Biblioteca Standard</strong> del lenguaje C, que todos los compiladores proveen, a veces con agregados. La filosofía de la Biblioteca Standard es la portabilidad, es decir, casi no incluye funciones que sean específicas de un sistema operativo determinado. Aquellas que sí incluye están orientadas a la programación de sistemas, y a veces no resultan suficientes para el programador de aplicaciones. No provee, por ejemplo, la capacidad de manejo de archivos indexados, ni funciones de entrada/salida interactiva por consola que sean seguras (). Estas deficiencias se remedian utilizando bibliotecas de funciones (creadas por el usuario u obtenidas de otros programadores).</p>
<p>Las funciones de la Biblioteca Standard no tienen ningún privilegio sobre las del usuario y <strong>sus nombres no son palabras reservadas</strong>; el usuario puede reemplazarlas por sus propias funciones simplemente dándoles el mismo nombre.</p>
<h2 id="evolución-del-lenguaje">Evolución del lenguaje</h2>
<p>La primera definición oficial del lenguaje fue dada en 1978 por <strong>Brian Kernighan y Dennis Ritchie</strong> (Fig. [fig:kandr]) en su libro <strong>El lenguaje de programación C</strong>. Este lenguaje fue llamado <strong>C K&amp;R</strong>, por las iniciales de sus autores. En 1983 se creó el comité ANSI para el lenguaje, que en 1988 estableció el estándar ANSI C, con algunas reformas sobre el C K&amp;R. Simultáneamente, Kernighan y Ritchie publicaron la segunda edición de su libro, describiendo la mayor parte de las características del ANSI C.</p>
<p><img src="./img/kernighan.jpg" title="fig:" alt="Brian Kernighan y Dennis Ritchie, los creadores del lenguaje C" width="130" height="150" /> <img src="./img/dennisritchie.jpg" title="fig:" alt="Brian Kernighan y Dennis Ritchie, los creadores del lenguaje C" width="130" height="150" /></p>
<p>Algunas nuevas características de C99 son:</p>
<ul>
<li><p>Matrices de tamaño variable</p></li>
<li><p>Soporte de números complejos</p></li>
<li><p>Tipos y de al menos 64 bits</p></li>
<li><p>Familia de funciones</p></li>
<li><p>Comentarios al estilo de C++ prefijando las líneas con la secuencia .</p></li>
<li><p>Familia de funciones</p></li>
<li><p>Tipo boolean</p></li>
</ul>
<h2 id="el-ciclo-de-compilación">El ciclo de compilación</h2>
<p>Las herramientas esenciales de un ambiente de desarrollo, además de cualquier <strong>editor de textos</strong>, son el <strong>compilador</strong>, el <strong>vinculador</strong>, <strong>linkeditor</strong> o <em>linker</em>, y el <strong>bibliotecario</strong>. A estas herramientas básicas se agregan otras, útiles para automatizar la compilación de proyectos extensos, almacenar y recuperar versiones de programas fuente, comprobar sintaxis en forma previa a la compilación, etc. Según el ambiente operativo y producto de software de que se trate, estas herramientas pueden ser comandos de línea independientes, con salidas de texto simples, o encontrarse integradas en una interfaz de usuario uniforme, en modo texto o modo gráfico.</p>
<p>Cuando encontramos varias de estas herramientas integradas en una sola aplicación, decimos que se trata de un <strong>IDE</strong> (<em>Integrated Development Environment</em>) o ambiente de desarrollo integrado. Un IDE oculta el ciclo de compilación al usuario, con la intención de simplificar el proceso de desarrollo. Sin embargo, conviene conocer qué función se cumple, y qué producto se espera, en cada fase del ciclo de compilación, para poder interpretar las diferentes situaciones de error y poder corregirlas.</p>
<h3 id="compilador">Compilador</h3>
<ul>
<li><p>El compilador acepta un archivo <strong>fuente</strong>, posiblemente relacionado con otros (una <strong>unidad de traducción</strong>), y genera con él un <strong>módulo objeto</strong>. Este módulo objeto contiene porciones de código ejecutable mezclado con <strong>referencias</strong>, aún no resueltas, a variables o funciones cuya definición no figura en los fuentes de entrada. Estas referencias quedan en forma simbólica en el módulo objeto hasta que se resuelvan en un paso posterior.</p></li>
<li><p>Si ocurren errores en esta fase, se deberán a problemas de sintaxis (el código escrito por el programador no respeta la definición del lenguaje).</p></li>
</ul>
<h3 id="vinculador-linkeditor-o-linker">Vinculador, linkeditor o <em>linker</em></h3>
<ul>
<li><p>El vinculador recibe como entrada un conjunto de módulos objeto y busca <strong>resolver</strong>, vincular, o enlazar, las referencias simbólicas en ellos, buscando la definición de las variables o funciones faltantes en los mismos objetos o en bibliotecas. Éstas pueden ser la Biblioteca Standard, u otras provistas por el usuario. Cuando el linker encuentra la definición de un objeto buscado (es decir, de una variable o función), la copia en el archivo resultante de salida (la <em>resuelve</em>). El objetivo del linker es resolver todas las referencias pendientes para producir un programa ejecutable.</p></li>
<li><p>Si ocurren errores en esta fase, se deberán a que existen variables o funciones cuya definición no ha sido dada (no se encuentran en las unidades de traducción procesadas, ni en ninguna biblioteca conocida por el linker).</p></li>
</ul>
<h3 id="bibliotecario">Bibliotecario</h3>
<ul>
<li><p>El bibliotecario es un programa administrador de módulos objeto. Su función es reunir módulos objeto en archivos llamados <strong>bibliotecas</strong>, y luego permitir la extracción, borrado, reemplazo y agregado de módulos. El conjunto de módulos en una biblioteca se completa con una tabla de información sobre sus contenidos para que el linker pueda encontrar rápidamente aquellos módulos donde se ha definido una variable o función, y así extraerlos durante el proceso de linkedición.</p></li>
<li><p>El bibliotecario es utilizado por el usuario cuando desea mantener sus propias bibliotecas. La creación de bibliotecas propias del usuario ahorra tiempo de compilación y permite la distribución de software sin revelar la forma en que se han escrito los fuentes y protegiéndolo de modificaciones.</p></li>
</ul>
<p>Una vez que el código ha sido compilado y vinculado, obtenemos un programa ejecutable. Los errores que pueden producirse en la ejecución ya no corresponden a problemas de compilación, sino que se deben a aspectos de diseño del programa que deben ser corregidos por el programador.</p>
<h2 id="un-primer-ejemplo">Un primer ejemplo</h2>
<p>El clásico ejemplo de todas las introducciones al lenguaje C es un programa llamado .</p>
<pre><code>#include &lt;stdio.h&gt;
/* El primer programa! */
main()
{
	printf(&quot;Hola, gente!\n&quot;);
}</code></pre>
<h3 id="estructura-del-programa">Estructura del programa</h3>
<ul>
<li><p>Este programa minimal comienza con una <strong>directiva de preprocesador</strong> que indica incluir en la unidad de traducción al archivo de cabecera o <em>header</em> <strong>stdio.h</strong>. Éste contiene, entre otras cosas, la declaración (o <strong>prototipo</strong>) de la función de salida de caracteres <strong>printf()</strong>, perteneciente a la Biblioteca Standard. Los prototipos se incluyen para advertir al compilador de los tipos de las funciones y de sus argumentos.</p></li>
<li><p>Entre los pares de caracteres especiales <strong>/*</strong> y <strong>*/</strong>se puede insertar cualquier cantidad de líneas de comentarios.</p></li>
<li><p>La función <strong>main()</strong> es el cuerpo principal del programa (es por donde comenzará la ejecución). Todas las funciones en C están delimitadas por un par de llaves. Terminada la ejecución de main(), terminará el programa.</p></li>
<li><p>La función imprimirá la cadena entre comillas, que es una <strong>constante string</strong> terminada por un carácter de <strong>nueva línea</strong> (la secuencia especial ).</p></li>
</ul>
<h3 id="compilación-del-programa">Compilación del programa</h3>
<p>Para ver el primer ejemplo en C en funcionamiento:</p>
<ol>
<li><p>Copiar el programa con cualquier editor de textos y guardarlo en un archivo llamado en el directorio de trabajo del usuario.</p></li>
<li><p>Sin cambiar de directorio, invocar al compilador ejecutando el comando . Por defecto, el compilador <strong>gcc</strong> invocará al vinculador <strong>ld</strong> para generar el ejecutable a partir del archivo objeto intermedio generado.</p></li>
<li><p>Ejecutar el programa con el comando .</p></li>
</ol>
<p>Notar el <em>punto y barra</em> del principio al ejecutar el programa. El punto y barra le indican al <strong>shell</strong> que debe buscar el programa en el directorio activo.</p>
<h4 id="otra-manera">Otra manera</h4>
<ol>
<li><p>Como antes, copiar el programa, o usar el mismo archivo fuente de hace un momento.</p></li>
<li><p>Sin cambiar de directorio, ejecutar el comando en una consola o terminal.</p></li>
<li><p>Ejecutar el programa con el comando .</p></li>
</ol>
<p>La diferencia es que en el primer caso invocamos directamente al compilador , mientras que en el segundo caso utilizamos la herramienta , que nos asiste en la compilación de proyectos. En el ejemplo, le decimos al compilador que procese el archivo fuente , y que el ejecutable de salida (opción , de <em>output</em>) reciba el nombre .</p>
<h3 id="el-comando-make">El comando make</h3>
<p>Cuando damos un comando como , utilizamos el comando <strong>make</strong> para compilar y vincular el programa <strong>hola.c</strong>. El comando <strong>make</strong> contiene la inteligencia para:</p>
<ul>
<li><p>buscar, en el directorio activo, archivos fuente llamados <strong>hola.*</strong>;</p></li>
<li><p>determinar (a partir de la extensión) que el hallado se trata de un programa en C;</p></li>
<li><p>ver que no existe en el directorio activo un programa ejecutable llamado <strong>hola</strong>, o que, si existe, su fecha de última modificación es anterior a la del fuente;</p></li>
<li><p>razonar que, por lo tanto, es necesario compilar el fuente <strong>hola.c</strong> para producir el ejecutable <strong>hola</strong>;</p></li>
<li><p>e invocar con una cantidad de opciones por defecto al compilador <strong>gcc</strong>, y renombrar la salida con el nombre <strong>hola</strong>. Éste será el ejecutable que deseamos producir.</p></li>
</ul>
<p>Si se invoca al comando <strong>make</strong> una segunda vez, éste comprobará, en base a las fechas de modificación de los archivos fuente y ejecutable, que no es necesaria la compilación (ya que el ejecutable es posterior al fuente). Si editamos el fuente para cambiar algo en el programa, invocar nuevamente a <strong>make</strong> ahora repetirá la compilación (porque ahora el fuente es posterior al ejecutable).</p>
<h4 id="makefiles">Makefiles</h4>
<p>En casos sencillos, el comando <strong>make</strong> puede hacer en forma autónoma todo el trabajo descripto anteriormente. Sin embargo, cuando se construyen proyectos más complejos, formados por muchos fuentes con interdependencias complejas, o cuando se requieren diferentes opciones del proceso de compilación (o aun diferentes compiladores), entonces es conveniente escribir una guía de actividades para <strong>make</strong>. Esta guía se guarda en un archivo llamado <strong>makefile</strong> o <strong>Makefile</strong>. Al ser invocado, el programa <strong>make</strong> buscará un archivo con alguno de esos nombres en el directorio actual, y si lo encuentra, ejecutará las tareas que se indican allí.</p>
<p>Un <strong>makefile</strong> tiene una sintaxis específica y sumamente compleja, pero suele ser suficiente con conocer unas pocas reglas de escritura para escribir <strong>makefiles</strong> que resulten útiles.</p>
<ul>
<li><p>Los objetos que se desea construir se llaman <strong>goals</strong> o metas. Se indican con rótulos al principio del renglón y seguidos por dos puntos.</p></li>
<li><p>Las dependencias de cada <strong>goal</strong> se escriben inmediatamente después de los dos puntos. Las dependencias son los archivos cuya fecha <strong>make</strong> comprobará para saber si debe reconstruir un <strong>goal</strong> o no.</p></li>
<li><p>Las acciones que se debe llevar a cabo para cada <strong>goal</strong>, en caso de que deba ser reconstruido, se indican a continuación, sin renglones intermedios, e indentadas.</p></li>
<li><p>Un <strong>goal</strong>, sus dependencias y las acciones asociadas, se separan de las demás con un renglón en blanco.</p></li>
</ul>
<p>Así, por ejemplo, el siguiente <strong>makefile</strong> es equivalente al conocimiento que <strong>make</strong> aplicó para construir el programa de nuestro primer ejemplo:</p>
<pre><code>hola: hola.c
	gcc hola.c -o hola
	</code></pre>
<p>Se recomienda consultar el manual del comando <strong>make</strong>, ya que es muy útil para el desarrollador C dominar el lenguaje de escritura de <strong>makefiles</strong>. En particular, es valioso comprender que <strong>make</strong> es versátil y puede utilizarse para automatizar muchas otras tareas, no solamente las de desarrollo de programas.</p>
<h2 id="mapa-de-memoria-de-un-programa">Mapa de memoria de un programa</h2>
<p>Luego de la compilación y vinculación, el programa ejecutable queda contenido en un archivo. Al ser invocado, el sistema operativo lo carga en memoria, y allí se despliega en una cantidad de secciones de diferentes tamaños y con distintas funciones.</p>
<p>Los sistemas operativos modernos, salvo raras excepciones, administran la memoria física usando sistemas de memoria virtual. Cada sistema de memoria virtual funciona de modo diferente. La manera como se distribuyen realmente las secciones de un programa en la memoria física depende fuertemente de la forma de administración de memoria del sistema operativo para el cual ha sido compilado y vinculado. Sin embargo, el siguiente modelo puede servir de referencia para ilustrar algunas particularidades y problemas que irán surgiendo con el estudio del lenguaje.</p>
<p>El programa cargado en memoria (Fig. [fig:mapa]) se dividirá en cuatro regiones: código o <strong>texto</strong>, <strong>datos estáticos</strong>, <strong>heap</strong> (o región de datos dinámicos), y <strong>stack</strong> (o pila).</p>
<p>El tamaño de las regiones de código y de datos estáticos está determinado al momento de compilación y es inamovible. Las otras dos regiones quedan en un bloque cuyo tamaño inicial es ajustado por el sistema operativo al momento de la carga, pero puede variar durante la ejecución. Este bloque es compartido entre ambas regiones. Una de ellas, la de datos dinámicos, o heap, crece (hacia direcciones de memoria más altas); la otra, la pila del programa, o stack, crece (en sentido opuesto).</p>
<dl>
<dt>Texto del programa</dt>
<dd><p>La región de texto contendrá el <strong>código del programa</strong>, es decir, la versión ejecutable de las <strong>instrucciones</strong> que escribió el programador, traducidas por el compilador al lenguaje de la máquina. En general, el programa fuente C se compondrá de funciones, que serán replicadas a nivel de máquina por subrutinas en el lenguaje del procesador subyacente. Algunas instrucciones C resultarán en última instancia en invocaciones a funciones del sistema (por ejemplo, cuando necesitamos escribir en un archivo).</p>
</dd>
<dt>Datos estáticos</dt>
<dd><p>La región de datos estáticos es un lugar de almacenamiento para datos del programa que quedan definidos al momento de la compilación. Se trata de datos cuya vida o instanciación no depende de la invocación de las funciones. Son las variables estáticas, definidas en el cuerpo del programa que es común a todas las funciones. A su vez, esta zona se divide en dos: la de <strong>datos estáticos inicializados</strong> explícitamente por el programa (zona a veces llamada <strong>bss</strong> por motivos históricos) y la zona de <strong>datos estáticos sin inicializar</strong> (a veces llamada <strong>data</strong>), que será llenada con ceros binarios al momento de la carga del programa.</p>
</dd>
<dt>Stack</dt>
<dd><p>El stack, o <strong>pila</strong>, aloja las variables locales de las funciones a medida que esas funciones son invocadas. Cada función que declare variables locales obtendrá espacio de almacenamiento para esas variables en el stack. Al terminar la función, como el ámbito de sus variables desaparece, esas variables son desalojadas, y el espacio que ocupaban vuelve a quedar disponible.</p>
</dd>
<dt>Heap</dt>
<dd><p>Un programa C puede utilizar estructuras de datos dinámicas, como listas o árboles, que vayan creciendo al agregárseles elementos. El programa puede memoria cada vez que necesite alojar un nuevo elemento de estas estructuras dinámicas, o para crear buffers temporarios para cualquier uso que sea necesario. El <strong>heap</strong> es la zona de donde el programa obtiene esos trozos de memoria, solicitada en forma dinámica al sistema operativo. El límite del heap se irá desplazando hacia las direcciones superiores.</p>
</dd>
</dl>
<p>Este modelo será útil en varias ocasiones para explicar algunas cuestiones especiales del lenguaje C.</p>
<p>Analicemos en qué lugares quedarán alojados los elementos del programa siguiente.</p>
<pre><code>int a = 1;
int b;
int fun()
{
	int c;
	c = a + b;
}
main()
{
	fun();
}</code></pre>
<ul>
<li><p>Las variables y corresponden a la zona de datos estáticos. La variable está inicializada con 1, pero como no está inicializada, recibirá un valor 0.</p></li>
<li><p>La variable aparecerá en el stack cuando se ejecute la función .</p></li>
<li><p>Las instrucciones de máquina procedentes de la compilación del programa (funciones y ) serán almacenadas en la región de texto.</p></li>
</ul>
<p>[sec:tc-introduccion-preg] El principal objetivo de diseño de quienes crearon el C era Posibilidad de acceder a los recursos de hardware. Portabilidad del compilador. Eficiencia del código generado. Todas las anteriores.</p>
<p>La primera definición oficial del lenguaje fue dada por Kernighan y Ritchie en 1975. 1978. 1983. 1988.</p>
<p>Las palabras reservadas de C son Muchas. Pocas. Exactamente las de entrada/salida. Exactamente tantas como las de Pascal.</p>
<p>La Biblioteca Standard de C Provee funciones para todas las necesidades. Está escrita por el usuario. No provee funciones para todas las necesidades.</p>
<p>El lenguaje C No realiza recolección de basura pero sí controles de tiempo de ejecución. No realiza controles de tiempo de ejecución pero sí recolección de basura. Realiza ambas cosas. Ninguna de las dos cosas.</p>
<p>Los programas en C son portables porque Se lo dotó de control de tipos de datos. Los tipos de datos no tienen un tamaño definido por el lenguaje. Los tamaños de los tipos de datos son idénticos en todas las implementaciones. Se lo basó en una única arquitectura.</p>
<p>El pasaje de argumentos a funciones en C se hace por valor. por referencia. por nombre.</p>
<p>El lenguaje C pertenece al paradigma Lógico. Procedural. Funcional. Orientado a objetos.</p>
<p>Las herramientas del ciclo de compilación comprenden compilador y linkeditor. editor, compilador, linkeditor y bibliotecario. compilador y Biblioteca Standard.</p>
<p>El utilitario genera archivos objeto. ejecutables. bibliotecas. todo lo anterior.</p>
<p>El mapa de memoria del programa comprende Dos regiones estáticas y dos dinámicas. Cuatro regiones en total. Regiones de texto, de datos estáticos, de heap y de stack . Todo lo anterior.</p>
<p>La región de pila almacena las variables locales. las variables estáticas. las estructuras de datos dinámicas. el código del programa.</p>
<h2 id="sec:tc-introduccion-ej">Ejercicios</h2>
<ol>
<li><p>¿Qué nombres son adecuados para los archivos fuente C?</p></li>
<li><p>Describa las etapas del ciclo de compilación.</p></li>
<li><p>¿Cuál sería el resultado de:</p>
<ul>
<li><p>Editar un archivo fuente?</p></li>
<li><p>Ejecutar un archivo fuente?</p></li>
<li><p>Editar un archivo objeto?</p></li>
<li><p>Compilar un archivo objeto?</p></li>
<li><p>Editar una biblioteca?</p></li>
</ul></li>
<li><p>¿Qué pasaría si un programa en C <strong>no</strong> contuviera una función ? Haga la prueba modificando <strong>hola.c</strong>.</p></li>
<li><p>Edite el programa <strong>hola.c</strong> y modifíquelo según las pautas que siguen. Interprete los errores de compilación. Identifique en qué etapa del ciclo de compilación ocurren los errores. Si resulta un programa ejecutable, observe qué hace el programa y por qué.</p>
<ul>
<li><p>Quite los paréntesis de .</p></li>
<li><p>Quite la llave izquierda de .</p></li>
<li><p>Quite las comillas izquierdas.</p></li>
<li><p>Quite los caracteres .</p></li>
<li><p>Agregue al final de la cadena los caracteres .</p></li>
<li><p>Agregue al final de la cadena los caracteres .</p></li>
<li><p>Quite las comillas derechas.</p></li>
<li><p>Quite el signo punto y coma.</p></li>
<li><p>Quite la llave derecha de .</p></li>
<li><p>Agregue un punto y coma en cualquier lugar del texto.</p></li>
<li><p>Agregue una coma o un dígito en cualquier lugar del texto.</p></li>
<li><p>Reemplace la palabra por , manteniendo los paréntesis.</p></li>
<li><p>Elimine la apertura o cierre de los comentarios.</p></li>
</ul></li>
</ol>
<h1 id="chap:tc-preprocesador">El preprocesador</h1>
<p>El compilador C tiene un componente auxiliar llamado <strong>preprocesador</strong>, que actúa en la primera etapa del proceso de compilación. Su misión es buscar, en el texto del programa fuente entregado al compilador, ciertas <strong>directivas</strong> que le indican realizar alguna tarea a nivel de texto. Por ejemplo, <strong>inclusión</strong> de otros archivos, o <strong>sustitución</strong> de ciertas cadenas de caracteres (<strong>símbolos</strong> o <strong>macros</strong>) por otras.</p>
<p>El preprocesador cumple estas directivas en forma similar a como podrían ser hechas interactivamente por el usuario, utilizando los comandos de un editor de texto ( o ), pero en forma automática. Una vez cumplidas todas estas directivas, el preprocesador entrega el texto resultante al resto de las etapas de compilación, que terminarán dando por resultado un módulo objeto. Un archivo fuente, junto con todos los archivos que incluya, es llamado una <strong>unidad de traducción</strong>.</p>
<p>El preprocesador sirve para eliminar redundancia y aumentar la expresividad de los programas en C, facilitando su mantenimiento. Si una variable o función se utiliza en varios archivos fuente, es posible aislar su declaración, colocándola en un único archivo aparte que será incluido al tiempo de compilación en los demás fuentes. Esto facilita toda modificación de elementos comunes en los fuentes de un proyecto. Por otro lado, si una misma constante o expresión aparece repetidas veces en un texto, y es posible que su valor deba cambiarse más adelante, es muy conveniente definir esa constante con un símbolo y especificar su valor sólo una vez, mediante un símbolo o macro.</p>
<h2 id="directivas-de-preprocesador">Directivas de preprocesador</h2>
<p>Las directivas del preprocesador no pertenecen al lenguaje C en un sentido estricto. El preprocesador <strong>no comprende ningún aspecto sintáctico ni semántico</strong> de C. Las <strong>macros</strong> definidas en un programa C <strong>no son variables ni funciones</strong>, sino simplemente cadenas de texto que el preprocesador deberá sustituir por otras. Las directivas pueden aparecer en cualquier lugar del programa, pero sus efectos se ponen en vigor recién a partir del punto del programa en que aparecen, y hasta el final de la unidad de traducción. Es decir, un símbolo o macro puede utilizarse sólo después de la aparición de la directiva que la define, y no antes. Tampoco puede utilizarse en una unidad de traducción diferente, salvo que vuelva a ser definida en ella (los símbolos de preprocesador no se entre unidades de traducción).</p>
<h3 id="símbolos-y-macros">Símbolos y macros</h3>
<p>Una de las funciones del preprocesador es sustituir símbolos, o cadenas de texto dadas, por otras Habitualmente se llama <strong>símbolos</strong> a aquellas cadenas que son directamente sustituibles por una expresión, reservándose el nombre de <strong>macros</strong> para aquellos símbolos cuya expansión es parametrizable (es decir, llevan argumentos formales y reales como en el caso de las funciones). La cadena de expansión puede ser cualquiera, no necesariamente un elemento sintácticamente válido de C.</p>
<p>La Fig. [fig:direct] muestra el programa ejemplo <strong>hola.c</strong> escrito usando directivas de inclusión de archivos, símbolos y macros, y las sucesivas transformaciones que hará el preprocesador.</p>
<p>El texto del programa una vez preprocesado quedará idéntico al del programa <strong>hola.c</strong> anteriormente presentado, y listo para ingresar a la etapa de compilación propiamente dicha.</p>
<h3 id="headers">Headers</h3>
<p>Las directivas para incluir archivos suelen darse al principio de los programas, ya que en general se desea que su efecto alcance a todo el archivo fuente. Por esta razón los archivos preparados para ser incluidos se denominan <em>headers</em> o archivos de cabecera. La implementación de la Biblioteca Standard que viene con un compilador posee sus propios headers, uno por cada módulo de la biblioteca, que <strong>declaran</strong> funciones y variables de uso general. Estos headers contienen texto legible por humanos, y están en algún subdirectorio predeterminado (llamado /usr/include en UNIX, y dependiendo del compilador en otros sistemas operativos). El usuario puede escribir sus propios headers, y no necesita ubicarlos en el directorio reservado del compilador; puede almacenarlos en el directorio activo durante la compilación.</p>
<p>En el párrafo anterior, nótese que decimos <strong>declarar</strong> funciones, y no <strong>definirlas</strong>; la diferencia es importante y se verá en profundidad más adelante. Recordemos por el momento que <strong>en los headers</strong> de la Biblioteca Standard no aparecen <strong>definiciones</strong> -es decir, textos- de funciones, sino solamente <strong>declaraciones o prototipos</strong>, que sirven para anunciar al compilador detalles como los tipos y cantidad de los argumentos de las funciones.</p>
<p>No se considera buena práctica de programación colocar la definición de una función de uso frecuente en un header. Esto obligaría a recompilar siempre la función cada vez que se la utilizara. Por el contrario, lo ideal sería compilarla una única vez, produciendo un módulo objeto (y posiblemente incorporándolo a una biblioteca). Esto ahorraría el tiempo correspondiente a su compilación, ocupando sólo el necesario para la vinculación.</p>
<h2 id="definición-de-símbolos">Definición de símbolos</h2>
<p>Si el programa dice:</p>
<pre><code>a = 2 * 3.14159 * 20.299322;</code></pre>
<p>Es mucho más claro poner, en su lugar:</p>
<pre><code>#define PI	3.14159
#define RADIO	20.299322

a = 2 * PI * RADIO;</code></pre>
<h2 id="definición-de-macros">Definición de macros</h2>
<p>Con las siguientes directivas:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;aux.h&quot;
#define MAXITEM 100
#define DOBLE(X) 2*X</code></pre>
<ul>
<li><p>Se incluye el header de Biblioteca Standard <code>stdio.h</code>, que contiene declaraciones necesarias para poder utilizar funciones de entrada/salida standard (hacia consola y hacia archivos).</p></li>
<li><p>Se incluye un header <code>aux.h</code> escrito por el usuario. Al indicar el nombre del header entre ángulos, como en la línea anterior, especificamos que la búsqueda debe hacerse en los directorios reservados del compilador. Al indicarlo entre comillas, nos referimos al directorio actual.</p></li>
<li><p>Se define un símbolo MAXITEM equivalente a la constante numérica 100.</p></li>
<li><p>Se define una macro DOBLE(X) que deberá sustituirse por la cadena 2*(argumento de la llamada a la macro).</p></li>
</ul>
<p>De esta manera, podemos escribir sentencias tales como:</p>
<pre><code>a=MAXITEM;
b=DOBLE(45);</code></pre>
<p>El texto luego de la etapa de preprocesamiento y antes de la compilación propiamente dicha será</p>
<pre><code>a=100;
b=2*45;</code></pre>
<h3 id="macros-vs.-funciones">Macros vs. funciones</h3>
<p>Es importante comprender que, aunque sintácticamente parecido, el uso de una macro <strong>no es una llamada a función</strong>; los argumentos de una macro no se evalúan en tiempo de ejecución antes de la llamada, sino que <strong>se sustituyen textualmente</strong> en el cuerpo de la macro. Así, si ponemos</p>
<pre><code>#define DOBLE(X) 2*X
b=DOBLE(40+5);</code></pre>
<p>el resultado será <code>b=2*40+5</code>; y no <code>b=2*45</code>, ni <code>b=2*(40+5)</code>, que presumiblemente es lo que desea el programador.</p>
<p>Este problema puede solucionarse redefiniendo la macro así:</p>
<pre><code>#define DOBLE(X) 2*(X)
b=DOBLE(40+5);</code></pre>
<p>Ahora la expansión de la macro será la deseada. En general, es saludable rodear las apariciones de los argumentos de las macros entre paréntesis, para obligar a su evaluación al tiempo de ejecución con la precedencia debida, y evitar efectos laterales.</p>
<h2 id="compilación-condicional">Compilación condicional</h2>
<p>Una característica interesante del preprocesador es que permite la <strong>compilación condicional</strong> de segmentos de la unidad de traducción, en base a valores de símbolos. Una directiva condicional es aquella que comprueba si un símbolo dado ha sido definido, o si su definición coincide con cierta cadena. El texto del programa que figura entre la directiva y su <code>end</code> será considerado sólo si la comprobación resulta exitosa. Los símbolos o macros pueden ser definidos al tiempo de la compilación, sin alterar el texto del programa, permitiendo así una parametrización del programa en forma separada de su escritura.</p>
<p>Con las directivas condicionales:</p>
<ul>
<li><p>Definimos una macro <code>CARTEL</code> que equivaldrá a invocar a una función , pero sólo si el símbolo <code>DEBUG</code> ha sido definido. En otro caso, equivaldrá a la cadena vacía.</p>
<pre><code>#ifdef DEBUG
#define CARTEL(x)	imprimir(x)
#else
#define CARTEL(x)
#endif</code></pre></li>
<li><p>El segmento siguiente muestra un caso con lógica inversa pero equivalente al ejemplo anterior.</p>
<pre><code>#ifndef DEBUG
#define CARTEL(x)
#else
#define CARTEL(x) imprimir(x)
#endif</code></pre></li>
<li><p>En el caso siguiente, se incluirá uno u otro header dependiendo del valor del símbolo <code>SISTEMA</code>. Tanto <code>DEBUG</code> como <code>SISTEMA</code> pueden tomar valores al momento de compilación, si se dan como argumentos para el compilador. De esta manera se puede modificar el comportamiento del programa sin necesidad de editarlo.</p>
<pre><code>#if SISTEMA==MS_DOS
#include &quot;header1.h&quot;
#elif SISTEMA==UNIX
#include &quot;header2.h&quot;
#endif</code></pre></li>
</ul>
<h2 id="observaciones">Observaciones</h2>
<ul>
<li><p>A veces puede resultar interesante, para depurar un programa, observar cómo queda el archivo intermedio generado por el preprocesador después de todas las sustituciones, inclusiones, etc. La mayoría de los compiladores cuentan con una opción que permite generar este archivo intermedio y detener allí la compilación, para poder estudiarlo.</p></li>
<li><p>Otra opción relacionada con el preprocesador que suelen ofrecer los compiladores es aquella que permite definir, al tiempo de la compilación y sin modificar los fuentes, símbolos que se pondrán a la vista del preprocesador. Así, la estructura final de un programa puede depender de decisiones tomadas al tiempo de compilación. Esto permite, por ejemplo, aumentar la portabilidad de los programas, o generar múltiples versiones de un sistema sin diseminar el conocimiento reunido en los módulos fuente que lo componen.</p></li>
<li><p>Finalmente, aunque el compilador tiene un directorio default donde buscar los archivos de inclusión, es posible agregar otros directorios para cada compilación con argumentos especiales si es necesario.</p></li>
</ul>
<p>[sec:tc-preprocesador-preg] El preprocesador interviene Después de la compilación del código. Antes de la compilación del código.</p>
<p>El preprocesador promueve La legibilidad. La redundancia. La rapidez de ejecución. Todas las anteriores.</p>
<p>El preprocesador facilita El mantenimiento. La legibilidad. La expresividad. Todas las anteriores.</p>
<p>Las directivas de preprocesador Están contenidas en el lenguaje C. Son variables de texto. No pertenecen al lenguaje C. Son palabras reservadas. Son funciones de C.</p>
<p>El efecto de las directivas de preprocesador abarca La función donde están declaradas. La unidad de traducción. El proyecto de programación. El bloque donde están declaradas.</p>
<p>Los headers Son escritos por el usuario. Vienen con el compilador. Todas las anteriores. Ninguna de las anteriores.</p>
<p>Los headers que <strong>definen</strong> funciones son recomendables. son imprescindibles. no son recomendables. son recomendables pero no imprescindibles.</p>
<p>¿Cuál es la directiva de preprocesador correcta si queremos definir un símbolo ALFA con valor 1?</p>
<p>¿Cuál es la directiva de preprocesador correcta si queremos incluir el header de Biblioteca Standard ? Cualquiera de las anteriores.</p>
<p>La directiva correcta para crear una macro que devuelva el doble de su argumento es</p>
<p>¿Cuál es la directiva correcta para incluir un header llamado situado en el directorio donde se está realizando la compilación?</p>
<p>Normalmente los headers contienen Declaraciones de variables y funciones. Definiciones de variables y funciones. Prototipos de directivas. Inclusión de archivos fuente. Todas las anteriores.</p>
<p>Las directivas condicionales consideran un segmento de texto sólo si la compilación resulta exitosa. sólo si la condición resulta exitosa.</p>
<p>El resultado de preprocesar la macro aplicada al argumento será</p>
<p>El problema de la expansión errónea de las macros se soluciona Rodeando los argumentos entre signos . Rodeando los argumentos con corchetes. Poniendo la macro completa entre comillas. Rodeando los argumentos con paréntesis.</p>
<h2 id="sec:tc-preprocesador-ej">Ejercicios</h2>
<ol>
<li><p>Dé ejemplos de directivas de preprocesador:</p>
<ol>
<li><p>Para incluir un archivo proporcionado por el compilador.</p></li>
<li><p>Para incluir un archivo confeccionado por el usuario.</p></li>
<li><p>Para definir una constante numérica.</p></li>
<li><p>Para compilar un segmento de programa bajo la condición de estar definida una constante.</p></li>
<li><p>Idem bajo la condición de ser no definida.</p></li>
<li><p>Idem bajo la condición de que un símbolo valga una cierta constante.</p></li>
<li><p>Idem bajo la condición de que dos símbolos sean equivalentes.</p></li>
</ol></li>
<li><p>Proponga un método para incluir un conjunto de archivos en un módulo fuente con una sola directiva de preprocesador.</p></li>
<li><p>¿Cuál es el ámbito de una definición de preprocesador? Si defino un símbolo A en un fuente y lo compilo creando un módulo objeto algo.o, ¿puedo utilizar A desde otro fuente, sin declararlo, a condición de linkeditarlo con algo.o?</p></li>
<li><p>¿Qué pasa si defino dos veces el mismo símbolo en un mismo fuente?</p></li>
<li><p>Un cierto header A es incluido por otros headers B, C y D. El fuente E necesita incluir a B, C y D. Proponga un método para poder hacerlo sin obligar al preprocesador a leer el header A más de una vez.</p></li>
<li><p>Edite el programa hello.c del ejemplo del capítulo 1 reemplazando la cadena <code>Hola, mundo! n</code> por un símbolo definido a nivel de preprocesador.</p></li>
<li><p>Edite el programa hello.c incluyendo la compilación condicional de la instrucción de impresión printf() sujeta a que esté definido un símbolo de preprocesador llamado IMPRIMIR. Compile y pruebe a) sin definir el símbolo IMPRIMIR, b) definiéndolo con una directiva de preprocesador, c) definiéndolo con una opción del compilador. ¿En qué casos es necesario recompilar el programa?</p></li>
<li><p>Escriba una macro que imprima su argumento usando la función printf(). Aplíquela para reescribir hello.c de modo que funcione igual que antes.</p></li>
<li><p>¿Cuál es el resultado de preprocesar las líneas que siguen? Es decir, ¿qué recibe exactamente el compilador luego del preprocesado?</p>
<pre><code>#define ALFA 8
#define BETA 2*ALFA
#define PROMEDIO(x,y) (x+y)/2
a=ALFA*BETA;
b=5;
c=PROMEDIO(a,b);</code></pre></li>
<li><p>¿Qué está mal en los ejemplos que siguen?</p>
<ol>
<li><pre><code>#define PRECIO 27.5
PRECIO=27.7;</code></pre></li>
<li><pre><code>#define 3.14 PI</code></pre></li>
<li><pre><code>#define doble(x) 2*x;
alfa=doble(6)+5;</code></pre></li>
</ol></li>
<li><p>Investigue la función de los símbolos predefinidos <code>__STDC__</code>, <code>__FILE__</code> y <code>__LINE__</code>.</p></li>
</ol>
<h1 id="chap:tc-tipos">Tipos de datos y expresiones</h1>
<p>En general, las <strong>expresiones</strong> en C se construyen conectando, mediante <strong>operadores</strong>, diversos elementos, tales como <strong>identificadores</strong> de variables, <strong>constantes</strong> e invocaciones de <strong>funciones</strong>. Cada uno de estos elementos tiene un valor al tiempo de ejecución, y debe ocupar -al menos temporariamente, mientras se calcula el resultado de la expresión- un lugar en memoria. Al evaluar cada expresión, el compilador crea, para alojar cada subexpresión de las que la constituyen, <strong>objetos de datos</strong>, que pueden pensarse como espacio de memoria reservado temporariamente para contener valores. Al completar el cálculo de la expresión, el resultado nuevamente debe ser alojado en un objeto de datos propio. Estos espacios de memoria son de diferentes (cantidades de bits) de acuerdo al <strong>tipo de dato</strong> de la subexpresión.</p>
<p>Así, las expresiones y subexpresiones en C asumen siempre un <strong>tipo de datos</strong>: alguno de los tipos básicos del lenguaje, o uno definido por el usuario. Una expresión, según las necesidades, puede convertirse de un tipo a otro. El compilador hace esto a veces en forma <strong>automática</strong>. Otras veces, el programador fuerza una <strong>conversión de tipo</strong> para producir un determinado resultado.</p>
<h2 id="declaración-de-variables">Declaración de variables</h2>
<p>Los <strong>tipos básicos</strong> son:</p>
<ul>
<li><p><code>char</code> (un elemento del tamaño de un byte)</p></li>
<li><p><code>int</code> (un número entero con signo)</p></li>
<li><p><code>long</code> (un entero largo)</p></li>
<li><p><code>float</code> (un número en punto flotante)</p></li>
<li><p><code>double</code> (un número en punto flotante, doble precisión)</p></li>
</ul>
<p>Cuando declaramos una variable o forzamos una conversión de tipo, utilizamos una <strong>especificación de tipo</strong>. Ejemplos de declaración de variables:</p>
<pre><code>char a;
int alfa,beta;
float x1,x2;</code></pre>
<p>Los <strong>tipos enteros</strong> (<code>char</code>, <code>int</code> y <code>long</code>) admiten los modificadores <code>signed</code> (con signo) y <code>unsigned</code> (sin signo). Un objeto de datos <strong>unsigned</strong> utiliza todos sus bits para representar magnitud; un <strong>signed</strong> utiliza un bit para signo, en representación complemento a dos.</p>
<p>El modificador <code>signed</code> sirve sobre todo para explicitar el signo de los chars. El default para un <code>int</code> es signed; el default para <code>char</code> puede ser signed o unsigned, dependiendo del compilador.</p>
<pre><code>unsigned int edad;
signed char beta;</code></pre>
<p>Un int puede afectarse con el modificador <code>short</code> (corto).</p>
<pre><code>short i;
unsigned short k;</code></pre>
<p>Cuando en una declaración aparece sólo el modificador unsigned o short, y no el tipo, <strong>se asume int</strong>. El tipo entero se supone el tipo básico manejable por el procesador, y es el tipo por omisión en varias otras situaciones. Por ejemplo, cuando no se especifica el <strong>tipo del valor devuelto</strong> por una función.</p>
<p>El modificador long puede aplicarse también a float y a double. Los tipos resultantes pueden tener más precisión que los no modificados.</p>
<pre><code>long float e; 
long double pi;</code></pre>
<h2 id="tamaños-de-los-objetos-de-datos">Tamaños de los objetos de datos</h2>
<p>El lenguaje C no define el tamaño de los objetos de datos de un tipo determinado. Es decir, un entero puede ocupar 16 bits en una implementación del compilador, 32 en otra, o aun 64. Un <code>long</code> puede tener, o no, más bits que un <code>int</code>. Un <code>short</code> puede ser, o no, más corto que un <code>int</code>. Según <strong>K&amp;R</strong>, lo único seguro es que “<em>un <code>short</code> no es mayor que un <code>int</code>, que a su vez no es mayor que <code>long</code></em>”.</p>
<p>Por supuesto, distintos tamaños en bits implican diferentes rangos de valores. Si deseamos <strong>portar</strong> un programa, hecho bajo una implementación del compilador, a otra, no es posible asegurar a priori el rango que tomará un tipo de datos. La fuente ideal para conocer los rangos de los diferentes tipos, en una implementación determinada, es –además del manual del compilador– el header <code>limits.h</code> de la Biblioteca Standard. Debe recordarse que cualquier suposición que hagamos sobre el rango o tamaño de un objeto de datos afecta la portabilidad de un programa en C.</p>
<p>Las siguientes líneas son parte de un archivo <code>limits.h</code> para una implementación en particular:</p>
<pre><code>/* Minimum and maximum values a &#39;signed short int&#39; can hold. */
#define SHRT_MIN	(-32768)
#define SHRT_MAX	32767
/* Maximum value an &#39;unsigned short int&#39; can hold. (Minimum is 0.) */
#define USHRT_MAX	65535
/* Minimum and maximum values a &#39;signed int&#39; can hold. */
#define INT_MIN	(-INT_MAX - 1)
#define INT_MAX	2147483647
/* Maximum value an &#39;unsigned int&#39; can hold. (Minimum is 0.) */
#ifdef __STDC__
#define UINT_MAX 	4294967295U
#else
#define UINT_MAX  	4294967295
#endif
/* Minimum and maximum values a &#39;signed long int&#39; can hold. */
#ifdef __alpha__
#define LONG_MAX 	9223372036854775807L
#else
#define LONG_MAX	2147483647L
#endif
#define LONG_MIN 	(-LONG_MAX - 1L)
/* Maximum value an &#39;unsigned long int&#39; can hold. (Minimum is 0.) */
# ifdef __alpha__
#define ULONG_MAX	18446744073709551615UL
#else
#ifdef __STDC__
#define ULONG_MAX 	4294967295UL
#else
#define ULONG_MAX 4294967295L
#endif
#endif</code></pre>
<p>Cuando una operación sobre una variable provoca overflow, no se obtiene ninguna indicación de error. El valor sufre <strong>truncamiento</strong> a la cantidad de bits que pueda alojar la variable.</p>
<p>Así, en una implementación donde los ints son de 16 bits, si tenemos en una variable entera el máximo valor positivo:</p>
<pre><code>int a; 
a=32767; /* a=0111111111111111 binario */
a=a+1;</code></pre>
<p>Al calcular el nuevo valor de <code>a</code>, aparece un 1 en el bit más significativo, lo cual, según la representación de los enteros, lo transforma en un negativo (el menor negativo que soporta el tipo de datos, -32768).</p>
<p>Si el int es sin signo:</p>
<pre><code>unsigned a;
a=65535; /* máximo valor de unsigned int */
a=a+1; </code></pre>
<p>el incremento de <code>a</code> provoca overflow, y el nuevo valor de <code>a</code> se trunca a 16 bits, volviendo así a 0.</p>
<p>Siempre se puede saber el tamaño en bits de un tipo de datos aplicando el operador <code>sizeof()</code> a una variable o a la especificación de tipo.</p>
<h2 id="operaciones-con-distintos-tipos">Operaciones con distintos tipos</h2>
<p>En una expresión en C pueden aparecer componentes de diferentes tipos. Durante la evaluación de una expresión cuyas subexpresiones sean de <strong>tipos diferentes</strong>, deberá tener lugar una <strong>conversión</strong>, ya sea implícita o explícita, para llevar ambos operandos a un <strong>tipo de datos común</strong> con el que se pueda operar. La forma en que el compilador resuelve las conversiones implícitas a veces provoca algunas sorpresas.</p>
<h3 id="truncamiento-en-asignaciones">Truncamiento en asignaciones</h3>
<p>Para empezar, una asignación de una expresión de un tipo dado a una variable de un tipo (en el sentido del tamaño en bits de cada objeto de datos), no sólo es permitida en C, sino que la conversión se hace en forma automática y generalmente sin ningún mensaje de tiempo de compilación ni de ejecución. Por ejemplo,</p>
<pre><code>int a;
float b;
...
a=b;</code></pre>
<p>En esta asignación tenemos miembros de diferentes tamaños. El resultado en <code>a</code> será el truncamiento del valor entero de <code>b</code> a la cantidad de bits que permita un int. Es decir, se tomará la parte entera de <code>b</code>, y de ese valor se copiarán en el objeto de datos de <code>a</code> tantos bits como quepan en un int, tomándose los menos significativos.</p>
<p>Si el valor de <code>b</code> es, por ejemplo, 20.5, <code>a</code> valdrá finalmente 20, lo que es similar a aplicar una función implícitamente, y no demasiado incongruente. Pero si la parte entera de <code>b</code> excede el rango de un entero (por ejemplo si <code>b=99232.5</code> en una plataforma donde los enteros son de 16 bits), el resultado en <code>a</code> no tendrá lógica aparente. En el primer caso, los bits menos significativos de <code>b</code> que en <code>a</code> conservan el valor de <code>b</code>; en el segundo caso, no.</p>
<p>En la sentencia:</p>
<pre><code>a=19.27 * b;	</code></pre>
<p><code>a</code> contendrá los <code>sizeof(int)</code> bits menos significativos del resultado de evaluar la expresión de la derecha, truncada sin decimales.</p>
<h3 id="promoción-automática-de-expresiones">Promoción automática de expresiones</h3>
<p>Por otra parte, se tienen las reglas de promoción automática de expresiones. Enunciadas en forma aproximada (luego las daremos con más precisión), estas reglas dicen que el compilador hará estrictamente las conversiones necesarias para llevar todos los operandos <strong>al tipo del</strong> entre ellos. El resultado de evaluar una operación aritmética <strong>será del tipo del</strong> de sus operandos.</p>
<p>A veces, esto no es lo que se desea.</p>
<p>Dada la sentencia:</p>
<pre><code>a=3/2;</code></pre>
<p>se tiene que tanto la constante 3 como la constante 2 son vistas por el compilador como ints; el resultado de la división será también un entero (la parte entera de 3/2, o sea 1).</p>
<p>Aun más llamativo es el hecho de que si declaramos previamente:</p>
<pre><code>float a;</code></pre>
<p>el resultado es casi el mismo: <code>a</code> contendrá finalmente el valor float 1.0, porque el problema de truncamiento se produce ya en la evaluación del miembro derecho de la asignación.</p>
<h3 id="operador-cast">Operador cast</h3>
<p>En el ejemplo anterior, ¿cómo recuperar el valor correcto, con parte decimal, de la división? Declarar a la variable <code>a</code> como <strong>float</strong> es necesario, pero no suficiente. Para que la expresión del miembro derecho sea <strong>float</strong> es necesario que <strong>al menos uno</strong> de sus operandos sea <strong>float</strong>. Hay dos formas de lograr esto; la primera es escribir cualquiera de las subexpresiones como constante en punto flotante (con punto decimal, o en notación exponencial):</p>
<pre><code>a=3./2;</code></pre>
<p>La segunda consiste en forzar explícitamente una conversión de tipo, con un importante operador llamado <strong>cast</strong>, de la siguiente manera.</p>
<pre><code>a=(float)3/2;</code></pre>
<p>El operador <strong>cast</strong> es la aclaración, entre paréntesis, del tipo al cual queremos convertir la expresión (en este caso, la subexpresión <strong>3</strong>). Da lo mismo aplicarlo a cualquiera de las constantes. Sin embargo, lo siguiente <strong>no funcionará</strong>:</p>
<pre><code>a=(float)(3/2);</code></pre>
<p>Aquí el operador <strong>cast</strong> se aplica a la expresión <strong>ya evaluada como entero</strong>, con lo que volvemos a tener un valor <strong>1.0</strong>, float, en <code>a</code>.</p>
<h3 id="reglas-de-promoción-en-expresiones">Reglas de promoción en expresiones</h3>
<p>Son aplicadas por el compilador en el orden que se da más abajo (tomado de K&amp;R, 2a. ed.). Ésta es una lista muy detallada de las comprobaciones y conversiones que tienen lugar. Para la mayoría de los propósitos prácticos, basta tener en cuenta la regla de <strong>llevar ambos operandos al tipo del</strong> de ellos.</p>
<p>Entendemos por el acto de llevar los objetos de tipo <code>char</code>, <code>enum</code> y <strong>campos de bits</strong> a <strong>int</strong>; o, si los bits de un int no alcanzan a representarlo, a <strong>unsigned int</strong>.</p>
<h2 id="observaciones-1">Observaciones</h2>
<p>Nótese que <strong>no existen</strong> en C tipos <code>boolean</code> ni <code>string</code>. Más adelante veremos cómo manejar datos de estas clases.</p>
<p>El tipo <strong>char</strong>, pese a su nombre, no está restringido a la representación de caracteres. Por el contrario, un char <strong>tiene entidad aritmética</strong>. Almacena una cantidad <strong>numérica</strong> y puede intervenir en operaciones matemáticas. En determinadas circunstancias, y sin perder estas propiedades, puede ser interpretado como un carácter (el <strong>carácter cuyo código ASCII contiene</strong>).</p>
<p>En general, en C es conveniente habituarse a pensar en los datos separando la <strong>representación</strong> (la forma como se almacena un objeto) de la <strong>presentación</strong> (la forma como se visualiza). Un mismo patrón de bits almacenado en un objeto de datos puede ser visto como un número decimal, un carácter, un número hexadecimal, octal, etc. La verdadera naturaleza del dato es la representación de máquina, el patrón de bits almacenado en el objeto de datos.</p>
<h2 id="sec:lafuncionprintf">Una herramienta: printf()</h2>
<p>Con el objeto de facilitar la práctica, describimos aquí la función de Biblioteca Standard <code>printf()</code>.</p>
<ul>
<li><p>La función de salida <code>printf()</code> lleva un <strong>número variable de argumentos</strong>.</p></li>
<li><p>Su primer argumento siempre es una cadena o constante string, la <strong>cadena de formato</strong>, conteniendo texto que será impreso, más, opcionalmente, <strong>especificaciones de conversión</strong>.</p></li>
<li><p>Las especificaciones de conversión comienzan con un signo %. Todo otro conjunto de caracteres en la cadena de formato será impreso textualmente.</p></li>
<li><p>Cada especificación de conversión determina la manera en que se imprimirán los restantes argumentos de la función.</p></li>
<li><p>Deben existir tantas especificaciones de conversión como argumentos luego de la cadena de formato.</p></li>
<li><p>Un mismo argumento de un tipo dado puede ser impreso o presentado de diferentes maneras según la especificación de conversión que le corresponda en la cadena de formato (de aquí la importancia de separar representación de presentación)</p></li>
<li><p>Las especificaciones de conversión pueden estar afectadas por varios <strong>modificadores</strong> opcionales que determinan, por ejemplo, el ancho del campo sobre el cual se escribirá el argumento, la cantidad de decimales de un número, etc.</p></li>
<li><p>Las principales especificaciones de conversión están dadas en el Cuadro [tab:conv].</p></li>
</ul>
<p>Este programa escribe algunos valores con dos especificaciones de formato distintas.</p>
<pre><code>main() {
	int i,j;
	for(i=65, j=1; i&lt;70; i++, j++)
		printf(&quot;vuelta no. %d: i=%d, i=%c\n&quot;,j,i,i);
}</code></pre>
<p>Salida del programa:</p>
<pre><code>vuelta no. 1: i=65, i=A
vuelta no. 2: i=66, i=B
vuelta no. 3: i=67, i=C
vuelta no. 4: i=68, i=D
vuelta no. 5: i=69, i=E</code></pre>
<p>El programa siguiente escribe el mismo valor en doble precisión pero con diferentes modificadores del campo correspondiente, para incluir una cierta cantidad de decimales o alinear la impresión.</p>
<pre><code>main() {
	double d;
	d=3.141519/2.71728182;
	printf(&quot;d=%lf\n&quot;,d);
	printf(&quot;d=%20lf\n&quot;,d);
	printf(&quot;d=%20.10lf\n&quot;,d);
	printf(&quot;d=%20.5lf\n&quot;,d);
	printf(&quot;d=%.10lf\n&quot;,d);
}	</code></pre>
<p>Salida del programa:</p>
<pre><code>d=1.156126
d=            1.156126
d=        1.1561255726
d=             1.15613
d=1.1561255726</code></pre>
<p>[sec:tc-tipos-preg] Un objeto de datos es Un tipo de datos. Un tipo de datos abstracto. Una variable. Un espacio de almacenamiento para contener valores.</p>
<p>Un objeto de datos es ocupado Al terminar la ejecución del programa. Al calcular cada subexpresión. Al inicio de cada función.</p>
<p>El tipo de las expresiones Es asignado por el compilador. Es asignado por el usuario. Las dos anteriores. Es asignado por el linkeditor. No puede ser modificado por el usuario.</p>
<p>¿Cuál de las declaraciones siguientes <strong>no</strong> es correcta?</p>
<p>¿Cuál de las declaraciones siguientes es incorrecta?</p>
<p>¿Cuál de las declaraciones siguientes es correcta?</p>
<p>Una declaración indica que la variable contendrá un número negativo o cero. un número positivo o negativo. un número no negativo. un número negativo, positivo o cero.</p>
<p>El signo default de las variables de tipo y de tipo es, respectivamente, y . y dependiente de la implementación. y . dependiente de la implementación y . dependiente de la implementación en ambos casos.</p>
<p>En la declaración siguiente, ¿cuál es el tipo básico interpretado por el compilador?<br />
char int long</p>
<p>¿Cuál es la regla verdadera para los tamaños de los objetos de datos? Un es mayor que un . Un es menor que un . Un no es menor que un . Un no es mayor que un .</p>
<p>El valor máximo de un suele estar en el orden de las decenas. los cientos. los miles. las decenas de miles. los millones.</p>
<p>Cuando existe una condición de <em>overflow</em>: El programa aborta con mensaje de error. El programa es terminado por el subsistema de protección del sistema operativo. El valor se trunca. El valor se redondea. La variable vuelve a cero.</p>
<p>Si un vale 127 y se le suma 1: queda en 0. queda en -127. queda en 128. queda en -128. queda en -1.</p>
<p>Si un vale 0 y se le resta 1, queda en 0. queda en -1. queda en el valor del máximo entero sin signo. queda en 65535. queda en 32768.</p>
<p>Si a y b son enteros, para obtener el valor de su cociente con decimales se debe escribir</p>
<p>Si a es int y b es , ¿cuál es el tipo de la expresión ?</p>
<p>Si a y b son s que tienen el máximo valor posible para los chars, el tipo de la expresión es:</p>
<h2 id="sec:tc-tipos-ej">Ejercicios</h2>
<ol>
<li><p>¿Cuáles de entre estas declaraciones contienen errores?</p>
<p><span>2</span></p>
<ol>
<li><p>integer a;</p></li>
<li><p>short i,j,k;</p></li>
<li><p>long float (h);</p></li>
<li><p>double long d3;</p></li>
<li><p>unsigned float n;</p></li>
<li><p>char 2j;</p></li>
<li><p>int MY;</p></li>
<li><p>float ancho, alto, long;</p></li>
<li><p>bool i;</p></li>
</ol></li>
<li><p>Dé declaraciones de variables con tipos de datos adecuados para almacenar:</p>
<ol>
<li><p>La edad de una persona.</p></li>
<li><p>Un número de DNI.</p></li>
<li><p>La distancia, en Km, entre dos puntos cualesquiera del globo terrestre.</p></li>
<li><p>El precio de un artículo doméstico.</p></li>
<li><p>El valor de la constante PI expresada con 20 decimales.</p></li>
</ol></li>
<li><p>Prepare un programa con variables conteniendo los valores máximos de cada tipo entero, para comprobar el resultado de incrementarlas en una unidad. Imprima los valores de cada variable antes y después del incremento. Incluya <strong>unsigneds</strong>.</p></li>
<li><p>Lo mismo, pero dando a las variables los valores mínimos posibles, e imprimiéndolas antes y después de decrementarlas en una unidad.</p></li>
<li><p>Averigüe los tamaños de todos los tipos básicos en su sistema aplicando el operador <code>sizeof()</code>.</p></li>
<li><p>Si se asigna la expresión <span class="math inline">(3 − 5)</span> a un <code>unsigned short</code>, ¿cuál es el resultado? ¿Depende de qué formato de conversión utilicemos para imprimirlo?</p></li>
<li><p>¿Qué hace falta corregir para que la variable <code>r</code> contenga la división exacta de <code>a</code> y <code>b</code>?</p>
<pre><code>int a, b;
float r;
a = 5;
b = 2;
r = a / b;		
	</code></pre></li>
<li><p>¿Qué resultado puede esperarse del siguiente fragmento de código?</p>
<pre><code>int a, b, c, d;
a = 1;
b = 2;
c = a / b;
d = a / c;
	</code></pre></li>
<li><p>¿Cuál es el resultado del siguiente fragmento de código? Anticipe su respuesta en base a lo dicho en esta unidad y luego confírmela mediante un programa.</p>
<pre><code>printf(&quot;%d\n&quot;, 20/3);
printf(&quot;%f\n&quot;, 20/3);
printf(&quot;%f\n&quot;, 20/3.);
printf(&quot;%d\n&quot;, 10%3);
printf(&quot;%d\n&quot;, 3.1416);
printf(&quot;%f\n&quot;, (double)20/3);
printf(&quot;%f\n&quot;, (int)3.1416);
printf(&quot;%d\n&quot;, (int)3.1416);
	</code></pre></li>
<li><p>Escribir un programa que multiplique e imprima <span class="math inline">100000 * 100000</span>. ¿De qué tamaño son los ints en su sistema?</p></li>
<li><p>Convertir una moneda a otra sabiendo el valor de cambio. Dar el valor a dos decimales.</p></li>
<li><p>Escriba y corra un programa que permita saber si los chars en su sistema son signed o unsigned.</p></li>
<li><p>Escriba y corra un programa que asigne el valor 255 a un char, a un unsigned char y a un signed char, y muestre los valores almacenados. Repita la experiencia con el valor <span class="math inline">−1</span> y luego con <span class="math inline">$'\377'$</span>. Explicar el resultado.</p></li>
<li><p>Copiar y compilar el siguiente programa. Explicar el resultado.</p>
<pre><code>main() {
	double x;
	int i;
	i = 1400;
	x = i; /* conversion de int a double */
	printf(&quot;x = %10.6le\ti = %d\n&quot;,x,i);
	x = 14.999;
	i = x; /* conversion de double a int */
	printf(&quot;x = %10.6le\ti = %d\n&quot;,x,i);
	x = 1.0e+60;
	i = x;
	printf(&quot;x = %10.6le\ti = %d\n&quot;,x,i);
}
	</code></pre></li>
<li><p>Escriba un programa que analice la variable <code>v</code> conteniendo el valor 347 y produzca la salida:</p>
<pre><code>3 centenas
4 decenas
7 unidades</code></pre>
<p>(y, por supuesto, salidas acordes si <code>v</code> toma otros valores).</p></li>
<li><p>Sumando los dígitos de un entero escrito en notación decimal se puede averiguar si es divisible por 3 (se constata si la suma de los dígitos lo es). ¿Esto vale para números escritos en otras bases? ¿Cómo se puede averiguar esto?</p></li>
<li><p>Indicar el resultado final de los siguientes cálculos</p>
<ol>
<li><p><code>int a; float b = 12.2; a = b;</code></p></li>
<li><p><code>int a, b; a = 9; b = 2; a /= b;</code></p></li>
<li><p><code>long a, b; a = 9; b = 2; a /= b;</code></p></li>
<li><p><code>float a; int b, c; b = 9; c = 2; a = b/c;</code></p></li>
<li><p><code>float a; int b, c; b = 9; c = 2; a = (float)(b/c);</code></p></li>
<li><p><code>float a; int b, c; b = 9; c = 2; a = (float)b/c;</code></p></li>
<li><p><code>short a, b, c; b = -2; c = 3; a = b * c;</code></p></li>
<li><p><code>short a, b, c; b = -2; c = 3; a = (unsigned)b * c;</code></p></li>
</ol></li>
<li><p>Aplicar operador cast donde sea necesario para obtener resultados apropiados:</p>
<ol>
<li><pre><code>int a; long b; float c;
a = 1; b = 2; c = a / b;
	</code></pre></li>
<li><pre><code>long a; 
int b,c;
b = 1000; c = 1000;
a = b * c;
	</code></pre></li>
</ol></li>
<li><p>¿Cuál es la salida de este programa? ¿Cuál es la explicación?</p>
<pre><code>#include &lt;stdio.h&gt;
int main(){
	printf(&quot;%f\n&quot;, (float)333334126.98);
	printf(&quot;%f\n&quot;, (float)333334125.31);
}</code></pre></li>
</ol>
<h1 id="tc-constantes">Constantes</h1>
<h2 id="constantes-numéricas">Constantes numéricas</h2>
<p>Las constantes numéricas en un programa C pueden escribirse en varias bases. Además, la forma de escribirlas puede modificar el tamaño de los <strong>objetos de datos</strong> donde se almacenan.</p>
<h3 id="constantes-enteras">Constantes enteras</h3>
<ul>
<li><p><code>10, -1</code> son constantes <strong>decimales</strong>.</p></li>
<li><p><code>010, -012</code> son constantes <strong>octales</strong> por comenzar en .</p></li>
<li><p><code>0x10, -0x1B, 0Xbf01</code> son constantes <strong>hexadecimales</strong> por comenzar en o .</p></li>
<li><p><code>’A’</code> es una constante de carácter. En una computadora que sigue la convención del código ASCII, equivale al decimal , hexadecimal , etc.</p></li>
</ul>
<h3 id="constantes-long">Constantes long</h3>
<p>Una constante entera puede indicarse como <strong>long</strong> agregando una letra L mayúscula o minúscula: <code>0L, 43l</code>. Si bien numéricamente son equivalentes a 0 y a 43 int, el compilador, al encontrarlas, manejará constantes de tamaño long (construirá objetos de datos sobre la cantidad de bits correspondientes a un long). Esto puede ser importante en ciertas ocasiones: por ejemplo, al invocar a funciones con argumentos formales long, usando argumentos reales que caben en un entero.</p>
<h3 id="constantes-unsigned">Constantes unsigned</h3>
<p>Para hacer más claro el propósito de una constante positiva, o para forzar la promoción de una expresión, puede notársela como <strong>unsigned</strong>. Esto tiene que ver con las reglas de promoción expresadas en el capítulo 3. Constantes unsigned son, por ejemplo, y .</p>
<h3 id="constantes-de-punto-flotante">Constantes de punto flotante</h3>
<p>Las constantes en punto flotante se caracterizan por llevar un punto decimal o un carácter ’e’ (que indica que está en notación exponencial). Así son constantes en punto flotante. La constante se interpreta como el número multiplicado por <span class="math inline">10<sup>23</sup></span>. La constante es igual a .</p>
<h2 id="sec:constantesstring">Constantes string</h2>
<p>El texto comprendido entre comillas dobles en un programa C es interpretado por el compilador como una <strong>constante string</strong>, con propiedades similares a las de un arreglo de caracteres.</p>
<p>El proceso de compilación, al identificarse una constante string, es como sigue:</p>
<ul>
<li><p>El compilador reserva una zona de memoria en la imagen del programa que está construyendo, <strong>del tamaño del string más uno</strong>.</p></li>
<li><p>Se copian los caracteres entre comillas en esa zona, agregando al final <strong>un byte conteniendo un cero</strong> (<code>’’</code>).</p></li>
<li><p>Se reemplaza la <strong>referencia</strong> a la constante string en el texto del programa por la <strong>dirección donde quedó almacenada</strong>.</p></li>
</ul>
<p>La cadena registrada por el compilador será almacenada al momento de ejecución en la zona del programa correspondiente a <strong>datos estáticos inicializados</strong> (zona a veces llamada ). Así, una constante string <strong>equivale a, o se evalúa a</strong>, una dirección de memoria: la dirección donde está almacenado su primer carácter.</p>
<h3 id="el-cero-final">El cero final</h3>
<p>El carácter <code>’’</code> impuesto por el compilador al final de la secuencia de caracteres señaliza el fin de la cadena, y tiene la importante misión de funcionar como <strong>protocolo</strong> o <strong>señal de terminación</strong> para aquellas funciones de la Biblioteca Standard que manejan strings (copia de cadenas, búsqueda de caracteres, comparación de cadenas, etc.). Debido a esta representación interna, algunas veces se las ve mencionadas con el nombre de <strong>cadenas ASCIIZ</strong> (caracteres ASCII seguidos de cero).</p>
<p>Gracias a esta representación con el <strong>cero final</strong>, las cadenas ASCIIZ en C <strong>no tienen una longitud máxima</strong>. El final de la cadena simplemente ocurre donde aparezca un carácter cero.</p>
<p>¿Hay diferencias entre <code>’’</code>, <code>’0’</code> y <code>0</code>? Muchas.</p>
<ul>
<li><p>La primera constante, <code>’’</code>, es un entero. Su valor aritmético es 0. Todos los bits del objeto de datos donde está representada son 0.</p></li>
<li><p>La segunda, <code>’0’</code>, es una constante de carácter. Ocupa un objeto de datos de 8 bits de tamaño. Su valor es <strong>48 decimal</strong> en aquellas computadoras cuyo juego de caracteres esté basado en ASCII, pero puede ser diferente en otras.</p></li>
<li><p>La tercera, <code>0</code>, es una constante string, y se evalúa a una dirección. Es decir, en cualquier expresión donde figure, su valor aritmético es una dirección de memoria dentro del espacio de direcciones del programa. Ocupa un objeto de datos del tamaño de una dirección (frecuentemente 16 o 32 bits), además del espacio de memoria ubicado a partir de esa dirección y ocupado por los caracteres del string. Ese espacio de memoria está ocupado por un byte igual a <code>’0’</code> (el primer y único carácter del string), que como hemos visto equivale a 48 decimal en computadoras que adoptan ASCII, y a continuación viene un byte <code>’’</code>, o sea, 0 (señal de fin del string).</p></li>
</ul>
<p>Si tenemos las declaraciones y asignaciones siguientes, donde las tres variables declaradas son char:</p>
<pre><code>char a,b,c;
a=&#39;\0&#39;;
b=&#39;0&#39;;
c=&quot;0&quot;;</code></pre>
<ul>
<li><p>La primera asignación es perfectamente válida y equivale a <code>a=0</code>.</p></li>
<li><p>La segunda asignación también es correcta y equivale a <code>b=48</code> en computadores basados en ASCII.</p></li>
<li><p>La tercera asignación será rechazada por el compilador, generándose un error de . Los objetos a ambos lados del signo igual son de diferente naturaleza: a la izquierda tenemos algo que puede ser directamente <strong>usado como un dato</strong> (una constante o una variable); a la derecha, algo que, indirectamente, <strong>referencia a un dato</strong> (una dirección). Se dice que la variable y la constante string tienen <strong>diferente nivel de indirección</strong>.</p></li>
</ul>
<h2 id="constantes-de-carácter">Constantes de carácter</h2>
<p>El gráfico muestra el resultado de asignar algunas constantes relacionadas con el problema anterior, suponiendo una arquitectura donde los enteros y las direcciones de memoria son de 16 bits. Las tres primeras asignaciones dejan en <code>a</code> valores aritméticos 0, 48 y 0.</p>
<p>Las dos últimas asignaciones dejan en la dirección de una cadena almacenada en memoria. Las cadenas apuntadas son las que están representadas en el diagrama.</p>
<p>La primera cadena contendrá el código ASCII del carácter 0 y un cero binario señalizando el fin del string. La segunda contendrá un cero binario (expresado por la constante de carácter <code>’’</code>) y un cero binario fin de string.</p>
<p>Las constantes de carácter son una forma expresiva y portable de especificar constantes numéricas. Internamente, durante la compilación y ejecución del programa, el compilador las entiende como valores numéricos sobre ocho bits. Así, es perfectamente lícito escribir expresiones como <code>’A’ + 1</code> (que equivale a <code>66</code>, o a <code>0x42</code>, o a la constante de carácter <code>’B’</code>).</p>
<p>Algunos caracteres especiales tienen una grafía especial:</p>
<ul>
<li><p><code></code> carácter ’backspace’, ASCII 8</p></li>
<li><p><code></code> tabulador, ASCII 9</p></li>
<li><p><code></code> fin de línea, ASCII 10 (UNIX) o secuencia 13,10 (DOS)</p></li>
<li><p><code></code> retorno de carro, ASCII 13</p></li>
<li><p>Una forma alternativa de escribir constantes de carácter es mediante su código ASCII: <code>’33’, ’1B’</code> Aquí representamos el carácter cuyo código ASCII es 27 decimal, en dos bases. La barra invertida (<em>backslash</em>) muestra que el contenido de las comillas simples debe ser interpretado como el código del carácter. Si el carácter siguiente al backslash es x o X, el código está en hexadecimal; si no, está en octal. Para representar el carácter backslash, sin su significado como modificador de secuencias de otros caracteres, lo escribimos dos veces seguidas.</p></li>
</ul>
<p>Estas constantes de carácter pueden ser también escritas respectivamente como las constantes numéricas , o , ya que son aritméticamente equivalentes; pero con las comillas simples indicamos que el programador a estas constantes como caracteres, lo que puede agregar expresividad a un segmento de programa.</p>
<p>Por ejemplo, 0 es claramente una constante numérica; pero si escribimos <code>’’</code> (que es numéricamente equivalente), ponemos en evidencia que estamos pensando en el carácter cuyo código ASCII es 0. El carácter <code>’’</code> (ASCII 0) es distinto de <code>’0’</code> (ASCII 48). La expresión de las constantes de carácter mediante backslash y algún otro contenido se llama una <strong>secuencia de escape</strong>.</p>
<h3 id="constantes-de-carácter-en-strings">Constantes de carácter en strings</h3>
<p>Todas estas notaciones para las constantes de carácter pueden intervenir en la escritura de constantes string. El mecanismo de reconocimiento de constantes de caracteres dentro de strings asegura que todo el juego de caracteres de la máquina pueda ser expresado dentro de una constante string, aun cuando no sea imprimible o no pueda producirse con el teclado. Cuando el compilador se encuentre analizando una constante string asignará un significado especial al carácter <strong>barra invertida</strong> o backslash (). La aparición de un backslash permite referirse a los caracteres por su código en el sistema de la máquina (por lo común, el ASCII).</p>
<h2 id="constantes-enumeradas">Constantes enumeradas</h2>
<p>Como una alternativa más legible y expresiva a la definición de constantes de preprocesador, se pueden definir grupos de constantes reunidas por una declaración. Una declaración de <strong>constantes enumeradas</strong> hace que las constantes tomen valores consecutivos de una secuencia.</p>
<p>Si no se especifica el primer inicializador, vale 0. Si alguno se especifica, la inicialización de los restantes continúa la secuencia. Las constantes de una enumeración no necesitan tener valores distintos, pero todos los nombres en las diferentes declaraciones <code>enum</code> de un programa deben ser diferentes.</p>
<p>Aquí los valores de las constantes son ENE = 1, FEB = 2, MAR = 3, etc.</p>
<pre><code>enum meses { 
	ENE = 1, FEB, MAR, ABR, MAY, JUN, 
	JUL,AGO, SEP, OCT, NOV, DIC 
};</code></pre>
<p>Aquí los valores asumidos son respectivamente 0, 1, 2, 5, 6, y nuevamente 1 y 2.</p>
<pre><code>enum varios { ALFA, BETA, GAMMA, DELTA = 5,IOTA, PI = 1, RHO };	</code></pre>
<p>[tc-constantes-preg] Elija dos constantes correctamente escritas: y . y . y . Todas las anteriores.</p>
<p>Una constante de carácter correctamente escrita entre las siguientes es: . <code>A</code>. . . Todas las anteriores.</p>
<p>La constante de carácter en un sistema basado en ASCII tiene el valor decimal 0. 48. “0”.</p>
<p>La constante de carácter en un sistema basado en ASCII tiene el valor decimal 0. 48. “0”.</p>
<p>La constante string <code>A 103</code> se leerá una vez impresa como <code>AA</code>. <code>A103</code>. <code>A\\103</code>. <code>A\103</code>.</p>
<p>La cadena es Una constante decimal. Una constante hexadecimal. Una constante string. Una constante de carácter. Ninguna de las anteriores.</p>
<h2 id="tc-constantes-ej">Ejercicios</h2>
<ol>
<li><p>Indicar si las siguientes constantes están bien formadas, y en caso afirmativo indicar su tipo y dar su valor decimal.</p>
<p><span>4</span></p>
<ol>
<li><p><code>’C’</code></p></li>
<li><p><code>’0’</code></p></li>
<li><p><code>’0xAB’</code></p></li>
<li><p><code>70</code></p></li>
<li><p><code>1A</code></p></li>
<li><p><code>0xABL</code></p></li>
<li><p><code>070</code></p></li>
<li><p><code>’010’</code></p></li>
<li><p><code>0xaB</code></p></li>
<li><p><code>080</code></p></li>
<li><p><code>0x10</code></p></li>
<li><p><code>’0xAB’</code></p></li>
<li><p><code>0XFUL</code></p></li>
<li><p><code>’30’</code></p></li>
<li><p><code>-40L</code></p></li>
<li><p><code>015L</code></p></li>
<li><p><code>x41</code></p></li>
<li><p><code>’B’</code></p></li>
<li><p><code>’’</code></p></li>
<li><p><code>’AB’</code></p></li>
<li><p><code>322U</code></p></li>
</ol></li>
<li><p>Indicar qué caracteres componen las constantes string siguientes:</p>
<ol>
<li><p><code>ABC</code></p></li>
<li><p><code>03B41</code></p></li>
</ol></li>
<li><p>¿Cómo se imprimirán estas constantes string?</p>
<ol>
<li><p><code>BA</code></p></li>
<li><p><code> 0BA</code></p></li>
<li><p><code>BACD</code></p></li>
</ol></li>
<li><p>¿Qué imprime esta sentencia? Pista: <em>nada</em> no es la respuesta correcta.</p>
<pre><code>printf(&quot;0\r1\r2\r3\r4\r5\r6\r7\r8\r9\r&quot;);</code></pre></li>
<li><p>Escribir una macro que devuelva el valor numérico de un carácter correspondiente a un dígito en base decimal.</p></li>
<li><p>Idem donde el carácter es un dígito hexadecimal entre A y F.</p></li>
</ol>
<h1 id="chap:tc-variables">Propiedades de las variables</h1>
<p>Las variables tienen diferentes propiedades según que sean declaradas dentro o fuera de las funciones, y según ciertos modificadores utilizados al declararlas. Entre las propiedades de las variables distinguimos:</p>
<ul>
<li><p>Alcance (desde dónde es visible una variable)</p></li>
<li><p>Vida (cuándo se crea y cuándo desaparece)</p></li>
<li><p>Clase de almacenamiento (dónde y cómo se aloja la información que contiene)</p></li>
<li><p>Liga o <em>linkage</em> (en qué forma puede ser manipulada por el linker)</p></li>
</ul>
<p>Las reglas que determinan, a partir de la declaración de una variable, cuáles serán sus propiedades, son bastante complejas. Estas reglas son tan interdependientes, que necesariamente la discusión de las propiedades de las variables será algo reiterativa.</p>
<h2 id="alcance-de-las-variables">Alcance de las variables</h2>
<p>Una declaración puede aparecer, o bien dentro de una función, o bien fuera de todas ellas. En el primer caso, hablamos de una <strong>variable local</strong>; en el segundo, se trata de una variable <strong>externa, o global</strong>, y las diferencias entre ambas son muchas e importantes. Por supuesto, la primera consecuencia del lugar de declaración es el <strong>alcance</strong>, o ámbito de visibilidad de la variable: una variable local <strong>es visible sólo desde dentro de la función</strong> donde es declarada. Una variable externa puede ser usada <strong>desde cualquier función de la unidad de traducción</strong>, siendo suficiente que la declaración se encuentre antes que el uso.</p>
<p>La variable <code>m</code> declarada al principio es externa, y puede ser vista desde <code>fun1()</code> y <code>fun2()</code>. Sin embargo, <code>fun1()</code> declara su propia variable m local, y toda operación con <code>m</code> dentro de <code>fun1()</code> se referirá a esta última. Por otro lado, la variable <code>n</code> es también externa, pero es visible sólo por <code>fun2()</code>, porque <strong>todo uso de las variables debe estar precedido por su declaración</strong>. Si apareciera una referencia a la variable <code>n</code> en <code>fun1()</code>, se dispararía un error de compilación.</p>
<pre><code>int m;
int fun1() 
{
	int m;
	m=1;
	...
}
int n;
int fun2() 
{
	m=1;
	...
}</code></pre>
<h2 id="vida-de-las-variables">Vida de las variables</h2>
<p>Una variable externa se crea al <strong>momento de carga</strong> del programa, y <strong>perdura durante toda la ejecución</strong> del mismo. Una variable local <strong>se crea y se destruye</strong> a cada invocación de la función donde esté declarada (excepción: las locales estáticas).</p>
<p>Cada vez que <code>fun2()</code> asigna el resultado de <code>fun1()</code> a <code>j</code>, está utilizando el mismo objeto de datos de la misma variable <code>j</code>, porque ésta es externa; pero cada invocación de <code>fun1()</code> crea un nuevo objeto de datos para la variable <code>k</code>, el cual se destruye al terminar esta función.</p>
<pre><code>int j;
int fun1()
{
	int k;
	...
}
int fun2()
{
	j=fun1();
}</code></pre>
<p>La diferencia del siguiente ejemplo con el anterior es que ahora <code>k</code> es declarada con el modificador <strong>static</strong>. Esto hace que <code>k</code> tenga las mismas propiedades de vida que una variable externa. A cada invocación de <code>fun1()</code>, ésta utiliza el mismo objeto de datos, sin modificarlo, para la variable <code>k</code>. Si lee su valor, encontrará el contenido que pueda haberle quedado de la invocación anterior. Si le asigna un valor, la invocación siguiente de <code>fun1()</code> encontrará ese valor en <code>k</code>.</p>
<p>Este ejemplo muestra que alcance y vida no son propiedades equivalentes en C.</p>
<pre><code>int j;
int fun1()
{
	static int k;
	...
}
int fun2()
{
	j=fun1();
}</code></pre>
<p>La propiedad que diferencia ambas instancias de <code>k</code> es la <strong>clase de almacenamiento</strong>; en el primer caso, <code>k</code> es local y automática; en el segundo, <code>k</code> es local pero estática.</p>
<h2 id="clases-de-almacenamiento">Clases de almacenamiento</h2>
<p>Dependiendo de cómo son almacenados los contenidos de las variables (es decir, en qué lugar del mapa de memoria del programa se mantienen los objetos de datos), éstas pueden tener varias clases de almacenamiento. Una variable <strong>externa</strong> tiene clase de almacenamiento <strong>estática</strong>. Una variable <strong>local</strong> tiene -salvo indicación contraria- clase de almacenamiento <strong>automática</strong>. Una tercera clase de almacenamiento es la llamada <strong>registro</strong>. La clase de almacenamiento determina, como se vio recién, la vida de las variables.</p>
<dl>
<dt>Variables estáticas</dt>
<dd><p>Las variables estáticas comienzan su vida al tiempo de carga del programa, es decir, aun antes de que se inicie la ejecución de la función . Existen durante todo el tiempo de ejecución del programa. Son <strong>inicializadas con ceros binarios</strong>, salvo que exista otra inicialización explícita. Son las variables externas y las locales declaradas .</p>
</dd>
<dt>Variables automáticas</dt>
<dd><p>Esta clase abarca exclusivamente las variables, declaradas localmente a una función, que no sean declaradas . El objeto de datos de una variable automática inicia su existencia al entrar el control a la función donde está declarada, y muere al terminar la función. <strong>No son inicializadas</strong> implícitamente, es decir, contienen <strong>basura</strong> salvo que se las inicialice explícitamente.</p>
</dd>
<dt>Variables registro</dt>
<dd><p>Una variable registro no ocupará memoria, sino que será mantenida en un registro del procesador.</p>
</dd>
</dl>
<p>En el segmento de programa siguiente:</p>
<pre><code>int m;
int fun()
{
	int j;
	register int k;
	static int l;
	...
}</code></pre>
<ul>
<li><p>La variable <code>m</code>, por ser externa, tiene clase de almacenamiento <strong>estática</strong>.</p></li>
<li><p>Las variables <code>j</code>, <code>k</code> y <code>l</code> son locales, pero sólo <code>j</code> es <strong>automática</strong>.</p></li>
<li><p>La variable <code>l</code> es <strong>estática</strong> (tiene propiedades de vida similares a las de <code>m</code>).</p></li>
<li><p>Por su parte <code>k</code> es de tipo <strong>registro</strong>, lo que quiere decir que el compilador, siempre que resulte posible, mantendrá sus contenidos en algún registro de CPU de tamaño adecuado.</p></li>
</ul>
<p>Una declaración <code>register</code> debe tomarse solamente como una <em>recomendación</em> hecha por el programador al compilador, ya que no hay garantías de que, al tiempo de ejecución, resulte posible utilizar un registro para esa variable. Más aún, el mismo programa, compilado y corrido en diferentes arquitecturas, podrá utilizar diferentes cantidades de registros para sus variables.</p>
<p>Una variable tendrá un tiempo de acceso muy inferior al de una variable en memoria, porque el acceso a un registro de CPU es mucho más rápido. La motivación de la clase de almacenamiento <strong>registro</strong> se hace evidente en el Cuadro [tab:tiempos] (tomado de <em>Systems Performance: Enterprise and the Cloud</em>, Brendan Gregg, Prentice Hall, 2014).</p>
<p>En general resulta interesante que las variables más frecuentemente accedidas sean las declaradas como ; típicamente, los índices de arrays, variables de control de lazos, etc. Sin embargo, la declaración es quizás algo anacrónica, ya que los compiladores modernos ejecutan una serie de optimizaciones que frecuentemente utilizan registros para mantener las variables, aun cuando no haya indicación alguna por parte del programador.</p>
<p>La clase de almacenamiento <strong>automática</strong> es la natural para las variables locales; ¿cuál es la idea de declarar variables locales que sean <strong>estáticas</strong>? Generalmente se desea aprovechar la capacidad de de las variables estáticas, utilizando el valor al momento de la última invocación para producir uno nuevo.</p>
<p>La inicialización (implícita o explícita) de una variable estática se produce una única vez, al momento de carga del programa. Por el contrario, la inicialización (explícita) de una variable automática se hace al crear cada instancia de la misma (al momento de la entrada del control a la función).</p>
<p>Usando variables estáticas, una función puede, por ejemplo, contar la cantidad de veces que ha sido llamada. En el código siguiente, el ciclo <strong>while</strong> se ejecuta 50 veces y la variable asume cada vez un valor dependiente del anterior, pese a ser local a la función .</p>
<pre><code>int veces()
{
	static int vez=0;
	return ++vez;
}
int fun()
{
	while(veces() &lt;= 50) {
		...
	}
}</code></pre>
<h3 id="variables-y-mapa-de-memoria">Variables y mapa de memoria</h3>
<p>De acuerdo a su clase de almacenamiento, las variables aparecen en diferentes regiones del mapa de memoria del programa en ejecución.</p>
<ul>
<li><p>Las variables locales (automáticas) <strong>se disponen en la pila o stack</strong> del programa. Debido a la forma de administración de esta zona de la memoria, existen solamente hasta la finalización de la función.</p></li>
<li><p>Las variables estáticas (las externas, y las locales cuando son declaradas <code>static</code>) se alojan en la <strong>zona de datos estáticos</strong>. Esta zona no cambia de tamaño ni pierde sus contenidos, y queda inicializada al momento de carga del programa.</p></li>
</ul>
<p>A medida que una función invoca a otras, las variables locales van apareciendo en el stack, y a medida que las funciones terminan, el stack se va desalojando en orden inverso a como aparecieron las variables. Cada función, al recibir el control, toma parte del stack, con los contenidos que hubieran quedado allí de ejecuciones previas, para alojar allí sus variables. A esto se debe que el programa las vea inicializadas con basura.</p>
<p>Con el código de la Fig. [fig:stack1], el estado del stack en momentos sucesivos será:</p>
<ol>
<li><p>Antes de entrar a <code>fun1()</code> se tiene el stack vacío.</p></li>
<li><p>Al entrar a <code>fun1()</code> se disponen sus variables locales en el stack, en orden de aparición.</p></li>
<li><p>Al entrar a <code>fun2()</code> se dispone en el stack su variable local.</p></li>
<li><p>Al salir de <code>fun2()</code> y volver a <code>fun1()</code> se desaloja la variable local de <code>fun2()</code>.</p></li>
<li><p>Al salir de <code>fun1()</code> se desmantela el stack completamente y se vuelve al estado inicial.</p></li>
</ol>
<p>Con el código de la Fig. [fig:stack2], que invoca a dos funciones secuencialmente, el estado del stack en momentos sucesivos será:</p>
<ol>
<li><p>Antes de entrar a <code>fun1()</code> se tiene el stack vacío.</p></li>
<li><p>Al entrar a <code>fun1()</code> se disponen sus variables locales en el stack, en orden de aparición.</p></li>
<li><p>Al terminar <code>fun1()</code> se desmantela el stack.</p></li>
<li><p>Al entrar en <code>fun2()</code> se dispone en el stack su variable local, cuyo objeto de datos tendrá <em>basura</em> debida al valor de a dejado por <code>fun1()</code>.</p></li>
<li><p>Al salir de <code>fun2()</code> se desmantela su stack completamente y se vuelve al estado inicial.</p></li>
</ol>
<h2 id="liga">Liga</h2>
<p>La <strong>liga</strong> es la propiedad que determina si las variables y funciones definidas en una unidad de traducción serán o no visibles por el linker. Una vez que un conjunto de unidades de traducción pasa exitosamente la compilación, tenemos un conjunto de módulos objeto. Cada módulo objeto puede contener, en forma simbólica, pendiente de resolución, <strong>referencias</strong> a variables o funciones definidas en otros módulos. La propiedad de las variables y funciones que permite que el linker encuentre la <strong>definición</strong> de un objeto para aparearlo con su <strong>referencia</strong> es la <strong>liga externa</strong>. Tienen liga externa por defecto las <strong>variables externas y las funciones</strong>, de modo que todas éstas pueden ser referenciadas desde otras unidades de traducción.</p>
<p>El concepto de liga externa es importante cuando el proyecto de desarrollo abarca varias unidades de traducción que deben dar lugar a un ejecutable. Aprovechando la propiedad de liga externa de las funciones, se puede ubicar cada definición de función, o un conjunto de ellas, en un archivo separado. Esto suele facilitar el mantenimiento y aportar claridad a la estructura de un proyecto de desarrollo.</p>
<p>La excepción a la regla de liga externa se produce cuando las <strong>variables externas o funciones</strong> son declaradas con el modificador <strong>static</strong>. Este modificador cambia el tipo de los objetos a liga interna. Un objeto que normalmente sería de liga externa, declarado como static, pasa a ser visible únicamente dentro de la unidad de traducción donde ha sido declarado.</p>
<p>Esta particularidad permite realizar, en cierta medida, ocultamiento de información. Si una unidad de traducción utiliza variables externas o funciones de su uso privado, que no deben hacerse visibles desde afuera, puede declarárselas static, con lo cual se harán inaccesibles a toda otra unidad de traducción. El caso típico se presenta cuando se desea hacer opacas las funciones que implementan un tipo de datos abstracto, haciéndolas de liga interna mientras que las funciones públicas (las de interfaz) se dejan con liga externa.</p>
<p>Finalmente, las variables <strong>locales</strong>, al ser visibles únicamente dentro de su función, se dice que <strong>no tienen liga</strong> (el linker nunca llega a operar con ellas).</p>
<p>En el ejemplo dado en el Cuadro [tab:ejliga], <code>fun1()</code>, <code>fun2()</code> y <code>fun3()</code> están definidas en unas unidades de traducción distintas de la de <code>main()</code>. El fuente <strong>alfa.c</strong> es capaz de dar origen a un programa ejecutable (porque contiene el punto de entrada al programa), pero solamente si al momento de linkedición se logra que el linker resuelva las referencias pendientes a <code>fun1()</code> y a <code>fun2()</code> (que no están definidas en <strong>alfa.c</strong>). Por motivos similares, las referencias en <strong>gamma</strong> necesitan de las definiciones en <strong>beta</strong> al momento de linkedición.</p>
<p>En la práctica logramos esto de varias maneras.</p>
<ol>
<li><p>O bien, con:</p>
<pre><code>gcc alfa.c beta.c gamma.c -o alfa</code></pre>
<p>que significa ;</p></li>
<li><p>o bien con:</p>
<pre><code>gcc -c alfa.c
gcc -c beta.c
gcc -c gamma.c
gcc alfa.o beta.o gamma.o -o alfa</code></pre>
<p>que es la misma tarea pero distribuida en etapas separadas;</p></li>
<li><p>o bien preparando un archivo <strong>makefile</strong> indicando este modo de construcción e invocar a <strong>make</strong>.</p></li>
</ol>
<p><span>l|l|l</span> alfa.c &amp; beta.c &amp; gamma.c<br />
</p>
<p>main() <span> fun1(); fun2(); </span></p>
<p>&amp;</p>
<p>int fun1() <span> ... </span></p>
<p>&amp;</p>
<p>int fun2() <span> ... fun3(); .... </span> int fun3() <span> ... </span></p>
<p><br />
</p>
<p>El ejemplo del Cuadro [tab:ejliga2] es casi idéntico al anterior, salvo que la función <code>fun3()</code> ahora está declarada <code>static</code>, y por este motivo no podrá ser vista por el linker para resolver la referencia pendiente de <code>fun2()</code> en lambda.c. La función <code>fun3()</code> tiene liga interna. Las tres unidades de traducción jamás podrán satisfacer la compilación.</p>
<p><span>l|l|l</span> iota.c &amp; kappa.c &amp; lambda.c<br />
</p>
<p>main() <span> fun1(); fun2(); </span></p>
<p>&amp;</p>
<p>int fun1() <span> ... </span> static int fun3() <span> ... </span></p>
<p>&amp;</p>
<p>int fun2() <span> ... fun3(); ... </span></p>
<p><br />
</p>
<h2 id="declaraciones-y-definiciones">Declaraciones y definiciones</h2>
<ul>
<li><p>Una <strong>declaración</strong> consiste en la <strong>mención</strong> de un objeto (variable o función) antes de su uso.</p></li>
<li><p>Una <strong>definición</strong> consiste en una sentencia de <strong>creación</strong> de dicha variable o función, que a partir de la ejecución de esa sentencia comienza a ser una entidad viva del programa.</p></li>
</ul>
<p>Normalmente una <strong>declaración</strong> de variable (de la forma <code>especificacion_de_tipo identificador</code>) funciona también como <strong>definición</strong> de la variable. Es decir, no sólo queda advertido el compilador de cuál es el <strong>tipo</strong> del objeto que se va a utilizar, sino que también se crea el espacio de memoria (el <strong>objeto de datos</strong>) que va a alojar la información asociada.</p>
<p>Son declaraciones que además funcionan como definiciones:</p>
<pre><code>int a;
float b, c;
int fun() 
{
	...
}</code></pre>
<p>Cuando la declaración de una variable cualquiera aparece precedida del modificador <code>extern</code>, ésta indica el nombre y tipo asociado, pero no habilita al compilador para crear el objeto de datos; se trata de una variable cuya <strong>definición</strong> puede ser encontrada <strong>más adelante, o aun en otra unidad de traducción</strong>. La declaración <code>extern</code> tan sólo enuncia el tipo y nombre de la variable para que el compilador los tenga en cuenta.</p>
<p>Las declaraciones siguientes no crean objetos de datos y por lo tanto <strong>no son</strong> definiciones.</p>
<pre><code>extern int a;
extern float b, c;
int fun();</code></pre>
<p>Una variable externa es visible desde todas las funciones de la unidad de traducción, y además puede ser utilizada desde otras. Esto se debe a la propiedad de liga externa de las variables externas: son visibles al linker como candidatos para resolver referencias pendientes.</p>
<p>El requisito para poder utilizar una variable definida en otra unidad de traducción es declararla con el modificador <strong>extern</strong> en aquella unidad de traducción donde se va a utilizar.</p>
<p>En el Cuadro [tab:ejliga3], el texto <code>delta.c</code> es una unidad de traducción que declara dos variables externas y dos funciones, pero hace <strong>opacas</strong> a la variable <code>n</code> y a la función <code>fun2()</code> con el modificador <strong>static</strong>.</p>
<ul>
<li><p>La función <code>fun1()</code> puede utilizar a todas ellas por estar dentro de la misma unidad de traducción, pero <code>fun3()</code>, que está en otra, sólo puede referenciar a <code>m</code> y a <code>fun1()</code>, que son de liga externa. Para ello debe declarar a <code>m</code> como <code>extern</code>, o de lo contrario no superará la compilación (<em></em>).</p></li>
<li><p>Si, además, <code>eta.c</code> declarara una variable <code>extern int n</code>, con la intención de referirse a la variable <code>n</code> definida en <code>delta.c</code>, la referencia no podría ser resuelta a causa de la condición de liga interna de <code>n</code>.</p></li>
<li><p>Los usos de funciones (como <code>fun1()</code> en <code>eta.c</code>) pueden aparecer sin declaración previa, pero en este caso el compilador asumirá tipos de datos default para los argumentos y para el tipo del valor devuelto por la función (<strong>int</strong> en todos los casos).</p></li>
</ul>
<p><span>l|l</span> delta.c &amp; eta.c<br />
</p>
<p>int m; static int n; int fun1() <span> n=fun2(); ... </span> static int fun2() <span> ... </span></p>
<p>&amp;</p>
<p>extern int m; int fun3() <span> m=fun1(); </span></p>
<p><br />
</p>
<h2 id="modificadores-especiales">Modificadores especiales</h2>
<dl>
<dt>Const</dt>
<dd><p>El modificador <code>const</code> indica que una variable no será modificada. Una variable <code>const</code> solamente puede inicializarse al momento de carga del programa (y debería hacerse así, ya que no hay otra manera de asignarle un valor).</p>
<pre><code>const int a=12; 	/* se declara un entero constante, con inicializacion */
a++;				/* el compilador no aprobara esta sentencia */</code></pre>
<p>El modificador <code>const</code> también permite expresar, en el prototipo de una función, que un argumento no podrá ser modificado por la función, aun cuando sea pasado por referencia.</p>
</dd>
<dt>Volatile</dt>
<dd><p>Los compiladores modernos aplican una cantidad de pasos de optimización cuando ven instrucciones aparentemente redundantes o sin efectos, porque su desplazamiento o eliminación puede implicar ventajas en tiempo de ejecución o espacio de almacenamiento. Esto es especialmente así si las instrucciones sospechosas se encuentran dentro de ciclos. El modificador volatile sirve para advertir al compilador de que una variable será modificada asincrónicamente con la ejecución del programa (por ejemplo, por efecto de una rutina de atención de interrupciones) y por lo tanto el optimizador no puede inferir correctamente su utilidad dentro del programa. Esto evitará que el compilador aplique la lógica de optimización a las instrucciones que involucran a esta variable.</p>
</dd>
</dl>
<p>El ciclo <code>while</code> del Cuadro [tab:ciclo] podría ser reescrito por un optimizador, extrayendo del ciclo la asignación <code>a=beta</code> en el entendimiento de que <code>beta</code> no cambiará en ninguno de los pasos del ciclo.</p>
<p><span>l|l|l</span> Sin optimizar &amp; Optimizado &amp; Optimización inhibida<br />
</p>
<p>while(!fin) <span> a = beta; b = fun(a); </span></p>
<p>&amp;</p>
<p>a = beta; while(!fin) b = fun(a);</p>
<p>&amp;</p>
<p>volatile int beta; while(!fin) <span> a = beta; b = fun(a); </span></p>
<p><br />
</p>
<p>Sin embargo, si esperamos que la variable beta cambie por acción de algún agente externo a la rutina en cuestión, con la declaración previa <code>volatile int beta</code> el compilador se abstendrá de optimizar las líneas donde intervenga <code>beta</code>.</p>
<p>[sec:tc-variables-preg] El alcance de una variable es el rango de valores que puede tomar. el tiempo transcurrido entre su creación y su desaparición. el conjunto de líneas de código desde donde es visible la variable.</p>
<p>Una variable local es aquella que aparece definida dentro de una función. fuera de una función. fuera de todas las funciones.</p>
<p>Una variable externa es aquella que aparece definida fuera de una función pero dentro de una segunda función. fuera de un bloque. fuera de toda función. dentro de una función.</p>
<p>Una variable local puede ser usada desde toda la unidad de traducción. desde dentro de la función donde se la declara. desde las funciones que aparecen con posterioridad a su declaración. en todos los casos anteriores.</p>
<p>Una variable externa puede ser usada desde toda la unidad de traducción. desde dentro de la función donde se la declara. desde las funciones que aparecen con posterioridad a su declaración. en todos los casos anteriores.</p>
<p>Si una función declara una variable local con el mismo nombre que una externa, los usos de esa variable dentro de la función se referirán a la variable local. la variable externa. depende de la implementación.</p>
<p>Una variable local vive durante toda la ejecución del programa. la ejecución de la función donde se la declara. la compilación del programa. la ejecución de las funciones que aparecen con posterioridad a su declaración</p>
<p>Cambiar la clase de almacenamiento de una variable implica afectar cuándo aparece y desaparece. el tamaño de los objetos de datos que contiene. el ámbito de la variable dentro de la unidad de traducción. todo lo anterior.</p>
<p>La clase de almacenamiento por defecto de las variables locales es . . . .</p>
<p>La clase de almacenamiento por defecto de las variables externas es . . . .</p>
<p>Una variable con clase de almacenamiento se crea estáticamente al ejecutarse la función donde se la define. se crea estáticamente al cargarse el programa en memoria. se crea estáticamente al iniciarse la ejecución de .</p>
<p>Una variable con clase de almacenamiento se inicializa con ceros al inicio del programa. no se inicializa y contiene basura. se inicializa con ceros al ejecutarse la función donde se la define.</p>
<p>Una variable con clase de almacenamiento se inicializa con ceros al inicio del programa. no se inicializa y contiene basura. se inicializa con ceros al ejecutarse la función donde se la define.</p>
<p>Las variables locales que son las declaradas . las declaradas . las declaradas . ninguna de las anteriores.</p>
<p>Si un objeto se declara se hace visible desde otras unidades de traducción. se impide que se vea desde otras unidades de traducción. se impide que se vea desde otras funciones que aquella donde se lo define.</p>
<p>La declaración para una variable crea el objeto de datos correspondiente. equivale a una definición de la variable. indica la unidad de traducción donde está definida la variable. solamente enuncia el tipo y nombre de la variable.</p>
<p>Una declaración puede corresponderse con una variable externa en otra unidad de traducción. con una variable local en otra unidad de traducción. ninguna de las anteriores.</p>
<p>Una declaración puede corresponderse con una variable externa en otra unidad de traducción. con una variable local en otra unidad de traducción. ninguna de las anteriores.</p>
<p>Una variable debe ser optimizada. no debe ser optimizada. puede ser modificada sólo por funciones en la misma unidad de traducción. no puede ser modificada.</p>
<p>Una variable debe ser optimizada. no debe ser optimizada. puede ser modificada sólo por funciones en la misma unidad de traducción. no puede ser modificada.</p>
<h2 id="sec:tc-variables-ej">Ejercicios</h2>
<ol>
<li><p>Copie, compile y ejecute el siguiente programa. Posteriormente agregue un modificador static sobre la variable a y repita la experiencia.</p>
<pre><code>int fun()
{
	int a;
	a = a + 1;
	return a;
}
main()
{
	printf(&quot;%d\n&quot;, fun());
	printf(&quot;%d\n&quot;, fun());
}</code></pre></li>
<li><p>¿Qué imprime este programa?</p>
<pre><code>int alfa;
int fun()
{
	int alfa;
	alfa = 1;
	return alfa;
}
main()
{
	alfa = 2;
	printf(&quot;%d\n&quot;,fun());
	printf(&quot;%d\n&quot;,alfa);
}</code></pre></li>
<li><p>¿Qué imprime este programa?</p>
<pre><code>int alfa;
int fun(int alfa)
{
	alfa = 1;
	return alfa;
}
main()
{
	alfa = 2;
	printf(&quot;%d\n&quot;,fun(alfa));
	printf(&quot;%d\n&quot;,alfa);
}</code></pre></li>
<li><p>Copie y compile, juntas, las unidades de traducción que se indican abajo. ¿Qué hace falta para que la compilación sea exitosa?</p>
<p><span>p<span>4cm</span>|p<span>5cm</span></span> fuente1.c &amp; fuente2.c<br />
</p>
<p>int a; int fun1(int x) <span> return 2 * x; </span></p>
<p>&amp;</p>
<p>main() <span> a = 1; printf(“d”, fun1(a)); </span></p>
<p><br />
</p></li>
<li><p>¿Qué ocurre si un fuente intenta modificar una variable externa, declarada en otra unidad de traducción como <code>const</code>? Prepare, compile y ejecute un ejemplo.</p></li>
<li><p>¿Qué resultado puede esperarse de la compilación de estos fuentes?</p>
<p><span>p<span>4cm</span>|p<span>5cm</span>|p<span>4cm</span></span> header.h &amp; fuente1.c &amp;fuente2.c<br />
</p>
<p>#include &lt;stdio.h&gt; #define VALOR 6</p>
<p>&amp;</p>
<p>#include “header.h” main() <span> static int c; printf(&quot;</span></p>
<p>&amp;</p>
<p>#include “header.h” int fun(int x) <span> return VALOR * x; </span></p>
<p><br />
</p></li>
<li><p>Denotemos esquemáticamente que un módulo objeto <code>prueba.o</code> contiene un objeto de datos <code>x</code> y una función <code>fun()</code>, ambos de liga externa, de esta manera:</p>
<table>
<thead>
<tr class="header">
<th align="center">prueba.o</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">x</td>
</tr>
<tr class="even">
<td align="center">fun()</td>
</tr>
</tbody>
</table>
<p>Si se tiene un conjunto de archivos y unidades de traducción que se compilarán para formar los respectivos módulos objeto, ¿cómo se aplicaría la notación anterior al conjunto de módulos objeto resultantes? Hacer el diagrama para los casos que aparecen en el Cuadro [tab:fuentes]. ¿Hay colisión de nombres? ¿Hay referencias que el linker no pueda resolver? Cada grupo de fuentes, ¿puede producir un ejecutable?</p></li>
<li><p>Un conjunto de programas debe modelar eventos relativos a un aeropuerto. Se necesita preparar una implementación de las estructuras de datos y funciones del aeropuerto, para ser usada por los demás programas. Especifique las variables y funciones (en pseudocódigo) que podrán satisfacer los siguientes requerimientos. Preste atención a las declaraciones extern y static.</p>
<ul>
<li><p>El aeropuerto tendrá cinco pistas.</p></li>
<li><p>Se mantendrá un contador de la cantidad total de aviones en el aeropuerto y uno de la cantidad total de aviones en el aire.</p></li>
<li><p>Para cada pista se mantendrá la cantidad de aviones esperando permiso para despegar de ella y la cantidad de aviones esperando permiso para aterrizar en ella.</p></li>
<li><p>Habrá una función para modelar el aterrizaje y otra para modelar el despegue por una pista dada (decrementando o incrementando convenientemente la cantidad de aviones en una pista dada, en tierra y en el aire).</p></li>
<li><p>Habrá una función para consultar, y otra para establecer, la cantidad de aviones esperando aterrizar o despegar por cada pista.</p></li>
<li><p>Habrá una función para consultar la cantidad de aviones en tierra y otra para consultar la cantidad de aviones en el aire.</p></li>
<li><p>No deberá ser posible que un programa modifique el estado de las estructuras de datos sino a través de las funciones dichas.</p></li>
</ul></li>
<li><p>¿Cuáles pueden ser los al programa que sean capaces de cambiar el valor de una variable <code>volatile</code>?</p></li>
</ol>
<p><span>m<span>0.2cm</span>|m<span>3cm</span>|m<span>3.5cm</span>|m<span>3.5cm</span>|m<span>3cm</span></span> &amp; hdr1.h &amp; fuente1.c &amp; fuente2.c &amp; fuente3.c<br />
</p>
<p>a) &amp;</p>
<p>#define UNO 1 #define DOS 2 extern int a;</p>
<p>&amp;</p>
<p>#include “hdr1.h” main() <span> int b; b = fun1(a); </span></p>
<p>&amp;</p>
<p>#include “hdr1.h” int fun1(int x) <span> return x+fun2(x); </span> static int fun2(int x) <span> return x + DOS; </span></p>
<p>&amp;</p>
<p>#include “hdr1.h” int a;</p>
<p><br />
</p>
<p>b) &amp;</p>
<p>extern int c; extern int fun1(int p), fun2(int p);</p>
<p>&amp;</p>
<p>#include “hdr1.h” int fun1(int x) <span> return fun2(x)+1; </span></p>
<p>&amp;</p>
<p>int a, b, c=1; int fun2(int x) <span> return x-1; </span></p>
<p>&amp;</p>
<p>main() <span> int d; d = fun1(3); </span></p>
<p><br />
</p>
<p>c) &amp;</p>
<p>&amp;</p>
<p>int fun1(int x) <span> return x+1; </span> int fun2(int x) <span> return x+2; </span></p>
<p>&amp;</p>
<p>int fun3(int x) <span> return x+3; </span> static int fun2(int x) <span> return x+4; </span></p>
<p>&amp;</p>
<p>main() <span> int a; a = fun1(a); </span></p>
<p><br />
</p>
<p>d) &amp;</p>
<p>&amp;</p>
<p>int fun1(int x) <span> extern int b; x = b-fun2(x); </span></p>
<p>&amp;</p>
<p>static int a = 1; static int b = 1; int fun2(int x) <span> return x-a; </span></p>
<p>&amp;</p>
<p>int b; main() <span> b = 2; printf(&quot; fun1(3)); </span></p>
<p><br />
</p>
<h1 id="chap:tc-operadores">Operadores</h1>
<h2 id="operadores-aritméticos">Operadores aritméticos</h2>
<p>El C tiene un conjunto de operadores muy rico, incluyendo algunos operadores que es difícil encontrar en otros lenguajes de programación. Comenzamos por los operadores aritméticos.</p>
<ul>
<li><p><span class="math inline">+</span>, <span class="math inline">−</span>, <span class="math inline">*</span>, <span class="math inline">/</span> (operaciones aritméticas usuales)</p></li>
<li><p><span class="math inline">++</span>, <span class="math inline">−−</span> (incremento y decremento)</p></li>
<li><p><span class="math inline">%</span> (operador módulo)</p></li>
<li><p>No existe operador de <strong>exponenciación</strong> en C. En cambio, está implementada una función <code>pow()</code> en la Biblioteca Standard.</p></li>
<li><p>No existe operador de <strong>división entera</strong>, opuesto a la división entre números reales, como en Pascal. Sin embargo, la división entre enteros da un entero: el resultado se trunca debido a las reglas de evaluación de expresiones.</p></li>
</ul>
<p>Aquí <code>a</code> y <code>b</code> reciben respectivamente el cociente y el resto de dividir un VALOR por 256. Imprimiéndolos podemos ver cómo una CPU, en la cual un <code>unsigned short int</code> tuviera un tamaño de 16 bits, almacenaría ese VALOR sobre dos bytes.</p>
<pre><code>unsigned char a,b;
a=VALOR / 256;
b=VALOR % 256;  	</code></pre>
<p>La siguiente división de <code>j</code> por <code>k</code> es entera. La variable <code>c</code> valdrá 1.</p>
<pre><code>float c;
int j,k;
j=3; 
k=2;
c=j/k; </code></pre>
<p>Los operadores de incremento y decremento (<span class="math inline">++</span> y <span class="math inline">−−</span>) equivalen a las sentencias del tipo <code>a = a+1</code> o <code>b = b-1</code>. Suman o restan una unidad a su argumento, que debe ser un tipo entero. Se comportan diferentemente según que se apliquen en forma prefija o sufija.</p>
<p><span>l|l|l</span> Sentencias &amp; a &amp; b<br />
</p>
<p>a=5; b=a++;</p>
<p>&amp; 6 &amp; 5<br />
</p>
<p>a=5; b=++a;</p>
<p>&amp; 6 &amp; 6<br />
</p>
<p>a=3; b=a–;</p>
<p>&amp; 2 &amp; 3<br />
</p>
<p>a=3; b=–a;</p>
<p>&amp; 2 &amp; 2<br />
</p>
<ul>
<li><p>Aplicados como prefijos, el valor devuelto por la expresión es el valor incrementado o decrementado.</p></li>
<li><p>Aplicados como sufijos, el incremento o decremento se realiza como efecto lateral, pero el valor devuelto por la expresión es el anterior al incremento o decremento.</p></li>
</ul>
<h3 id="abreviaturas">Abreviaturas</h3>
<p>Existe una forma de abreviar la notación en las expresiones del tipo <code>a = a*b</code> y <code>a = a+b</code>. Podemos escribir, respectivamente:</p>
<pre><code>a *= b;
a += b; </code></pre>
<p>Esto se aplica a todos los operadores aritméticos y de bits.</p>
<h2 id="operadores-de-relación">Operadores de relación</h2>
<ul>
<li><p><code>==</code> (igualdad)</p></li>
<li><p><code>&lt;, &gt;, &lt;=, &gt;=</code></p></li>
<li><p><code>!=</code> (distinto de)</p></li>
</ul>
<p>La sentencia <code>k=1;</code>, claramente, asigna 1 a la variable ; pero además, si se encuentra en un contexto donde sea evaluada, la expresión <code>k=1</code> vale 1. Como consecuencia, su valor lógico es <code>TRUE</code>, independientemente del valor que tuviera k. Por lo tanto, la sentencia <code>if(k=1) k=2;</code> <strong>siempre</strong> asignará el valor 2 a . Por el contrario, la expresión <code>k=0</code> es siempre <code>FALSE</code>.</p>
<p>La sentencia:</p>
<pre><code>if(k = 1)
     ...</code></pre>
<p>es sintácticamente válida, pero en lugar de <strong>comparar</strong> <code>k</code> con 1, <strong>asigna</strong> el valor 1 a la variable <code>k</code>.</p>
<p>Si el programador desea obtener el valor lógico de la comparación de <code>k</code> con 1, debe utilizar el operador de relación <code>==</code>, y la expresión correcta es <code>if(k == 1)</code>.</p>
<h2 id="operadores-lógicos">Operadores lógicos</h2>
<pre><code>!, &amp;&amp;, || (not, and, or)	</code></pre>
<p>La siguiente es una expresión lógica ().</p>
<pre><code>a==b || !(c &lt; 2)    </code></pre>
<p>Al no existir tipo booleano en C, los valores lógicos se equiparan a los aritméticos.</p>
<ul>
<li><p>Una expresión formada con un operador <code>||</code>, <code>&amp;&amp;</code> o <code>!</code> arroja un valor aritmético <span class="math inline">1</span> si es <span class="math inline"><em>V</em></span>, y un valor <span class="math inline">0</span> si es <span class="math inline"><em>F</em></span>.</p></li>
<li><p>Toda expresión cuyo valor aritmético sea diferente de <span class="math inline">0</span> es .</p></li>
<li><p>Toda expresión que dé <span class="math inline">0</span> es .</p></li>
</ul>
<ul>
<li><p><code>a - b</code>, que es una expresión aritmética, es también una expresión lógica. Será <span class="math inline"><em>F</em></span> cuando a sea igual a b.</p></li>
<li><p><code>a</code> como expresión lógica será <span class="math inline"><em>V</em></span> sólo cuando a sea distinto de 0 .</p></li>
<li><p><code>a = 8</code> es una expresión de asignación. Su valor aritmético es el valor asignado, por lo cual, como expresión lógica, es <span class="math inline"><em>V</em></span>, ya que 8 es distinto de 0.</p></li>
</ul>
<h3 id="constantes-lógicas">Constantes lógicas</h3>
<p>Generalmente los compiladores definen dos símbolos o macros, <code>FALSE</code> y <code>TRUE</code>, en el header <code>stdlib.h</code>, y a veces también en otros. Su definición suele ser la siguiente:</p>
<pre><code>#define FALSE  0
#define TRUE   !FALSE   </code></pre>
<p>Es conveniente utilizar estos símbolos para agregar expresividad a los programas.</p>
<h2 id="operadores-de-bits">Operadores de bits</h2>
<ul>
<li><p><code> </code> (negación de bits)</p></li>
<li><p><code>&amp;, |</code> (<strong>and</strong>, <strong>or</strong> de bits)</p></li>
<li><p><code>^</code> (<strong>or</strong> de bits exclusivo)</p></li>
<li><p><code>&gt;&gt;, &lt;&lt;</code> (desplazamiento de bits a derecha y a izquierda)</p>
<p>El desplazamiento de bits es <strong>con pérdida</strong>, en el sentido de que:</p>
<ul>
<li><p>Un desplazamiento a la izquierda en un bit equivale a una multiplicación por 2; un desplazamiento a la derecha en un bit equivale a una división por 2.</p></li>
<li><p>Si el bit menos significativo es 1 (si el número es impar), al desplazar a la derecha ese bit se pierde (la división no es exacta).</p></li>
<li><p>Si el bit más significativo es 1 (si el número es igual o mayor que la mitad de su rango posible), al desplazar a la izquierda ese bit se pierde (la multiplicación da overflow).</p></li>
</ul></li>
</ul>
<p>El operador de <strong>negación</strong> de bits es unario y provoca el complemento a uno de su operando. Los operadores <strong>and</strong>, <strong>or</strong> y <strong>or exclusivo</strong> de bits son binarios.</p>
<pre><code>unsigned char a;
a = ~255;             /* a &lt;-- 0    */
a = 0xf0 ^ 255;       /* a &lt;-- 0x0f */
a = 0xf0 &amp; 0x0f;      /* a &lt;-- 0x00 */
a = 0xf0 | 0x0f;      /* a &lt;-- 0xff */                </code></pre>
<p>Los operadores <code>&gt;&gt;</code> y <code>&lt;&lt;</code> desplazan los bits de un objeto de tipo <code>char</code>, <code>int</code> o <code>long</code>, una cantidad dada de posiciones.</p>
<pre><code>unsigned char a,b,c;
a = 1 &lt;&lt; 4;
b = 2 &gt;&gt; 1;
c &lt;&lt;= 2;    </code></pre>
<ul>
<li><p>En el primer caso, el 1 se desplaza 4 bits a la izquierda; <code>a</code> vale finalmente 16.</p></li>
<li><p>En el segundo caso, el bit 1 de la constante 2, a uno, se desplaza un lugar a la derecha; <code>b</code> vale 1.</p></li>
<li><p>En el tercero, <code>c</code> se desplaza dos bits a la izquierda.</p></li>
</ul>
<h2 id="operadores-especiales">Operadores especiales</h2>
<p>Distinguimos como especiales los operadores de <strong>asignación</strong> e <strong>inicialización</strong>, que son operaciones diferentes aunque desafortunadamente son representadas por el mismo signo, y el operador <strong>ternario</strong>.</p>
<ul>
<li><p><code>=</code> (operador de asignación)</p></li>
<li><p><code>=</code> (operador de inicialización)</p></li>
<li><p>?: (operador ternario)</p></li>
</ul>
<h3 id="inicialización">Inicialización</h3>
<p>Una inicialización es la operación que permite asignar un valor inicial a una variable en el momento de su definición:</p>
<pre><code>int a=1;</code></pre>
<h3 id="asignación">Asignación</h3>
<p>Una asignación es la operación que permite asignar un valor a una variable que ha sido definida anteriormente:</p>
<pre><code>int a;
a=1;</code></pre>
<h3 id="operador-ternario">Operador ternario</h3>
<p>El operador ternario comprueba el valor lógico de una expresión, y, según este valor, se evalúa a una u otra de las restantes expresiones. Supongamos tener la expresión siguiente.</p>
<pre><code>a = (expresión_1) ? expresión_2 : expresión_3;    </code></pre>
<p>Entonces, si <code>expresión_1</code> es <span class="math inline"><em>V</em></span>, el ternario se evaluará a <code>expresión_2</code>, y ese valor será asignado a la variable <code>a</code>. Si <code>expresión_1</code> es <span class="math inline"><em>F</em></span>, <code>a</code> quedará con el valor <code>expresión_3</code>.</p>
<p>La expresión</p>
<pre><code>c = b + (a &lt; 0) ? -a : a;   </code></pre>
<p>asigna a <code>c</code> el valor de <code>b</code> más el valor absoluto de <code>a</code>.</p>
<h2 id="precedencia-y-orden-de-evaluación">Precedencia y orden de evaluación</h2>
<p>En una expresión compleja, formada por varias subexpresiones conectadas por operadores, es peligroso hacer depender el resultado del orden de evaluación de las subexpresiones. Si los operadores en una subexpresión tienen la misma precedencia, la evaluación se hace de izquierda a derecha, pero en caso contrario el orden de evaluación no queda definido. Por ejemplo, en la expresión <code>w*x/++y + z/y</code> se puede contar con que primeramente se ejecutará <code>w*x</code> y sólo entonces <code>w*x/++y</code>, porque los operadores de multiplicación y división son de la misma precedencia. Sin embargo, no se puede asegurar que <code>w*x/++y</code> sea evaluado antes o después de <code>z/y</code>, lo que hace que el resultado de esta expresión sea <strong>indefinido</strong> en C, ya que no sabemos cuál será el valor de <code>y</code> que intervendrá en el cómputo de <code>z/y</code>.</p>
<p>La solución es <strong>secuencializar</strong> la ejecución, dividiendo las expresiones en sentencias:</p>
<pre><code>a = w * x / ++y;
b = a + z / y;     	</code></pre>
<h2 id="resumen">Resumen</h2>
<p>El Cuadro [tab:preced] ilustra las relaciones de precedencia entre los diferentes operadores. La tabla está ordenada con los operadores de mayor precedencia a la cabeza. Los que se encuentran en el mismo renglón tienen la misma precedencia.</p>
<p>[tc-operadores-preg] El operador en C significa exponenciación en base 10. exponenciación en base <span class="math inline"><em>e</em></span>. <strong>or</strong> exclusivo de bits. <strong>or</strong> lógico exclusivo.</p>
<p>Luego de ejecutar las sentencias</p>
<pre><code>c = 1; 
a = c++;	</code></pre>
<p>las variables y valen respectivamente: 1 y 1. 1 y 2. 2 y 2. 2 y 1. ninguna de las anteriores.</p>
<p>Luego de ejecutar las sentencias</p>
<pre><code>c = 1; 
a = ++c;</code></pre>
<p>las variables y valen respectivamente: 1 y 1. 1 y 2. 2 y 2. 2 y 1. ninguna de las anteriores.</p>
<p>Luego de ejecutar las sentencias</p>
<pre><code>c = 1; 
a = --c; 
a += c++;</code></pre>
<p>las variables y valen respectivamente 1 y 1. 1 y 2. 2 y 2. 2 y 1. ninguna de las anteriores.</p>
<p>La sentencia puede escribirse también</p>
<p>Luego de ejecutar las sentencias</p>
<pre><code>a = 1; 
b = 2; 
if(a == b) 
	b = a;	</code></pre>
<p>las variables y valen respectivamente 1 y 1. 1 y 2. 2 y 2. ninguno de los anteriores.</p>
<p>Luego de ejecutar las sentencias</p>
<pre><code>a = 1; 
b = 2; 
if(a = b) 
	b = a;	</code></pre>
<p>las variables y valen respectivamente 1 y 1. 1 y 2. 2 y 2. ninguno de los anteriores.</p>
<p>Luego de ejecutar las sentencias</p>
<pre><code>a = 1; 
b = 0; 
if(a = b) 
	b = a;</code></pre>
<p>las variables y valen respectivamente 0 y 0. 0 y 2. 2 y 2. ninguno de los anteriores.</p>
<p>¿Cuál de las reglas <strong>no es</strong> válida? Toda expresión cuyo valor aritmético es 0 tiene valor lógico falso. Toda expresión cuyo valor lógico es falso tiene valor aritmético 0. Toda expresión cuyo valor aritmético es 1 tiene valor lógico verdadero. Toda expresión cuyo valor lógico es verdadero tiene valor aritmético 1.</p>
<p>Indicar cuál de las expresiones tiene valor lógico falso:</p>
<p>¿Cuál es el valor de la expresión <code>c = 20</code>? Depende del valor de c. 20.</p>
<p>¿Cuál es el valor de la expresión <code>c == 20</code>? Depende del valor de c. 20.</p>
<p>La operación equivale a: dividir a por 7. dividir a por 8. tomar el resto de dividir a por 7. tomar el resto de dividir por 8. restarle 8 a . restarle 7 a .</p>
<p>La operación equivale a: dividir a por dos. dividir a por cuatro. multiplicar a por dos. multiplicar a por cuatro.</p>
<p>Dada la declaración la operación tiene como resultado 0. 1. 2. 255. 127.</p>
<p>La expresión vale a, si a es igual a b. b, si c es distinto de d. c, si c es igual a d. d, si a es distinto de b.</p>
<p>La sentencia imprime: 1. 2. 3. 4.</p>
<h2 id="tc-operadores-ej">Ejercicios</h2>
<ol>
<li><p>¿Qué valor lógico tienen las expresiones siguientes?</p>
<ol>
<li><p><code>TRUE &amp;&amp; FALSE</code></p></li>
<li><p><code>TRUE || FALSE</code></p></li>
<li><p><code>0 &amp;&amp; 1</code></p></li>
<li><p><code>0 || 1</code></p></li>
<li><p><code>(c &gt; 2) ? (b &lt; 5) : (2 != a)</code></p></li>
<li><p><code>(b == c) ? 2 : FALSE;</code></p></li>
<li><p><code>c == a;</code></p></li>
<li><p><code>C = A;</code></p></li>
<li><p><code>0 || TRUE</code></p></li>
<li><p><code>TRUE || 2-(1+1)</code></p></li>
<li><p><code>TRUE &amp;&amp; !FALSE</code></p></li>
<li><p><code>!(TRUE &amp;&amp; !FALSE)</code></p></li>
<li><p><code>x == y &gt; 2</code></p></li>
</ol></li>
<li><p>Escriba una macro <code>IDEM(x,y)</code> que devuelva el valor lógico <code>TRUE</code> si <code>x</code> e <code>y</code> son iguales, y <code>FALSE</code> en caso contrario. Escriba <code>NIDEM(x,y)</code> que devuelva <code>TRUE</code> si las expresiones <code>x</code> e <code>y</code> son diferentes y <code>FALSE</code> si son iguales.</p></li>
<li><p>Escriba una macro <code>PAR(x)</code> que diga si un entero es par. Muestre una versión usando el operador , una usando el operador <code>&gt;&gt;</code>, una usando el operador <code>&amp;</code> y una usando el operador <code>|</code>.</p></li>
<li><p>Escriba macros <code>MIN(x,y)</code> y <code>MAX(x,y)</code> que devuelvan el menor y el mayor elemento entre <code>x</code> e <code>y</code>. Usando las anteriores, escriba macros <code>MIN3(x,y,z)</code> y <code>MAX3(x,y,z)</code> que devuelvan el menor y el mayor elemento entre tres expresiones.</p></li>
<li><p>¿Cuál es el significado aritmético de la expresión <code>1&lt;&lt;x</code> para diferentes valores de <code>x</code> = 0, 1, 2... ?</p></li>
<li><p>Utilice el resultado anterior para escribir una macro <code>DOSALA(x)</code> que calcule <span class="math inline">2</span> elevado a la <span class="math inline"><em>x</em></span>-ésima potencia.</p></li>
<li><p>¿A qué otra expresión es igual <code>a&lt;b || a&lt;c &amp;&amp; c&lt;d</code>?</p>
<ol>
<li><p><code>a&lt;b || (a&lt;c &amp;&amp; c&lt;d)</code></p></li>
<li><p><code>(a&lt;b || a&lt;c) &amp;&amp; c&lt;d</code></p></li>
</ol></li>
<li><p>Reescribir utilizando abreviaturas:</p>
<ol>
<li><p><code>a = a + 1;</code></p></li>
<li><p><code>b = b * 2;</code></p></li>
<li><p><code>b = b - 1;</code></p></li>
<li><p><code>c = c - 2;</code></p></li>
<li></li>
<li><p><code>e = e &amp; 0x0F;</code></p></li>
<li><p><code>a = a + 1;</code></p></li>
<li><p><code>b = b + a;</code></p></li>
<li><p><code>a = a - 1;</code></p></li>
<li><p><code>c = c * a;</code></p></li>
</ol></li>
<li><p>¿Qué escribirá este programa?</p>
<pre><code>main()
{
	int a = 1;
	int b;

	b = a || 12;

	printf(&quot;%d\n&quot;,b);
}</code></pre></li>
</ol>
<h1 id="estructuras-de-control">Estructuras de control</h1>
<p>Las estructuras de control de C no presentan, en conjunto, grandes diferencias con las del resto de los lenguajes estructurados. En los esquemas siguientes, donde figura una sentencia puede reemplazarse por varias sentencias encerradas entre llaves (un <strong>bloque</strong>).</p>
<h2 id="estructura-alternativa">Estructura alternativa</h2>
<p>Como en la casi totalidad de los lenguajes de programación, la estructura alternativa permite ejecutar un bloque de una o más sentencias cuando la expresión condicional es <span class="math inline"><em>V</em></span>, y opcionalmente otro bloque cuando dicha expresión es <span class="math inline"><em>F</em></span>. Formas típicas de la estructura alternativa son las siguientes.</p>
<pre><code>if(expresión)
    sentencia;</code></pre>
<pre><code>if(expresión) {
    sentencias
    ...
}</code></pre>
<pre><code>if(expresión)
    sentencia;
else
    sentencia;</code></pre>
<p>El formato en C es libre, y las llaves sólo son necesarias cuando las sentencias de ejecución condicional son más de una.</p>
<pre><code>if(a == 8) c++;</code></pre>
<p>Las condiciones lógicas se construyen en base a operadores de relación y lógicos.</p>
<pre><code>if(c &gt;= 2 || fun(b) &lt; 0)</code></pre>
<p>La cláusula <code>else</code> indica el bloque que se ejecutará en el caso negativo de la condición.</p>
<pre><code>if(d)
	c++;
else
	c += 2;</code></pre>
<p>En las estructuras anidadas, la cláusula <code>else</code> se aparea con el <code>if</code> más interno, salvo que las llaves expresen otra cosa.</p>
<p>En el Cuadro [tab:indent], las llaves del <strong>Listado 1</strong> muestran cómo están asociadas las estructuras. En el <strong>Listado 2</strong>, se han quitado, con lo cual la semántica cambia, pero se mantiene la misma indentación, lo que puede dar lugar a confusión. El <strong>Listado 2</strong> en realidad es equivalente al <strong>Listado 3</strong>, que utiliza llaves aunque en forma redundante, y además tiene la indentación correcta.</p>
<p><span>l|l|l</span> Listado 1 &amp; Listado 2 &amp; Listado 3<br />
</p>
<p>if(c &gt;= 2) <span> if(d) c++; </span> else c += 2;</p>
<p>&amp;</p>
<p>if(c &gt;= 2) if(d) c++; else c += 2;</p>
<p>&amp;</p>
<p>if(c &gt;= 2) <span> if(d) c++; else c += 2; </span></p>
<p><br />
</p>
<h2 id="estructuras-repetitivas">Estructuras repetitivas</h2>
<p>El lenguaje C dispone de las estructuras adecuadas para procesar conjuntos de <strong>0 o más</strong> datos (estructura <code>while</code>) y <strong>1 o más</strong> datos (estructura <code>do-while</code>).</p>
<p>Ambas estructuras ejecutan su cuerpo de sentencias mientras la expresión resulte verdadera, pero en un lazo <code>while</code>, la comprobación de la expresión se hace <strong>al principio de cada ciclo</strong>. En cambio, en el lazo <code>do-while</code>, se hace <strong>al final</strong>.</p>
<h3 id="estructura-while">Estructura while</h3>
<pre><code>while(expresión)
    sentencia;</code></pre>
<h3 id="estructura-do-while">Estructura do-while</h3>
<pre><code>do {
    sentencias;
} while(expresión);</code></pre>
<h3 id="estructura-for">Estructura for</h3>
<p>La iteración es un caso particular de lazo <code>while</code> donde necesitamos que un bloque de sentencias se repita una cantidad previamente conocida de veces. Estos casos implican la inicialización de variables de control, el incremento o decremento de las mismas, y la comprobación por valor límite. Estas tareas administrativas se pueden hacer más cómoda y expresivamente con un lazo <code>for</code>.</p>
<p>El esquema es:</p>
<pre><code>for(inicialización; condición_mientras;  incremento)
    sentencia;</code></pre>
<p>Donde:</p>
<ul>
<li><p><strong>inicialización</strong> es una o más sentencias, separadas por comas, que se ejecutan una única vez al entrar al lazo.</p></li>
<li><p><strong>condición_mientras</strong> es una expresión lógica, que se comprueba al principio de cada iteración. Mientras resulte verdadera, se continúa ejecutando el cuerpo.</p></li>
<li><p><strong>incremento</strong> es una o más sentencias, separadas por comas, que se realizan al final de cada ejecución del cuerpo de la iteración.</p></li>
</ul>
<p>La estructura for es equivalente al siguiente lazo while:</p>
<pre><code>inicialización;
while(condición_mientras) {
    sentencia;
    incremento;
}</code></pre>
<p>Aunque el uso más común de las <strong>sentencias de incremento</strong> es hacer avanzar o retroceder un contador de la cantidad de iteraciones, nada impide que se utilice esa sección para cualquier otro fin.</p>
<p>Cualesquiera de las secciones inicialización, condición_mientras o incremento pueden estar vacías. En particular, la sentencia:</p>
<pre><code>for( ; ; )</code></pre>
<p>es un lazo infinito.</p>
<ul>
<li><p>El siguiente lazo acumula los números 1 a 10 sobre la variable <code>a</code>:</p>
<pre><code>for(i=1; i&lt;=10; i++)
    a += i;</code></pre></li>
<li><p>Si se quiere asegurar que la variable <code>a</code> tiene un valor inicial cero, se puede escribir:</p>
<pre><code>for(i=1, a=0; i&lt;=10; i++)
	a += i;</code></pre></li>
<li><p>Aprovechando la propiedad del corto circuito en las expresiones lógicas, se puede introducir el cuerpo del lazo <code>for</code> en la comprobación (aunque no es recomendable si complica la lectura):</p>
<pre><code>for(i=1, a=0; i&lt;=10 &amp;&amp; a+=i; i++);</code></pre>
<p>Nótese que el cuerpo de este último for es la sentencia nula. A propósito: es un error muy común utilizar un signo “;” de más, así:</p>
<pre><code>for(i=1; i&lt;=10; i++);
    a += i;</code></pre>
<p>Esta estructura llevará la variable <code>i</code> desde 1 hasta 10 sin ejecutar ningún otro trabajo (lo que se repite es la sentencia nula) y después incrementará <code>a</code>, una sola vez, en el valor de la última iteración de <code>i</code>.</p></li>
<li><p>Una clásica estructura de control para un proceso consumidor de objetos:</p>
<pre><code>a=leercaracter();
while( a != &#39;\033&#39; ) {
    procesar(a);
    a = leercaracter();
}</code></pre></li>
<li><p>La propiedad de que toda asignación en C tiene un valor como expresión (el valor asignado) permite reescribir la estructura de control anterior como:</p>
<pre><code>while( (a=leercaracter()) != &#39;\033&#39; )
        procesar(a);</code></pre></li>
<li><p>Las expresiones conectadas por los operadores lógicos se evalúan de izquierda a derecha, y la evaluación se detiene apenas alcanza a determinarse el valor de verdad de la expresión (propiedad ). Así, si suponemos que procesar() siempre devuelve un valor distinto de cero, la sentencia siguiente equivale a los lazos anteriores.</p>
<pre><code>while((a=leercaracter()) != &#39;\033&#39; &amp;&amp; procesar(a));</code></pre></li>
<li><p>Otra versión, utilizando la estructura do-while, podría ser:</p>
<pre><code>do {
    if((a=leercaracter()) != &#39;\033&#39;)
        procesar(a);
} while(a != &#39;\033&#39;);</code></pre></li>
<li><p>Si utilizamos <code>for</code>, que es esencialmente un <em>while</em>:</p>
<pre><code>for( ; (a=leercaracter()) != &#39;\033&#39;; ) procesar(a);</code></pre>
<p>Aquí dejamos vacías las secciones de inicialización y de incremento.</p></li>
<li><p>También, pero algo menos claro:</p>
<pre><code>for( ; (a=leercaracter()) != &#39;\033&#39;; procesar(a) );</code></pre></li>
</ul>
<h2 id="estructura-de-selección">Estructura de selección</h2>
<p>La estructura de selección (<em>switch</em>) es una estructura alternativa múltiple. Dadas varias alternativas, la estructura de selección desvía el control al segmento de programa correspondiente. La sintaxis de la estructura <code>switch</code> es como sigue:</p>
<pre><code>switch(expresión_entera) {
    case expresión_constante1:
        sentencias;
        break;
    case expresión_constante2:
        sentencias;
        break;
    default:
        sentencias;
}</code></pre>
<p>Al entrar al switch, se comprueba el valor de la expresión entera, y si coincide con alguna de las constantes propuestas en los rótulos <code>case</code>, se deriva el control directamente allí. La sección <code>default</code> no es obligatoria. Sirve para derivar allí todos los casos que no se contemplen explícitamente. En las expresiones_constantes no se permite la aparición de variables ni funciones. Un ejemplo válido con expresiones_constantes sería:</p>
<pre><code>#define ARRIBA 10
#define ABAJO   8

switch(valor(tecla)) {
    case 127+ARRIBA:
        arriba();
        break;
    case 127+ABAJO:
        abajo();
        break;
}</code></pre>
<p>La sentencia <code>break</code> es necesaria aquí porque, al contrario que en Pascal, el control no se detiene al llegar al siguiente rótulo.</p>
<p>Esta estructura recibe como entrada las variables <code>m</code> y <code>a</code> (mes y año) y da como salida <code>d</code> (la cantidad de días del mes).</p>
<pre><code>switch(m) {
    case 2:
        d=28 + bisiesto(a) ? 1 : 0;
        break;
    case 4:
    case 6:
    case 9:
    case 11:
        d= 30;
        break; 
	default:
        d= 31;
    }</code></pre>
<p>Si <code>m</code> vale 4, 6, 9, u 11, la variable <code>d</code> recibe el valor 30. Al no haber un <code>break</code> intermedio, el control cae hasta la asignación <code>d = 30</code>.</p>
<p>La estructura <code>switch</code> tiene algunas limitaciones con respecto a sus análogos en otros lenguajes. A saber, no se puede comparar la expresión de selección con expresiones no constantes, ni utilizar rangos (el concepto de rango no está definido en C).</p>
<h2 id="transferencia-incondicional">Transferencia incondicional</h2>
<p>Hay varias sentencias de transferencia incondicional de control en C. Algunas tienen aplicación exclusivamente como modificadoras del control dentro de estructuras, como <code>break</code> y <code>continue</code>.</p>
<h3 id="sentencia-continue">Sentencia continue</h3>
<p>Utilizada dentro de un lazo <code>while</code>, <code>do-while</code> o <code>for</code>, hace que el control salte directamente a la comprobación de la condición de iteración. Así:</p>
<pre><code>for(i=0; i&lt;100; i++) {
    if(no_procesar(i))
        continue;
    procesar(i);
}</code></pre>
<p>En este lazo, si la función <code>no_procesar()</code> devuelve valor distinto de cero, no se ejecuta el resto del lazo (la función <code>procesar()</code>, y otras, si las hubiera, hasta la llave final del lazo). Se comprueba la validez de la expresión <code>i&lt;100</code>, y si corresponde se inicia una nueva iteración.</p>
<h3 id="sentencia-break">Sentencia break</h3>
<p>La sentencia <code>break</code>, por el contrario, hace que el control abandone definitivamente el lazo:</p>
<pre><code>while(expresión) {
    if(ya_no_procesar())
        break;
    procesar();
}
seguir();</code></pre>
<p>Cuando la función <code>ya_no_procesar()</code> dé distinto de cero, el control saltará a la función <code>seguir()</code>, terminando la ejecución de la estructura repetitiva.</p>
<h3 id="sentencia-goto">Sentencia goto</h3>
<p>Un <strong>rótulo</strong> es un nombre, seguido del carácter “:”, que se asocia a un segmento de un programa. La sentencia <code>goto</code> transfiere el control a la instrucción siguiente a un rótulo. Aunque no promueve la programación estructurada, y se sabe que su abuso es perjudicial, <code>goto</code> es útil para resolver algunas situaciones. Por ejemplo: anidamiento de lazos con salida forzada.</p>
<pre><code>for(i=0; i&lt;10; i++) {
    for(j=0; j&lt;50; j++) {
        if(ya_no_procesar(i,j))
            goto final;
        procesar(i,j);
    }
}
final: imprimir(i,j);</code></pre>
<p>Aquí se podría implementar una estrategia estructurada, en base a <code>break</code>, pero el control quedaría retenido en el lazo exterior y se requeriría más lógica para resolver este problema. Se complicaría la legibilidad del programa innecesariamente.</p>
<p>Los rótulos a los que puede dirigirse un <code>goto</code> tienen un espacio de nombres propio. Es decir, no hay peligro de conflicto entre un rótulo y una variable del mismo nombre. Además, el ámbito de un rótulo es local a la función (una sentencia <code>goto</code> sólo puede acceder a los rótulos dentro del texto de la función donde aparece).</p>
<h3 id="sentencia-return">Sentencia return</h3>
<p>Permite devolver un valor a la función llamadora. Implica una transferencia de control incondicional hasta el punto de llamada de la función que se esté ejecutando.</p>
<h2 id="observaciones-2">Observaciones</h2>
<p>Hay errores de programación típicos, relacionados con estructuras de control en C, que vale la pena enumerar:</p>
<ul>
<li><p>Terminar el encabezado de las estructuras de control con un punto y coma extra.</p></li>
<li><p>Olvidar la sentencia <code>break</code> separando casos de un <code>switch</code>.</p></li>
<li><p>Confundir el significado de un lazo <code>do-while</code> tomando la condición de mientras como si fuera una condición de hasta (por analogía con <code>repeat</code> de Pascal).</p></li>
</ul>
<p>[tc-control-preg] ¿Qué resultado final tiene la variable ?</p>
<pre><code>a = 1; 
if(a == 1)
	a = 2;</code></pre>
<p>1. 2. Ninguna de las anteriores.</p>
<p>¿Qué resultado final tiene la variable ?</p>
<pre><code>a = 1; 
if(3)
	a = 2;</code></pre>
<p>1. 2. Ninguna de las anteriores.</p>
<p>¿Qué resultado final tiene la variable ?</p>
<pre><code>a = 1;
if(b == 2)
	a = 2;</code></pre>
<p>1. 2. Depende del valor de b. Ninguna de las anteriores.</p>
<p>¿Qué resultado final tiene la variable ?</p>
<pre><code>a = 1;
if(b == 2);
	a = 2;</code></pre>
<p>1. 2. Depende del valor de b. Ninguna de las anteriores.</p>
<p>¿Qué resultado final tiene la variable ?</p>
<pre><code>a = 1;
if(b = 0)
    a=2;</code></pre>
<p>1. 2. Depende del valor de b. Ninguna de las anteriores.</p>
<p>¿Qué resultado final tiene la variable ?</p>
<pre><code>b = 3;
if(b == 1)
	a=2;
else 
	if(b == 2)
	 	a=3; 
	else 
		a=4;</code></pre>
<p>2. 3. 4. No está definido.</p>
<p>¿Qué resultado final tiene la variable si inicialmente a, c y d valen 1?</p>
<pre><code>switch(c) {
	case 1: a = a+d;  
		    break;
	case 2: a = a-d;
			break;
}</code></pre>
<p>1. 2. 3.</p>
<p>¿Qué resultado final tiene la variable si inicialmente a, c y d valen 1?</p>
<pre><code>switch(c) {
	case 1: a = a+d;  
	case 2: a = a-d;
}</code></pre>
<p>1. 2. 3.</p>
<p>¿Qué resultado final tiene la variable si inicialmente b, c y d valen 1?</p>
<pre><code>switch(c) {
	case 1: b = b+d;
	case 2: b = b-d;
	default: b = 0;
}</code></pre>
<p>0 1 2 3</p>
<p>¿Qué resultado final tiene la variable si inicialmente b, c y d valen 1?</p>
<pre><code>switch(c) {
	case 1: b = b+d;
			break;
	case 2: b = b-d;
			break;
	default: b = 0;
}</code></pre>
<p>0 1 2 3</p>
<p>¿Qué resultado final tiene la variable si inicialmente b, c y d valen 3?</p>
<pre><code>switch(c) {
	case 1: b = b+d;
			break;
	case 2: b = b-d;
			break;
	default: b = 0;
}</code></pre>
<p>0 1 2 3</p>
<p>¿Qué resultado final tiene la variable ?</p>
<pre><code>c = 1;
for(i=0; i&lt;5; i++);
	for(j=0; j&lt;2; j++)    
		c++;</code></pre>
<p>1 2 3 6 13</p>
<p>¿Cuántas X imprimen estas líneas?</p>
<pre><code>c = 3; 
do {
	printf(&quot;X&quot;);
} while(c--);</code></pre>
<p>1 2 3 4</p>
<p>¿Cuántas X imprimen estas líneas?</p>
<pre><code>c = 3; 
do { 
	printf(&quot;X&quot;); 
} while(--c);</code></pre>
<p>1 2 3 4</p>
<p>¿Cuántas X imprimen estas líneas?</p>
<pre><code>c = 3; 
while(c--) 
	printf(&quot;X&quot;); </code></pre>
<p>1 2 3 4</p>
<p>¿Cuántas X imprimen estas líneas?</p>
<pre><code>c = 3; 
while(--c) 
	printf(&quot;X&quot;);</code></pre>
<p>1 2 3 4</p>
<p>¿Cuántas X imprimen estas líneas?</p>
<pre><code>c = 3; 
while(--c); 
	printf(&quot;X&quot;);</code></pre>
<p>1 2 3 4</p>
<h2 id="tc-control-ej">Ejercicios</h2>
<ol>
<li><p>Reescribir estas sentencias usando while en vez de for:</p>
<ol>
<li><pre><code>for(i=0; i&lt;=10; i++)
    a = i;</code></pre></li>
<li><pre><code>for( ; j&lt;100; j+=2) {
    a = j;
    b = j * 2;
}</code></pre></li>
<li><pre><code>for( ; ; )
    a++;</code></pre></li>
</ol></li>
<li><p>Si la función <code>quedanDatos()</code> devuelve el valor lógico que sugiere su nombre, ¿cuál es la estructura preferible?</p>
<ol>
<li><pre><code>while(quedanDatos()) {
    procesar();
}</code></pre></li>
<li><pre><code>do {
    procesar();
} while(quedanDatos());</code></pre></li>
</ol></li>
<li><p>¿Cuál es el error de programación en estos ejemplos?</p>
<ol>
<li><pre><code>for(i = 0; i &lt; 10; i++);
    a = i - 50L;</code></pre></li>
<li><pre><code>while(i &lt; 100) {
    procesar(i);
    a = a + i;
}</code></pre></li>
</ol></li>
<li><p>¿Cuál es el valor de x a la salida de los lazos siguientes?</p>
<ol>
<li><pre><code>for(x = 0; x&lt;100; x++);</code></pre></li>
<li><pre><code>for(x = 32; x&lt;55; x += 3);</code></pre></li>
<li><pre><code>for(x =  10;x&gt;0; x--);</code></pre></li>
</ol></li>
<li><p>¿Cuántas X escriben estas líneas?</p>
<pre><code>for (x = 0; x &lt; 10; x++)
    for (y = 5;  y &gt;  0; y--)
        escribir(&quot;X&quot;);</code></pre></li>
<li><p>Escribir sentencias que impriman la tabla de multiplicar para un entero dado.</p></li>
<li><p>Imprimir la tabla de los diez primeros números primos (sólo divisibles por sí mismos y por la unidad).</p></li>
<li><p>Escribir las sentencias para calcular el factorial de un entero.</p></li>
</ol>
<h1 id="sec:tc-funciones">Funciones</h1>
<p>Una unidad de traducción en C contiene un conjunto de funciones. Si entre ellas existe una con el nombre especial <strong>main</strong>, entonces esa unidad de traducción puede dar origen a un programa ejecutable, y el comienzo de la función main será el punto de entrada al programa.</p>
<h2 id="declaración-y-definición-de-funciones">Declaración y definición de funciones</h2>
<p>Los tipos de datos de los parámetros recibidos y del resultado que devuelve la función quedan especificados en su cabecera. El valor devuelto se expresa mediante <strong>return</strong>:</p>
<p>Una función que recibe un int y un long, y devuelve un int.</p>
<pre><code>int fun1(int alfa, long beta)
{
	...
}	</code></pre>
<p>Una función que recibe dos doubles y devuelve un double.</p>
<pre><code>double sumar(double x, double y)
{
	...
	return x+y;
}	</code></pre>
<p>El caso especial de una función que no desea devolver ningún valor se especifica con el modificador <strong>void</strong>, y en tal caso un return, si lo hay, no debe tener argumento. Los paréntesis son necesarios aunque la función no lleve parámetros, y en ese caso es recomendable indicarlo con un parámetro void:</p>
<p>Una función que recibe un int, y no devuelve ningún valor.</p>
<pre><code>void procesar(int k)
{
	...
}	</code></pre>
<p>Una función que devuelve un int, y no recibe argumentos.</p>
<pre><code>int hora(void)
{
	...
}	</code></pre>
<p>Una función puede ser declarada de un tipo cualquiera y sin embargo no contar con una instrucción return. En ese caso su valor de retorno queda indeterminado. Además, la función que llama a otra puede utilizar o ignorar el valor devuelto, a voluntad, sin provocar errores.</p>
<p>En el caso siguiente se recoge basura en la variable <code>a</code>, ya que <code>fun2</code> no devuelve ningún valor pese a ser declarada como de tipo entero.</p>
<pre><code>int fun2(int x)
{
    ...
    return;
}

    ...
    a=fun2(1);</code></pre>
<p>El cuerpo de la función, y en general cualquier cuerpo de instrucciones entre llaves, es considerado un bloque. Las <strong>variables locales</strong> son aquellas declaradas dentro del cuerpo de una función, y su declaración debe aparecer antes de cualquier sentencia ejecutable. Es legal ubicar la declaración de variables como la primera sección dentro de cualquier bloque, aun cuando ya se hayan incluido sentencias ejecutables. Sin embargo, no es legal declarar funciones dentro de funciones.</p>
<p>La variable <code>v</code> declarada dentro del bloque interno opaca a la declarada al principio de la función.</p>
<pre><code>int fun3()
{
    int j,k,v;

     for(i=0; i&lt;10; i++) {
        double v;
        ...
}</code></pre>
<h2 id="prototipos-de-funciones">Prototipos de funciones</h2>
<p>En general, como ocurre con las variables, el uso de una función debe estar precedido por su declaración. Sin embargo, el compilador trata el caso de las funciones con un poco más de flexibilidad. Un uso de variable sin declaración es ilegal, mientras que un uso de función sin definición obliga al compilador a suponer ciertos hechos, pero permite proseguir la compilación.</p>
<p>La suposición que hará el compilador, en la primera instancia en que se utilice una función y en ausencia de una definición previa, es que el resultado y los parámetros de la función son del tipo más que pueda representarlos. Esto vale tanto para las funciones escritas por el usuario como para las mismas funciones de la Biblioteca Standard.</p>
<p>Así, si se intenta calcular <span class="math inline"><em>e</em><sup>5</sup></span>:</p>
<pre><code>main()
{
    double a;
    a=exp(5);
}</code></pre>
<p>Nada permite al compilador suponer que la función exp() debe devolver algo distinto de un entero (el hecho de que se esté asignando su valor a un double no es informativo, dada la conversión automática de expresiones que hace el C). Además, el argumento 5 puede tomarse a primera vista como int, pudiendo ser que en la definición real de la función se haya especificado como double, o alguna otra elección de tipo.</p>
<p>En cualquier caso, esto es problemático, porque la comunicación de parámetros entre funciones, normalmente, se hace mediante el stack del programa, donde los objetos se almacenan como sucesiones de bytes. La función llamada intentará recuperar del stack los bytes necesarios para los objetos que necesita, mientras que la función que llama le ha dejado en el mismo stack menos información de la esperada. El programa compilará correctamente pero los datos pasados a y desde la función serán truncamientos de los valores deseados.</p>
<h2 id="redeclaración-de-funciones">Redeclaración de funciones</h2>
<p>Otro problema, relacionado con el anterior, es el que ocurre si permitimos que el compilador construya esa declaración provisoria y luego, en la misma unidad de traducción, damos la definición de la función, y ésta no concuerda con la imaginada por el compilador. La compilación abortará con error de . La forma de advertir al compilador de los tipos correctos antes del uso de la función es, o bien, definirla (proporcionando su fuente), o incluir su prototipo:</p>
<pre><code>double exp(double x); /* prototipo de exp() */
main()
{
    double a;
    a=exp(5);
}</code></pre>
<p>En el caso particular de las funciones de Biblioteca Standard, cada grupo de funciones cuenta con su header conteniendo estas declaraciones, que podemos utilizar para ahorrarnos tipeo. Para las matemáticas, utilizamos el header math.h:</p>
<pre><code>#include &lt;math.h&gt;
main()
{
    double a;
    a=exp(5);
}</code></pre>
<p>Un problema más serio que el de la redeclaración de funciones es cuando una función es compilada en una unidad de traducción separada A y luego se la utiliza, desde una función en otra unidad de traducción B, pero con una declaración incorrecta, ya sea porque se ha suministrado un prototipo erróneo o porque no se ha suministrado ningún prototipo explícito. y el implícito, que puede inferir el compilador, no es el correcto. En este caso la compilación y la linkedición tendrán lugar sin errores, pero la conducta al momento de ejecución depende de la diferencia entre ambos prototipos, el real y el inferido.</p>
<h2 id="recursividad">Recursividad</h2>
<p>Las funciones en C pueden ser recursivas, es decir, pueden invocarse a sí mismas directa o indirectamente. Siguiendo el principio de que las estructuras de programación deben replicar la estructura de los datos, la recursividad de funciones es una manera ideal de tratar las estructuras de datos recursivas, como árboles, listas, etc.</p>
<pre><code>int factorial(int x)
{
    if(x==0)
        return 1;
    return x * factorial(x-1);
}</code></pre>
<p>[sec:tc-funciones-preg] ¿De qué tipo es la función siguiente?</p>
<pre><code>float z(int p, short q) {
	double g=1;
	float h=2;
	return g;
}</code></pre>
<p>¿Qué ocurre con el parámetro en el cuerpo de la función siguiente?</p>
<pre><code>int fun(int a) {
	a = 2 * b;
	return b;
}</code></pre>
<p>El código no compila porque falta declarar el parámetro b. Se devuelve el valor de b que es basura por ser variable local. Se devuelve el valor b siempre que b sea una global declarada más arriba.</p>
<p>¿Cuál sería el prototipo más plausible para la función si su uso legal es como el siguiente?</p>
<pre><code>float p, r; 
int s;
r = q(p,s) / 2;	</code></pre>
<p>¿Cuál sería el prototipo más plausible para la función si su uso legal es como el siguiente?</p>
<pre><code>double w;
w = t(5e1, 2L);</code></pre>
<p>Con el prototipo:</p>
<pre><code>void fun1(long x, double y, int g, char h);</code></pre>
<p>¿Cuál es el parámetro cuyo tipo <strong>no es</strong> correcto en la invocación de la función?</p>
<pre><code>fun1(500, 1.02e3, -12, 9);</code></pre>
<p>x y g h</p>
<p>Con el prototipo:</p>
<pre><code>void fun2(char a, unsigned b, int c, double d);</code></pre>
<p>¿Cuál es el parámetro cuyo tipo <strong>no es</strong> correcto en la invocación de la función?</p>
<pre><code>fun2(&#39;2&#39;, 100, 100, 100);</code></pre>
<p>a b c d</p>
<p>¿Con quién está relacionado el problema en estas líneas?</p>
<pre><code>void fun3(int e, unsigned short f, long int g, signed char h);
a = fun3(1, 1, 1, 1);</code></pre>
<p>Con e Con f Con g Con h Con a</p>
<h2 id="sec:tc-funciones-ej">Ejercicios</h2>
<ol>
<li><p>Escribir una función que reciba tres argumentos enteros y devuelva un entero, su suma.</p></li>
<li><p>Escribir una función que reciba dos argumentos enteros y devuelva un long, su producto.</p></li>
<li><p>Escribir una función que reciba dos argumentos enteros a y b, y utilice a las dos anteriores para calcular:</p>
<pre><code>(a * b + b * 5 + 2) * (a + b + 1)</code></pre></li>
<li><p>Escribir un programa que utilice la función anterior para realizar el cálculo con a=7 y b=3.</p></li>
<li><p>¿Qué está mal en estos ejemplos?</p>
<ol>
<li><pre><code>int f1(int x, int y);
{
    int z;
    z = x - y;
    return z;
}</code></pre></li>
<li><pre><code>void f2(int k)
{
    return k + 3;
}</code></pre></li>
<li><pre><code>int f3(long k)
{
    return (k &lt; 0) ? -1 : 1;
}
printf(&quot;%d\n&quot;,f3(8));</code></pre></li>
</ol></li>
<li><p>Escribir una función que reciba dos argumentos, uno de tipo int y el otro de tipo char. La función debe repetir la impresión del char tantas veces como lo diga el otro argumento. Escribir un programa para probar la función.</p></li>
</ol>
<h1 id="sec:tc-estructuradas">Variables estructuradas</h1>
<p>Como casi todos los lenguajes, el C provee varias maneras de estructurar, o combinar, variables simples en alguna forma de agregación. Las variables estructuradas permiten manejar un conjunto de datos como una sola entidad.</p>
<h2 id="arreglos">Arreglos</h2>
<p>La declaración</p>
<pre><code>tipo nombre[cant_elementos];</code></pre>
<p>define un bloque llamado de <strong>objetos consecutivos</strong> de tipo , lo que habitualmente recibe el nombre de <strong>vector, array o arreglo</strong>. Sus elementos se acceden <strong>indexando</strong> el bloque con expresiones enteras entre corchetes.</p>
<p>Declaraciones y uso de arreglos.</p>
<pre><code>int dias[12];</code></pre>
<pre><code>dias[0] = 31;
enero = dias[0];
febrero = dias[1];
a = dias[6 * b - 1];</code></pre>
<pre><code>double saldo[10];
for(i=0; i&lt;10; i++)
    saldo[i] = entradas[i] - salidas[i];</code></pre>
<h3 id="inicialización-de-arreglos">Inicialización de arreglos</h3>
<p>Al ser declarados, los arreglos pueden recibir una <strong>inicialización</strong>, que es una lista de valores del tipo correspondiente, indicados entre llaves. Esta inicialización puede ser completa o incompleta. Si se omite la dimensión del arreglo, el compilador la infiere por la cantidad de valores de inicialización.</p>
<p>Inicializaciones completas e incompletas.</p>
<pre><code>/* inicialización completa */
int dias[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };   </code></pre>
<pre><code>/* inicialización incompleta */
double saldo[10] = { 150.40, 170.20 };     </code></pre>
<pre><code>long altura[] = { 3600, 3400, 3200, 6950 };  /* se infiere &quot;long altura[4]&quot; */</code></pre>
<h3 id="errores-frecuentes-con-arreglos">Errores frecuentes con arreglos</h3>
<p>Los siguientes son errores de programación muy comunes al tratar con arreglos, y lamentablemente el lenguaje C no provee ayuda para prevenirlos:</p>
<ul>
<li><p><strong>Indexación fuera de límites</strong></p>
<p>La dimensión dada en la declaración del arreglo dice cuántos elementos tiene. Esto no quiere decir que exista un elemento del arreglo con ese índice (porque se numeran a partir de 0).</p>
<p>La última instrucción equivale a acceder a un elemento fuera de los límites del arreglo. Este programa, aunque erróneo, <strong>compilará correctamente</strong>.</p>
<pre><code>int tabla[5];

tabla [5] = 1;	/* ¡Error! el último elemento es tabla[4] */</code></pre></li>
<li><p><strong>Asignación de arreglos</strong></p>
<p>Es frecuente confundir las operaciones de inicialización y de asignación. La inicialización sólo es válida en el momento de la declaración: <strong>no es legal asignar un arreglo</strong>. La asignación debe forzosamente hacerse elemento por elemento.</p>
<p>Notar la diferencia sintáctica entre inicialización y asignación.</p>
<pre><code>/* Inicializacion */
int tabla[5] = { 1, 3, 2, 3, 4 }; 	/* correcto */

/* Asignacion */
int tabla[5];
tabla[] = { 1, 3, 2, 3, 4 }; 		/* incorrecto */</code></pre>
<p>La última sentencia no es compilable. Debe reemplazarse por:</p>
<pre><code>tabla[0] = 1;
tabla[1] = 3; ...etc</code></pre></li>
</ul>
<h2 id="arreglos-multidimensionales">Arreglos multidimensionales</h2>
<p>En C se pueden simular matrices y arreglos de más dimensiones creando <strong>arreglos cuyos elementos son arreglos</strong>. La declaración:</p>
<pre><code>int matriz[3][4];</code></pre>
<p>expresa un arreglo de tres posiciones cuyos elementos son arreglos de cuatro posiciones. Una declaración con inicialización podría escribirse así:</p>
<pre><code>int matriz[3][4] = {
    {1, 2, 5, 7},
    {3, 0, 0, 1},
    {2, 8, 5, 4}};</code></pre>
<p>y correspondería a una matriz de tres filas por cuatro columnas. La primera dimensión de un arreglo multidimensional puede ser inferida:</p>
<pre><code>int matriz[][4] = {
    {1, 2, 5, 7},
    {3, 0, 0, 1},
    {2, 8, 5, 4}};</code></pre>
<p>El recorrido de toda una matriz implica necesariamente un lazo doble, a dos variables:</p>
<pre><code>for(i=0; i&lt;3; i++)
    for(j=0; j&lt;4; j++)
      a[i][j] = i  + j;	</code></pre>
<h2 id="estructuras-y-uniones">Estructuras y uniones</h2>
<h3 id="estructuras">Estructuras</h3>
<p>Las <strong>estructuras</strong> de C permiten agrupar una cantidad de variables simples, de tipos, en general, diferentes. Las estructuras y uniones aportan la ventaja de que es posible manipular este conjunto de variables como un todo.</p>
<p>Es posible inicializar estructuras, asignar conjuntos de constantes a las estructuras, asignar estructuras entre sí, pasarlas como argumentos reales a funciones, y devolverlas como valor de salida de funciones. En particular, ésta viene a ser la única manera de que una función devuelva más de un dato.</p>
<p>Las declaraciones siguientes no definen variables, con espacio de almacenamiento, sino que simplemente enuncian un nuevo tipo que puede usarse en nuevas declaraciones de variables.</p>
<pre><code>struct persona {
    long DNI;
    char nombre[40];
    int edad;
};

struct cliente {
    int num_cliente;
    struct persona p;
    double saldo;
};	</code></pre>
<p>El nombre o <em>tag</em> dado a la estructura es el nombre del nuevo tipo. En las instrucciones siguientes se utilizan los tags definidos anteriormente y se acceden a los diferentes miembros de las estructuras.</p>
<pre><code>struct cliente c1, c2;

c1.num_cliente = 1001;
c1.p.DNI = 14233326;   /* acceso anidado */
c1.p.edad=40;

c2 = c1;               /* copia de estructuras */
struct persona p1 = {17698735, &quot;Juan Perez&quot;, 30};
c2.p = p1;	</code></pre>
<p>Una declaración con inicialización completa:</p>
<pre><code>struct cliente c3 = {
    1002,
    {17698735, &quot;Juan Perez&quot;, 30},
    150.25 };</code></pre>
<p>Es legal declarar una variable junto con la enunciación de su tipo, con o sin el tag asociado y con o sin inicialización.</p>
<pre><code>struct complejo { double real, imag; } c;
struct { double real, imag; } c;
struct complejo {
   double real, imag;
} c = { 20.5, -7.3 };</code></pre>
<p>Una función que recibe y devuelve estructuras:</p>
<pre><code>struct punto {
    int x, y;
};

struct punto puntomedio(struct punto p1, struct punto p2)
{
    struct punto z;
    z.x = (p1.x + p2.x) / 2;
    z.y = (p1.y + p2.y) / 2;
    return z;
}</code></pre>
<h3 id="uniones">Uniones</h3>
<p>En una estructura, el compilador calcula la dirección de inicio de cada uno de los miembros dentro de la estructura sumando los tamaños de los elementos de datos. Una <strong>unión</strong> es un caso especial de estructura donde todos los miembros en el mismo lugar de origen de la estructura.</p>
<pre><code>union intchar {
    int i;
    char a[sizeof(int)];
};</code></pre>
<p>Este ejemplo de unión contiene dos miembros: un entero y un arreglo de tantos caracteres como bytes contiene un en la arquitectura destino. Ambos miembros, por la propiedad fundamental de los , quedan en memoria. El resultado es que podemos asignar un campo por un nombre y acceder por el otro.</p>
<p>En este caso particular, podemos conocer qué valores recibe cada byte de los que forman un .</p>
<pre><code>union intchar k;
k.i = 30541;
b = k.a[2];</code></pre>
<h3 id="campos-de-bits">Campos de bits</h3>
<p>Se pueden definir estructuras donde los miembros son agrupaciones de bits. Esta construcción es especialmente útil en programación de sistemas donde se necesita la máxima compactación de las estructuras de datos. Cada miembro de un <strong>campo de bits</strong> es un que lleva explícitamente un indicando la cantidad de bits que contiene.</p>
<pre><code>struct disp {
    unsigned int encendido : 1;
    unsigned int
        online : 1,
        estado : 4;
};</code></pre>
<p>Imaginemos, en base a la declaración anterior, un dispositivo mapeado en memoria con el cual comunicarnos en base a un protocolo, también imaginario. Implementamos con un campo de bits un registro de control , que permite encenderlo o apagarlo, consultar su disponibilidad ( o no), y hacer una lectura de un valor de de cuatro bits (que entonces puede tomar valores entre 0 y 15). Todo el registro de comunicación cabe en un byte.</p>
<p>Podríamos encender nuestro dispositivo imaginario, esperar a que se ponga online, tomar el promedio de diez lecturas de estado y apagarlo, con las instrucciones siguientes. Como se ve, no hay diferencia sintáctica de acceso con las estructuras.</p>
<pre><code>struct disp {
    unsigned int encendido : 1;
    unsigned int
        online : 1,
        estado : 4;
};</code></pre>
<pre><code>struct disp d;
d.encendido = 1;
while(!d.online);
for(p=0, i=0; i&lt;10; i++)
    p += d.estado;
p /= 10;
d.encendido = 0;</code></pre>
<p>[sec:tc-estructuradas-preg] ¿Cuántos elementos tiene el arreglo ? 11 12 13</p>
<p>¿Cuál es la declaración correcta para un arreglo de nueve caracteres?</p>
<p>¿Cuántos elementos tiene el arreglo ? 3 11 12 13</p>
<p>¿Cuántos elementos tiene el arreglo ? 3 11 12 13</p>
<p>Con la declaración del arreglo que sigue, ¿cuál de las sentencias es incorrecta?<br />
</p>
<p>¿Cuál de estos segmentos de programa es incorrecto?</p>
<h2 id="sec:tc-estructuradas-ej">Ejercicios</h2>
<ol>
<li><p>Escribir una declaración con inicialización de un arreglo de diez elementos , todos inicialmente iguales a <span class="math inline">2.25</span>.</p></li>
<li><p>Escribir las sentencias para copiar un arreglo de cinco en otro.</p></li>
<li><p>Escribir las sentencias para obtener el producto escalar de dos vectores.</p></li>
<li><p>Escribir una función que devuelva la posición donde se halla el menor elemento de un arreglo de .</p></li>
<li><p>Dado un vector de diez elementos, escribir todos los promedios de cuatro elementos consecutivos.</p></li>
<li><p>Declarar una estructura punto conteniendo coordenadas x e y de tipo . Dar ejemplos de inicialización y de asignación.</p></li>
<li><p>Declarar una estructura <strong>segmento</strong> conteniendo dos estructuras <strong>punto</strong>. Dar ejemplos de inicialización y de asignación. Dar una función que calcule su longitud. Dar una función que reciba un segmento <span class="math inline"><em>S</em></span> y un punto <span class="math inline"><em>p</em></span>, y devuelva si <span class="math inline"><em>p</em> ∈ <em>S</em></span>.</p></li>
<li><p>¿Cuál es el error en estas sentencias de inicialización?</p>
<ol>
<li><pre><code>struct alfa {
	int a, b;
};
alfa = { 10, 25 };</code></pre></li>
<li><pre><code>struct alfa {
	int a, b;
};
alfa d = { 10, 25 };</code></pre></li>
<li><pre><code>union dato {
	char dato_a[4];
	long dato_n;
} xdato = { &quot;ABC&quot;, 1000 };</code></pre></li>
</ol></li>
</ol>
<h1 id="sec:tc-direcciones">Apuntadores y Direcciones</h1>
<p>El tema de esta unidad es el más complejo del lenguaje C y por este motivo se han separado los contenidos en dos partes (llamadas 10 y 10b).</p>
<p>La memoria del computador está organizada como un vector o arreglo unidimensional. Los índices en este arreglo son las direcciones de memoria. Este arreglo puede accederse indexando a cada byte individualmente, y en particular a cada estructura de datos del programa, mediante su dirección de comienzo.</p>
<p>Para manipular direcciones se utilizan en C variables especiales llamadas apuntadores o punteros, que son aquellas capaces de contener direcciones. En la declaración de un apuntador se especifica el tipo de los objetos de datos cuya dirección contendrá.</p>
<p>La notación:</p>
<pre><code>char *p;</code></pre>
<p>es la declaración de una variable puntero a carácter. El contenido de la variable <code>p</code> puede ser, en principio, cualquiera dentro del rango de direcciones de la máquina subyacente al programa. Una vez habiendo recibido un valor, se dice que la variable <code>p</code> apunta a algún objeto en memoria.</p>
<p>Esquemáticamente representamos la situación de una variable que contiene una dirección (y por lo tanto ) según el diagrama siguiente (mas_información). La posición 1 de la memoria aloja un puntero que actualmente apunta a la posición 5.</p>
<p>El tema de apuntadores (o punteros) y direcciones es crucial en la programación en C, y parece ser el origen más frecuente de errores. Programas con mala lógica de acceso a memoria pueden ser declarados válidos por el compilador: su compilación puede ser exitosa y sin embargo ser completamente erróneos en ejecución. Esta es una de las críticas más frecuentes al lenguaje C, aunque en rigor de verdad, el problema no es del lenguaje, sino del programador con una mala comprensión de las cuestiones del lenguaje relacionadas con memoria.</p>
<p>Es fundamental, para no cometer estos errores, comprender en profundidad los conceptos de direcciones y punteros, así como la sintaxis de las declaraciones de punteros, para asegurarnos de que escribimos lo que se pretende lograr.</p>
<h2 id="operadores-especiales-1">Operadores especiales</h2>
<p>Para manipular punteros se hacen necesarios dos operadores especiales:</p>
<table>
<tbody>
</tbody>
</table>
<ul>
<li><p>El operador <strong>dirección</strong> devuelve <strong>la dirección de un objeto</strong>. La construcción siguiente:</p>
<pre><code>p = &amp;a;</code></pre>
<p>puede leerse: .</p></li>
<li><p>El operador de <strong>indirección</strong>, o de <strong>dereferenciación</strong>, surte el efecto contrario: accede al <strong>objeto apuntado por</strong> una dirección. La construcción</p>
<pre><code>a = *p;</code></pre>
<p>puede leerse como .</p></li>
</ul>
<p>Para obtener el efecto lógicamente esperado, en las expresiones anteriores <code>p</code> deberá ser un <strong>puntero</strong>, capaz de recibir y entregar una dirección.</p>
<p>En general, si el contenido de la variable <code>p</code> es igual a la dirección de <code>a</code>, es decir, <code>&amp;a</code>, la expresión de dereferenciación <code>*p</code> puede aparecer en cualquier contexto en el que apareciera <code>a</code>. En particular, es legal asignar indirectamente a través de un apuntador.</p>
<p>Las instrucciones</p>
<pre><code>int a, *p;
p = &amp;a;
*p = 1;</code></pre>
<p>equivalen a</p>
<pre><code>a = 1;</code></pre>
<h2 id="aritmética-de-punteros">Aritmética de punteros</h2>
<p>Son operaciones legales asignar punteros entre sí, sumar algebraicamente un entero a un puntero y restar dos punteros. Las consecuencias de cada operación se esquematizan en las figuras siguientes.</p>
<h3 id="asignación-entre-punteros">Asignación entre punteros</h3>
<p>Luego de asignar un puntero a otro, ambos apuntan al mismo objeto. Cualquier modificación al objeto apuntado por uno se refleja al accederlo mediante el otro puntero.</p>
<h3 id="suma-de-enteros-a-punteros">Suma de enteros a punteros</h3>
<p>La suma algebraica de una dirección más un entero es nuevamente una dirección. El sentido de la operación es desplazar el punto de llegada del apuntador (hacia arriba o hacia abajo en memoria) en tantas unidades como diga el entero, con la particularidad de que el resultado final es dependiente del tamaño del objeto apuntado. Esto es en general lo que desea el programador al aplicar un incremento a un apuntador.</p>
<p>Es decir que sumar (o restar) una unidad a un puntero, lo incrementa (decrementa) en tantos bytes como mida el objeto al cual apunta. Por ejemplo, para punteros a carácter, la instrucción <code>p++</code> incrementa el valor del puntero en <span class="math inline">1</span>, que es el <code>sizeof()</code> de los <code>chars</code>; pero si <code>p</code> es un puntero a <code>long</code>, en una arquitectura donde los <code>longs</code> miden cuatro bytes, <code>p++</code> incrementa el valor de <code>p</code> en <span class="math inline">4</span> (y <code>p</code> queda apuntando en la memoria).</p>
<h3 id="resta-de-punteros">Resta de punteros</h3>
<p>El sentido de una resta de punteros (o, equivalentemente, de una diferencia de direcciones) es obtener el tamaño del área de memoria comprendida entre los objetos apuntados por ambos punteros. La resta tendrá sentido únicamente si se hace entre variables que apuntan a objetos del mismo tipo.</p>
<p>Nuevamente se aplica la lógica del punto anterior: el resultado obtenido quedará expresado en unidades del tamaño del objeto apuntado. Es decir, si una diferencia entre punteros a long da 3, debe entenderse el resultado como equivalente a 3 longs, y por lo tanto a 3*sizeof(long) bytes.</p>
<h2 id="punteros-y-arreglos">Punteros y arreglos</h2>
<p>Una consecuencia de que sea posible sumar enteros a punteros es que se puede simular el recorrido de un arreglo mediante el incremento sucesivo de un puntero. La operación de acceder a un elemento del arreglo es equivalente a obtener el objeto apuntado por el puntero. Las sentencias:</p>
<pre><code>int *p;
int a[10];
p = &amp;a[0];</code></pre>
<p>Habilitan al programador para acceder a cada elemento del arreglo a mediante aritmética sobre el puntero p. Como el nombre de un arreglo se evalúa a su dirección inicial, la última sentencia también puede escribirse simplemente así:</p>
<pre><code>p = a;</code></pre>
<p>Supongamos dadas las definiciones siguientes:</p>
<pre><code>int alfa[] = { 2, 4, 6, 7, 4, 2, 3, 1 };
int *p, *q;
int b;</code></pre>
<p>Con estas definiciones, veamos algunas manipulaciones de arreglos y punteros.</p>
<pre><code>p = alfa;        /* el nombre de un arreglo
                    equivale a su direccion    */</code></pre>
<pre><code>*p = 3;          /* equivalente a alfa[0] = 3  */
*(p+2) = 4;      /* equivalente a alfa[2] = 4  */
b = *p;          /* equiv. a b = alfa[0]       */
*(p+3) = *(p+6); /* sobreescribe el 7 con el 3 */</code></pre>
<pre><code>q = alfa + 2;    /* apunta al tercer elemento  */</code></pre>
<pre><code>printf(&quot;%d\n&quot;,*q);                /* imprime 4 */
printf (&quot;%d\n&quot;,q - p);            /* imprime 2 */</code></pre>
<pre><code>p += q;          /* ERROR - la suma de punteros
                              no esta definida */</code></pre>
<p>Los dos segmentos de código siguientes hacen exactamente la misma tarea pero de maneras diferentes.</p>
<h2 id="punteros-y-cadenas-de-texto">Punteros y cadenas de texto</h2>
<p>Un caso típico del uso de punteros ocurre cuando se necesita trabajar con <strong>cadenas de texto</strong>, a veces llamadas <strong>strings</strong>, o <strong>constantes string</strong>.</p>
<p>Como se vio en la sección [sec:constantesstring], las constantes string son todas aquellas secuencias de caracteres (eventualmente la secuencia vacía) en el texto del programa, que aparecen entre comillas. La representación interna de las constantes string durante la compilación, con el <strong>cero final</strong>, y con la referencia a la constante reemplazada por su dirección, se trasladará al programa compilado y aparecerá en la memoria, en la zona de datos estáticos, al momento de ejecución del programa.</p>
<p>Como la constante string es reemplazada por la dirección de su primer carácter, la asignación o inicialización de una constante string a un puntero es legal, y almacena en el puntero dicha dirección. En la inicialización de punteros, las constantes string son un caso especialmente frecuente.</p>
<p>Un puntero a carácter inicializado con una constante string.</p>
<pre><code>char *s = &quot;Lenguaje C&quot;;</code></pre>
<p>La inicialización de <code>s</code> y la asignación de <code>t</code> cargan a ambas variables con las direcciones del primer carácter, o direcciones iniciales, de las cadenas respectivas.</p>
<pre><code>char *s = &quot;Esta es una cadena&quot;;
char *t;
t = &quot;Esta es otra cadena&quot;;</code></pre>
<p>Representamos en el diagrama el carácter 0 final (que no es imprimible) con el símbolo . La expresión en C de este carácter es simplemente 0 (un entero) o <code>’’</code> (una constante carácter cuyo código ASCII es cero).</p>
<p>La función de Biblioteca Standard <code>printf()</code> permite imprimir una cadena con el especificador de conversión .</p>
<p>Las líneas siguientes;</p>
<pre><code>char *s = &quot;Cadena de prueba&quot;;
char *t;
t = s + 7;
printf(&quot;%s\n&quot;, s);
printf(&quot;%s\n&quot;, t);</code></pre>
<p>O bien, equivalentemente:</p>
<pre><code>char *s = &quot;Cadena de prueba&quot;;
printf(&quot;%s\n&quot;, s);
printf(&quot;%s\n&quot;, s + 7);</code></pre>
<p>imprimen:</p>
<pre><code>Cadena de prueba
de prueba</code></pre>
<p>Una función que recorre una cadena ASCIIZ buscando un carácter y devuelve la primera dirección donde se lo halló, o bien el puntero nulo (NULL).</p>
<pre><code>char *donde(char *p, char c)
{
    for( ; *p != 0; p++)
        if(*p == c)
             return p;
    return NULL;
}

main()
{
    char *cadena = &quot;Buscando exactamente esto&quot;;
    char *s;
    s = donde(cadena, &#39;e&#39;);
    if(s != NULL)
        printf(&quot;%s\n&quot;, s);
}</code></pre>
<p>El ejemplo de uso imprime:</p>
<pre><code>exactamente esto</code></pre>
<h2 id="pasaje-por-referencia">Pasaje por referencia</h2>
<p>En C, donde todo pasaje de parámetros a funciones se realiza <strong>por valor</strong>, los punteros brindan una manera de entregar a las funciones <strong>referencias a objetos</strong>.</p>
<p>Modificación de un objeto externo a una función. La función <code>f2()</code> debe poner a cero una variable entera que es externa a ella, por lo cual el argumento formal <code>h</code> debe ser la dirección de un entero.</p>
<pre><code>void f2(int *h)
{
    *h = 0;
}

int f1()
{
    int j,k;
    int *p;

    p = &amp;j;
    f2(p);		/* le pasamos una direccion */
    f2(&amp;k);		/* y tambien aqui           */
}</code></pre>
<p>Uso incorrecto de argumentos pasados por valor.</p>
<pre><code>void swap(int x, int y) /* incorrecta */
{
    int temp;
    temp = x;
    x = y;
    y= temp;
}</code></pre>
<p>La función <code>swap()</code>, que podría ser usada por un algoritmo de ordenamiento para intercambiar los valores de dos variables, está <strong>incorrectamente escrita</strong>, ya que los valores que intercambia son los de sus argumentos, que vienen a estar al nivel de variables locales. El uso de la función swap() no tendrá efecto en el exterior de la misma. La versión correcta debe escribirse con pasaje por referencia:</p>
<pre><code>void swap(int *x, int *y) /* correcta */
{
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}</code></pre>
<p>La invocación de <code>swap()</code> debe hacerse con las direcciones de los objetos a intercambiar:</p>
<pre><code>int a, b;
swap(&amp;a, &amp;b);</code></pre>
<h2 id="punteros-y-argumentos-de-funciones">Punteros y argumentos de funciones</h2>
<p>En las funciones que reciben direcciones, los argumentos formales pueden tener cualquiera de dos notaciones: como punteros, o como arreglos. No importa qué objeto sea exactamente el argumento real (arreglo o puntero): en ambos casos, la función únicamente <strong>recibe una dirección</strong> y no sabe, ni le importa, cuál es la naturaleza real del objeto exterior a ella.</p>
<p>La función que busca un carácter en una cadena, vista más arriba, puede escribirse correctamente así, cambiando el tipo del argumento formal. El uso es exactamente el mismo que antes, sin cambios en la función que llama.</p>
<pre><code>char *donde(char p[], char c)
{
    int i;
    for(i=0 ; p[i] != 0; i++)
        if(p[i] == c)
             return p+i;
    return NULL;
}</code></pre>
<p>Nótese que dentro del cuerpo de la función podemos seguir utilizando la notación de punteros si lo deseamos, aun con la declaración del argumento formal como arreglo.</p>
<pre><code>char *donde(char p[], char c) /* el argumento p es un arreglo */
{
    for( ; *p != 0; p++)      /* pero se le puede aplicar el  */
        if(*p == c)			  /* operador de dereferenciacion */
             return p;
    return NULL;
}</code></pre>
<p>Del mismo modo, si quisiéramos, podríamos representar los argumentos como punteros y manipular los datos con indexación. Todo esto se debe, por un lado, a que las notaciones <code>*p</code> y <code>p[]</code>, para argumentos formales, expresan únicamente que el argumento es una dirección; y por otro lado, a la equivalencia entre las formas de acceso mediante apuntadores y mediante índices de arreglos.</p>
<p>¡Esto no quiere decir que punteros y arreglos sean lo mismo! Véanse las observaciones en la próxima unidad.</p>
<h2 id="sec:tc-direcciones-ej">Ejercicios</h2>
<ol>
<li><p>Dado el programa siguiente, ¿a dónde apunta <code>k1</code>?</p>
<pre><code>main()
{
    int k;
    int *k1;
}</code></pre></li>
<li><p>Dado el programa siguiente, ¿a dónde apunta <code>m1</code>?</p>
<pre><code>int *m1;
main()
{
    ...
}	</code></pre></li>
<li><p>¿Cuánto espacio de almacenamiento ocupa un arreglo de diez enteros? ¿Cuánto espacio de almacenamiento ocupa un puntero a entero?</p></li>
<li><p>Declarar variables <code>long</code> llamadas a, b y c, y punteros a <code>long</code> llamados p, q y r; y dar las sentencias en C para realizar las operaciones siguientes. Para cada caso, esquematizar el estado final de la memoria.</p>
<ol>
<li><p>Cargar p con la dirección de a. Si ahora escribimos <code>*p = 1000</code>, ¿qué ocurre?</p></li>
<li><p>Cargar r con el contenido de p. Si ahora escribimos <code>*r = 1000</code>, ¿qué ocurre?</p></li>
<li><p>Cargar q con la dirección de b, y usar q para almacenar una constante <code>4L</code> en el espacio de b.</p></li>
<li><p>Cargar en c la suma de a y b, pero sin escribir la expresión <span class="math inline"><em>a</em> + <em>b</em></span>.</p></li>
<li><p>Almacenar en c la suma de a y b pero haciendo todos los accesos a las variables en forma indirecta.</p></li>
</ol></li>
<li><p>Compilar y ejecutar:</p>
<ol>
<li><pre><code>main()
{
    char *a = &quot;Ejemplo&quot;;
    printf(&quot;%s\n&quot;,a);
}</code></pre></li>
<li><pre><code>main()
{
    char *a;
    printf(&quot;%s\n&quot;,a);
}</code></pre></li>
<li><pre><code>main()
{
    char *a = &quot;Ejemplo&quot;;
    char *p;
    p = a;
    printf(&quot;%s\n&quot;, p);
}</code></pre></li>
</ol></li>
<li><p>¿Qué imprimirán estas sentencias?</p>
<ol>
<li><p><code>char *s = ABCDEFG;</code></p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ol></li>
<li><p>¿Son correctas estas sentencias? Bosqueje un diagrama del estado final de la memoria para aquellas que lo sean.</p>
<ol>
<li><p><code>char *a = Uno;</code></p></li>
<li><p><code>char *a, b; a = Uno; b = Dos;</code></p></li>
<li><p><code>char *a,*b ; a = Uno; b = a;</code></p></li>
<li><p><code>char *a,*b ; a = Uno; b = *a;</code></p></li>
<li><p><code>char *a,*b ; a = Uno; *b = a;</code></p></li>
<li><p><code>char *a = Dos; *a = ’T’;</code></p></li>
<li><p><code>char *a = Dos; a = T;</code></p></li>
<li><p><code>char *a = Dos; *(a + 1) = ’i’; *(a + 2) = ’a’;</code></p></li>
<li><p><code>char *a, *b ; b = a;</code></p></li>
</ol></li>
<li><p>Escribir funciones para:</p>
<ol>
<li><p>Calcular la longitud de una cadena.</p></li>
<li><p>Dado un carácter determinado y una cadena, devolver la primera posición de la cadena en la que se lo encuentre, o bien <span class="math inline">−1</span> si no se halla.</p></li>
<li><p>Buscar una subcadena en otra, devolviendo un puntero a la posición donde se la halle.</p></li>
</ol></li>
<li><p>Escribir una función para reemplazar en una cadena todas las ocurrencias de un carácter dado por otro, suponiendo:</p>
<ol>
<li><p>Que no interesa conservar la cadena original, sino que se reemplazarán los caracteres sobre la misma cadena.</p></li>
<li><p>Que se pretende obtener una segunda copia, modificada, de la cadena original, sin destruirla.</p></li>
</ol></li>
<li><p>Escribir funciones para:</p>
<ol>
<li><p>Rellenar una cadena con un carácter dado, hasta que se encuentre el <span class="math inline">0</span> final, o hasta alcanzar <span class="math inline"><em>n</em></span> iteraciones.</p></li>
<li><p>Pasar una cadena a mayúsculas o minúsculas.</p></li>
</ol></li>
<li><p>Reescriba dos de las funciones escritas en 8 y dos de las escritas en 10 usando la notación opuesta (cambiando punteros por arreglos).</p></li>
</ol>
<h2 id="sec:tc-punteros">Errores más frecuentes</h2>
<h3 id="punteros-sin-inicializar">Punteros sin inicializar</h3>
<p>El utilizar un puntero sin inicializar parece estar entre las primeras causas de errores en C.</p>
<p>Si bien sintácticamente correctas, las líneas del ejemplo presentan un problema muy común en C. Declaran un puntero a entero, <code>p</code>, y almacenan un valor entero en la dirección apuntada por el mismo.</p>
<pre><code>/* Incorrecto */
   int *p;
   *p = 8;</code></pre>
<p>Como <code>p</code> es un puntero, su contenido será interpretado como una dirección de memoria. El problema es que el contenido de <code>p</code> es <strong>impredecible</strong>:</p>
<ul>
<li><p>Si la variable <code>p</code> es local, su clase de almacenamiento es <strong>auto</strong> y por lo tanto contiene <strong>basura</strong>, salvo inicialización explícita.</p></li>
<li><p>Si <code>p</code> es externa, <strong>será inicializada a 0</strong>.</p></li>
</ul>
<p>En el primer caso, esa dirección es aleatoria. En el segundo caso, será <code>cero</code>, que en la mayoría de los sistemas operativos conocidos es una dirección <strong>inaccesible</strong> para los procesos no privilegiados.</p>
<p>En cualquier caso, el programa compilará pero se encontrará con problemas de ejecución. Lo que falta es hacer que <code>p</code> apunte a alguna zona válida.</p>
<p>Direcciones válidas, que pueden ser manipuladas mediante punteros, son las de los objetos conocidos por el programa: <strong>variables, estructuras, arreglos, funciones, bloques de memoria asignados dinámicamente</strong>, son todos objetos cuya dirección ha sido <strong>obtenida legítimamente</strong>, ya sea al momento de carga o al momento de ejecución.</p>
<p>La solución al problema de los punteros sin inicializar es asegurarse, <strong>siempre</strong>, de que los punteros apuntan a <strong>lugares válidos del programa</strong>, asignándoles <strong>direcciones de objetos conocidos</strong>.</p>
<pre><code>/* Correcto */
	int a;
	int *p;
	p = &amp;a;
	*p = 8;	</code></pre>
<h3 id="confundir-punteros-con-arreglos">Confundir punteros con arreglos</h3>
<p>Es imprescindible comprender rigurosamente la diferencia entre arreglos y punteros. Aunque son intercambiables en algunos contextos, suponer que son lo mismo lleva a graves errores. Es frecuente confundirlos, y esta confusión es explicable a partir de algunos hechos que se enumeran a continuación. No hay que dejarse engañar por ellos.</p>
<ol>
<li><p><strong>Ambos se evalúan a direcciones.</strong></p>
<p>El nombre de un arreglo equivale a una dirección, y usar un puntero equivale a usar la dirección que contiene. Es decir, tienen usos similares.</p>
<ol>
<li><pre><code>char formato[] = &quot;%d %d\n&quot;;
printf(formato, 5, -1);</code></pre></li>
<li><pre><code>char *formato = &quot;%d %d\n&quot;;
printf(formato, 5, -1);</code></pre>
<p>Aquí usamos como equivalentes a un arreglo y a un puntero, porque de cualquiera de las dos maneras estamos expresando una dirección en la invocación a <code>printf()</code>.</p></li>
</ol></li>
<li><p><strong>Como argumentos formales, son equivalentes.</strong></p>
<p>En una función, un argumento formal que sea una dirección puede ser declarado como puntero o como arreglo, intercambiablemente. Convirtamos los ejemplos de más arriba a funciones:</p>
<ol>
<li><pre><code>int fun(char *s, int x, int y)
{
       printf(s, x, y);
}</code></pre></li>
<li><pre><code>int fun(char s[], int x, int y)
{
        printf(s, x, y);
}</code></pre></li>
</ol>
<p>Ambas formas son válidas, porque lo único que estamos expresando es que un argumento es una dirección; y, como se ha dicho, tanto punteros como nombres de arreglos los representan. Además, cualquiera de las funciones escritas puede usarse en cualquiera de las dos maneras siguientes, pasando punteros o arreglos en la llamada:</p>
<ol>
<li><pre><code>char formato[] = &quot;%d %d\n&quot;;
   fun(formato, 5, -1);</code></pre></li>
<li><pre><code>char *formato = &quot;%d %d\n&quot;;
   fun(formato, 5, -1);</code></pre></li>
</ol></li>
<li><p><strong>Comparten operadores.</strong></p>
<p>Se pueden aplicar los mismos operadores de acceso a ambos; a saber, se puede dereferenciar un arreglo (igual que un puntero) para acceder a un elemento y se puede indexar un puntero (como un arreglo) para acceder a una posición dentro del espacio al que apunta.</p>
<ol>
<li><pre><code>char cadena[] = &quot;abcdefghijkl&quot;;
   char c;
   c = *(cadena + 4); /* c = &#39;e&#39; */</code></pre></li>
<li><pre><code>char *cadena = &quot;abcdefghijkl&quot;;
   char c;
   c = cadena[4];     /* c = &#39;e&#39; */</code></pre></li>
</ol></li>
</ol>
<p>En muchas formas, entonces, punteros y arreglos pueden ser intercambiados porque son dos maneras de acceder a direcciones de memoria, pero <strong>un arreglo no es un puntero</strong>, y <strong>ninguno de ellos es una dirección</strong> (aunque las representan), porque:</p>
<ul>
<li><p>Un arreglo tiene memoria asignada para todos sus elementos (desde la carga del programa, para arreglos globales o <code>static</code>, y desde la entrada a la función donde se lo declara, para los arreglos locales).</p></li>
<li><p>Un puntero, en cambio, solamente contiene una dirección, que puede ser o no válida en el sentido de apuntar o no a un objeto existente en el espacio direccionable por el programa. La validez de la dirección contenida en un puntero es responsabilidad del programador.</p></li>
</ul>
<h3 id="no-analizar-el-nivel-de-indirección">No analizar el nivel de indirección</h3>
<p>Una variable de un tipo básico cualquiera contiene un dato que puede ser directamente utilizado en una expresión para hacer cálculos. En cambio, un puntero que apunte a esa variable contiene su dirección; es una <strong>referencia</strong> al dato, y necesita ser <strong>dereferenciado</strong> para acceder al dato. La variable y su puntero tienen <strong>diferente nivel de indirección</strong>.</p>
<p>Un <code>char</code>, un <code>int</code>, un <code>long</code>, un <code>double</code>, una estructura de un tipo definido por el usuario, tienen un mismo nivel de indirección, que podríamos llamar . Un puntero, una dirección, un nombre de arreglo, tienen un . La Fig. [fig:indir] esquematiza situaciones donde los niveles de indirección son <strong>0, 1, y 2</strong>.</p>
<p>Aplicar el operador <code>&amp;</code> (dirección de) a algo aumenta su nivel de indirección. Aplicar el operador <code>*</code> (dereferenciación) lo decrementa.</p>
<p>Este tipo de análisis es sumamente útil para prevenir errores de programación. Conviene utilizarlo para dar una segunda mirada crítica a las expresiones que escribimos.</p>
<pre><code>char *s = &quot;cadena&quot;;
char *t;
char u;
t = s + 2; /* CORRECTO */
u = s;     /* INCORRECTO */
u = *s;    /* CORRECTO */
t = &amp;u;    /* CORRECTO */	</code></pre>
<p>La asignación <code>t = s + 2</code> es correcta porque la suma de una dirección más un entero está definida y devuelve una dirección; con lo cual la expresión mantiene el mismo nivel de indirección en ambos miembros (<strong>puntero = dirección</strong>).</p>
<p>En cambio, la asignación <code>u = s</code> intenta asignar una dirección (la dirección contenida en <code>s</code>) a un char. No se respeta el mismo nivel de indirección en ambos miembros de la asignación (<strong>puntero = char</strong>), de modo que ésta es incorrecta y será rechazada por el compilador.</p>
<p>En las dos últimas asignaciones se usan los operadores de dirección y de indirección para hacer consistentes los niveles de indirección de ambos miembros:</p>
<pre><code>		u = *s;
		char = lo apuntado por(puntero a char);
		char = char;</code></pre>
<pre><code>		t = &amp;u;
		puntero a char = direccion de(char);
		direccion de char = direccion de char;</code></pre>
<h2 id="arreglos-de-punteros">Arreglos de punteros</h2>
<p>Una construcción especialmente útil es la de <strong>arreglos de punteros a carácter</strong>. Esta construcción permite expresar una lista de rótulos y navegar por ellos con la indexación natural de los arreglos.</p>
<p>Aquí el tipo de los elementos del arreglo mes es puntero a carácter. Cada elemento se inicializa en la declaración a una constante string.</p>
<pre><code>char *mes[] = { &quot;Ene&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Abr&quot;,&quot;May&quot;,&quot;Jun&quot;,
                &quot;Jul&quot;,&quot;Ago&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dic&quot; };

printf(&quot;Mes: %s\n&quot;,mes[6]);</code></pre>
<h2 id="estructuras-referenciadas-por-punteros">Estructuras referenciadas por punteros</h2>
<p>En el caso particular de <strong>estructuras o uniones referenciadas por punteros</strong>, la notación para acceder a sus miembros cambia ligeramente, reemplazando el operador por .</p>
<p>Accedemos a los miembros de la estructura <code>persona</code> en forma directa:</p>
<pre><code>struct persona p;
p.DNI = 14233326;
p.edad = 40;</code></pre>
<p>En forma indirecta:</p>
<pre><code>struct persona p, *pp;
pp = &amp;p;
pp-&gt;DNI = 14233326;
pp-&gt;edad = 40;</code></pre>
<h2 id="estructuras-de-datos-recursivas">Estructuras de datos recursivas</h2>
<p>Las estructuras de datos recursivas se expresan efectivamente creando miembros que sean punteros a estructuras del mismo tipo.</p>
<pre><code>struct itemlista {
    double dato;
    struct itemlista *proximoitem;
}</code></pre>
<pre><code>struct nodoarbol {
    int valor;
    struct nodoarbol *hijoizquierdo;
    struct nodoarbol *hermanoderecho;
}</code></pre>
<p>En cambio, no es legal la composición de estructuras dentro de sí mismas:</p>
<pre><code>struct itemlista { /* INCORRECTO */
    double dato;
    struct itemlista proximoitem;
}</code></pre>
<h2 id="construcción-de-tipos">Construcción de tipos</h2>
<p>Aunque la construcción de <strong>tipos definidos por el usuario</strong> no es una característica directamente ligada a los punteros o a las variables estructuradas, es un momento apropiado para introducirla. El lenguaje C admite la generación de nuevos nombres para tipos (en particular, los tipos estructurados) mediante la primitiva <code>typedef</code>.</p>
<p>Las declaraciones del ejemplo anterior se podrían reescribir más claramente de la forma que sigue.</p>
<pre><code>typedef struct nodoarbol {
    int valor;
    struct nodoarbol *hijoizquierdo;
    struct nodoarbol *hermanoderecho;
}nodo;
typedef struct nodoarbol *nodop;	</code></pre>
<p>Entonces, el tipo de un argumento de una función podría quedar expresado sintéticamente como <code>nodop</code>:</p>
<pre><code>nodop crearnodo(nodop padre);</code></pre>
<p>La construcción con <code>typedef</code> no es indispensable, pero aporta claridad al estilo de programación, y, bien manejada, promueve la portabilidad.</p>
<h2 id="asignación-dinámica-de-memoria">Asignación dinámica de memoria</h2>
<p>Se ha visto la necesidad de que los punteros apunten a direcciones válidas. ¿Qué hacer cuando la lógica del programa pide la creación de estructuras de datos en forma dinámica? Los punteros son muy convenientes para manejarlas, pero se debe asegurar que apunten a zonas de memoria legítimamente obtenidas por el programa.</p>
<p>En C se tiene como <strong>herramientas básicas de gestión dinámica de memoria</strong> a las funciones <code>malloc()</code> y <code>free()</code>. Con <code>malloc()</code> pedimos una cantidad de bytes contiguos que serán tomados del <strong>heap</strong>. La función <code>malloc()</code> devuelve la dirección del bloque de memoria asignado. Esta dirección debe reservarse en un puntero para uso futuro y para liberarla con <code>free()</code>.</p>
<p>En lugar de hacer que <code>p</code> apunte a un objeto existente al momento de compilación, solicitamos tanta memoria como sea necesaria para alojar un entero y ponemos a <code>p</code> apuntando allí. Luego podemos hacer la asignación. Luego del uso se debe liberar la zona apuntada por <code>p</code>.</p>
<pre><code>/* Correcto */
int *p;
p = malloc(sizeof(int));
*p = 8;
free(p);</code></pre>
<p>Mejoramos el ejemplo anterior verificando que devuelva memoria válida.</p>
<pre><code>/* ¡Mejor! */
int *p;
if(p = (int *)malloc(sizeof(int))) {
	*p = 8;
	free(p);
}</code></pre>
<p>Aplicamos el operador <strong>cast</strong> al resultado de para que ambos miembros de la asignación sean consistentes.</p>
<p>La propiedad de poder aplicar indexación a los punteros hace que, virtualmente, el C sea capaz de proporcionarnos <strong>arreglos dimensionables en tiempo de ejecución</strong>. En efecto:</p>
<pre><code>double *tabla;
tabla = malloc(k);
tabla[50] = 15.25;</code></pre>
<p>Estas líneas son virtualmente equivalentes a un arreglo de <span class="math inline"><em>k</em></span> elementos <code>double</code>, donde <span class="math inline"><em>k</em></span>, por supuesto, puede ser calculado en tiempo de ejecución.</p>
<p>Una variante de <code>malloc()</code> es la función <code>calloc()</code>, que solicita una cantidad dada de elementos de memoria, de un tamaño también dado, y además garantiza que todo el bloque de memoria concedido esté <strong>inicializado con ceros binarios</strong>.</p>
<pre><code>float *lista;
int i;
lista = calloc(k, sizeof(float));
for(i=0; i&lt;k; i++)
    lista[i] = fun(i);</code></pre>
<h2 id="punteros-a-funciones">Punteros a funciones</h2>
<p>Así como se pueden tomar las direcciones de los elementos de datos, es posible manipular las <strong>direcciones iniciales de los segmentos de código</strong> representados por las funciones de un programa C, mediante punteros a funciones. Esta característica es <strong>sumamente poderosa</strong>.</p>
<p>La declaración de un puntero a función tiene una sintaxis algo complicada: debe indicar <strong>el tipo devuelto</strong> por la función y los <strong>tipos de los argumentos</strong>. El nombre del puntero, con el signo de incluido, debe estar <strong>entre paréntesis</strong> en la declaración.</p>
<p>Definición de un puntero llamado <code>p</code>, a una función que recibe dos enteros y devuelve un entero:</p>
<pre><code>int (*p)(int x, int y);</code></pre>
<p>o también:</p>
<pre><code>int (*p)(int, int);</code></pre>
<p>Los paréntesis alrededor de <code>*p</code> son importantes: sin ellos, se define una <strong>función que devuelve un puntero a entero</strong>, que no es lo que se pretende.</p>
<p>Asignación del puntero <code>p</code>:</p>
<pre><code>int fun(int x, int y)
{
    ...
}
p = fun;</code></pre>
<p>Uso del puntero <code>p</code> para invocar a la función <code>fun</code> cuya dirección tiene asignada:</p>
<pre><code>a = (*p)(k1, 20 - k2);</code></pre>
<h2 id="aplicación-de-punteros-a-funciones">Aplicación de punteros a funciones</h2>
<p>La Biblioteca Standard contiene una función, <code>qsort()</code>, que realiza el ordenamiento de una tabla de datos mediante el método de <strong>Quicksort</strong>. Para que pueda ser completamente flexible (para poder ordenar datos de cualquier naturaleza y según cualquier criterio), la función acepta a su vez una <strong>función provista por el usuario</strong>, que determina el <strong>orden de dos elementos</strong>.</p>
<p>Es responsabilidad del usuario, entonces, definir cuándo un elemento es mayor que el otro, a través de esta función de comparación. La función de ordenamiento recibe un puntero a la función de comparación y la invoca repetidamente.</p>
<p>La función de comparación sólo debe aceptar <code>p1</code> y <code>p2</code>, dos punteros a un par de datos, y seguir el protocolo siguiente:</p>
<table>
<thead>
<tr class="header">
<th align="center">Si</th>
<th align="center">Devolver</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">*<em>p</em>1 &lt; *<em>p</em>2</span></td>
<td align="center">un número menor que cero</td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">*<em>p</em>1 = = * <em>p</em>2</span></td>
<td align="center">cero</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">*<em>p</em>1 &lt; *<em>p</em>2</span></td>
<td align="center">un número mayor que cero</td>
</tr>
</tbody>
</table>
<p>La declaración de argumentos formales como <code>void *</code> expresa que esos argumentos pueden tratarse de direcciones de objetos de cualquier tipo.</p>
<pre><code>#include &lt;stdlib.h&gt;

struct p {
    ...
    char nombre[40];
    double salario;
    ...
} lista[100];

int cmpSalario(const void *p1, const void *p2)
{
    return p1-&gt;salario - p2-&gt;salario;
}

int cmpNombre(const void *p1, const void *p2)
{
    return strncmp(p1-&gt;nombre, p2-&gt;nombre, 40);
}</code></pre>
<p>Con estas definiciones, la tabla <strong>lista</strong> se puede ordenar por uno u otro campo de la estructura con las sentencias:</p>
<pre><code>qsort(lista, 100, sizeof(struct p),cmpSalario);</code></pre>
<pre><code>qsort(lista, 100, sizeof(struct p),cmpNombre);</code></pre>
<h2 id="punteros-a-punteros">Punteros a punteros</h2>
<p>La indirección mediante punteros puede ser <strong>doble, triple</strong>, etc. Los punteros dobles tienen aplicación en el manejo de conjuntos de strings o matrices bidimensionales.</p>
<p>Como en el caso de punteros a funciones, esto brinda una gran potencia, pero a costa de complicar enormemente la notación y la programación, por lo que se recomienda no abordar el tema en un curso introductorio y, sólo una vez dominadas las técnicas y conceptos básicos de punteros, referirse a una fuente como el libro de Kernighan y Ritchie, 2ª edición.</p>
<p>Un ejemplo de uso de punteros dobles.</p>
<ul>
<li><p>En estas sentencias, el puntero <code>q</code> recibe la dirección de <code>a</code>; pero <code>p</code> recibe la dirección de <code>q</code>. Luego, <code>p</code> contiene de <code>a</code>.</p></li>
<li><p>Similarmente, la expresión <code>*p</code> significa ; pero entonces <code>**p</code> significa .</p></li>
</ul>
<pre><code>int **p;    /* un puntero doble */
int *q;
int a;
q = &amp;a;		/* q recibe la direccion de a */
p = &amp;q;		/* p recibe la direccion de q */
			
**p = 8;    /* la variable a recibe un valor 8 */</code></pre>
<h2 id="sec:lafunciongets">Una herramienta: gets()</h2>
<p>Para facilitar la práctica damos la descripción de otra función de Biblioteca Standard.</p>
<p>La función <code>gets()</code> pide al usuario una cadena terminada por <code>ENTER</code>. Recibe como argumento un espacio de memoria (expresado por una dirección) donde copiará los caracteres tipeados. El fin de la cadena recibirá automáticamente un <strong>cero final</strong> para hacerla compatible con las funciones de tratamiento de strings de la Biblioteca Standard.</p>
<p>La función <code>gets()</code> debe recibir la dirección de un área de memoria legal para el programa y donde no haya riesgo de sobreescribir contenidos. Es importante comprender la teoría dada en este capítulo para evitar el <strong>uso de un puntero no inicializado</strong>, una situación de error frecuente cuando se utilizan <code>gets()</code> y funciones similares.</p>
<p>Creamos un área de memoria utilizable por gets() simplemente definiendo un arreglo de caracteres del tamaño deseado.</p>
<pre><code>main()
{
    char arreglo[100];
    gets(arreglo);
}</code></pre>
<p>El puntero del siguiente ejemplo no está inicializado. Por ser una variable local, contiene <strong>basura</strong>, y por lo tanto apunta a un lugar impredecible.</p>
<pre><code>main()
{
    char *s;
    gets(s); /* ¡¡¡Mal!!! */
}</code></pre>
<p>Podemos corregir el ejemplo anterior proveyendo espacio legítimo a donde apunte <code>s</code>, reservándolo estáticamente mediante la declaración del arreglo.</p>
<pre><code>main()
{
    char arreglo[100];
    char *s;
    s = arreglo;
    gets(s); 		/* ¡Ahora sí! */
}</code></pre>
<p>En el siguiente ejemplo cambiamos la asignación estática del ejemplo anterior, usando ahora asignación dinámica y liberación de memoria. En un sentido estricto, en este caso particular no es necesaria la liberación, porque la terminación del programa devuelve todas las estructuras creadas dinámicamente; pero es útil habituarse a la disciplina de aparear cada invocación de <code>malloc()</code> con el correspondiente <code>free()</code>.</p>
<pre><code>main()
{
    char *s;
    s = malloc(100); /* ¡Ahora también! */
    gets(s);
    printf(&quot;ingresado: %s\n&quot;,s);
    free(s);
}</code></pre>
<p>[sec:tc-punteros-preg] La expresión puede traducirse como . . . .</p>
<p>La expresión es equivalente a multiplicar por . hacer igual a lo apuntado por . almacenar en la dirección de . .</p>
<p>La expresión es equivalente a la dirección de . lo apuntado por . lo apuntado por la dirección de . la dirección de lo apuntado por .</p>
<p>La expresión equivale al valor de . . . .</p>
<p>La expresión equivale al valor de .</p>
<p>Con la declaración , la variable será un carácter. un puntero a carácter. la dirección de un carácter. todas las anteriores.</p>
<p>Con la declaración , la variable será un carácter. un puntero a carácter. la dirección de un carácter. todas las anteriores.</p>
<p>Con la declaración , la expresión será un puntero. equivalente a la dirección de . equivalente a lo apuntado por . un arreglo.</p>
<p>Con la declaración , la expresión será un puntero. equivalente a la dirección de j. equivalente a lo apuntado por j. un arreglo.</p>
<p>La expresión , si y son punteros a , vale la cantidad de bytes entre las direcciones apuntadas por y . la diferencia entre las direcciones apuntadas por y . la cantidad de bytes que hace falta desplazarse desde la dirección apuntada por para llegar a la dirección apuntada por . Todas las anteriores. Ninguna de las anteriores.</p>
<p>La expresión , si y son punteros a , vale La cantidad de bytes entre las direcciones apuntadas por y . La cantidad de longs que caben entre las direcciones apuntadas por y . La diferencia entre los s apuntados por y por . Todas las anteriores. Ninguna de las anteriores.</p>
<p>Con la declaración construimos un arreglo. un puntero a una cadena terminada en <code>0</code>. un puntero a una cadena terminada en . un puntero a un carácter . un puntero nulo.</p>
<p>El puntero nulo es igual a <code>0</code>. . . .</p>
<p>Con la declaración , se tiene que equivale a: la dirección de la cadena <code>beta</code>. la dirección de la cadena <code>alfa</code>. la letra ’l’ dentro de la cadena <code>alfa</code>. la letra ’b’ dentro de la cadena <code>beta</code>. Ninguna de las anteriores.</p>
<p>Con la declaración se tiene que equivale a: la dirección de la cadena <code>beta</code>. la dirección de la cadena <code>alfa</code>. la letra ’l’ dentro de la cadena <code>alfa</code>. la letra ’b’ dentro de la cadena <code>beta</code>. Ninguna de las anteriores.</p>
<p>Con la declaración , la letra dentro de la cadena <code>beta</code> se puede escribir como: . . . Todas las anteriores. Ninguna de las anteriores.</p>
<h2 id="sec:tc-punteros-ej">Ejercicios</h2>
<ol>
<li><p>¿Qué objetos se declaran en las sentencias siguientes? El primero, por ejemplo, es un <em>apuntador a función que recibe un entero y devuelve un double</em>.</p>
<ol>
<li><p>double (*nu)(int kappa);</p></li>
<li><p>int (*xi)(int *rho);</p></li>
<li><p>long phi();</p></li>
<li><p>int *chi;</p></li>
<li><p>int pi[3];</p></li>
<li><p>long *beta[3];</p></li>
<li><p>int *(gamma[3]);</p></li>
<li><p>int (*delta)[3];</p></li>
<li><p>void (*eta[5])(int *rho);</p></li>
<li><p>int *mu(long delta);</p></li>
</ol></li>
<li><p>Construir una función que reciba un arreglo de punteros a string A y un string B, y busque a B en el array A, devolviendo su índice en el array, o bien <span class="math inline">−1</span> si no se halla.</p></li>
<li><p>Construir una función que imprima una cadena en forma inversa. Muestre una versión iterativa y una recursiva.</p></li>
<li><p>Construir un programa que lea una sucesión de palabras y las busque en un pequeño diccionario. Al finalizar debe imprimir la cuenta de ocurrencias de cada palabra en el diccionario.</p></li>
<li><p>Construir un programa que lea una sucesión de palabras y las almacene en un arreglo de punteros a carácter.</p></li>
<li><p>Ordenar lexicográficamente el arreglo de punteros del ejercicio 4.</p></li>
</ol>
<h1 id="entradasalida-standard">Entrada/Salida Standard</h1>
<p>El concepto de <strong>Entrada/Salida</strong> en C replica el de su ambiente nativo, el sistema operativo UNIX, donde todos los archivos son vistos como una sucesión de bytes, prescindiendo completamente de su contenido, organización o forma de acceso. Además, en UNIX los dispositivos de entrada o salida llevan asociados <strong>archivos lógicos</strong>, que son puntos de entrada implementados en software a dichos dispositivos. Toda la comunicación entre un programa y el mundo externo, ya sean archivos físicos o lógicos, se hace mediante las mismas funciones comunes. Para la programación en C, la abstracción de un archivo es simplemente un flujo de bytes o stream, que se maneja con operaciones primitivas comunes y con independencia de cuál sea el origen y su destino de ese flujo.</p>
<p>Si bien el C no contiene palabras reservadas de entrada/salida (<strong>E/S</strong>), la Biblioteca Standard sí provee un rico conjunto de funciones de E/S, tan amplio que suele provocar confusión en quienes se aproximan por primera vez al lenguaje. Primero veremos un resumen de las funciones de E/S standard y luego nos concentraremos en la E/S sobre archivos. Aunque la información dada aquí es suficiente para intentar la creación de programas simples, la E/S es un tema notablemente complejo, y es aconsejable tener a mano el manual de las funciones C de nuestro sistema. Para mejor orientarnos, agregamos un mapa de esta unidad en el Cuadro [tab:mapaes].</p>
<p><span>|c|c|c|c|</span><br />
E/S standard ([sec:esstandard])&amp;<br />
De caracteres ([subsec:esstandardcaract])&amp; &amp; POSIX ([subsec:esarchivosposix])<br />
De líneas ([subsec:esstandardlineas])&amp; De caracteres ([subsubsec:esarchivosansiccaract])&amp; De acceso directo ([subsec:esarchivosansicdirect])&amp;<br />
Con formato ([subsec:esstandardformato])&amp; De líneas ([subsubsec:esarchivosansiclineas])&amp; &amp;<br />
Sobre strings ([subsec:esstandardstrings])&amp; Con formato ([subsubsec:esarchivosansicformato])&amp; &amp;<br />
</p>
<h2 id="sec:esstandard">Funciones de E/S Standard</h2>
<p>Los programas C reciben tres <strong>canales de comunicación</strong> con el ambiente abiertos antes de comenzar su ejecución. El uso típico de estos canales de comunicación es la lectura del teclado y la impresión sobre pantalla, aunque, si el sistema operativo lo soporta, la existencia de estos canales también hace posibles las poderosas técnicas de la <strong>redirección</strong> y el <strong>piping</strong>.</p>
<p>La Biblioteca Standard provee funciones mínimas para estos usos, quedando fuera de consideración algunas características indispensables en programas de producción, como seguridad, validación de datos, o la posibilidad de organizar la salida en pantalla. Por ejemplo, no hay una forma canónica de borrar la pantalla en C, ya que ésta es una función que depende fuertemente de la plataforma y del ambiente donde se ejecute el programa. Las características faltantes en la E/S standard se compensan recurriendo a bibliotecas de terceras partes.</p>
<h2 id="subsec:esstandardcaract">E/S standard de caracteres</h2>
<p>Las funciones de E/S standard de caracteres son y . Las funciones y leen de teclado e imprimen, respectivamente, <strong>un carácter por vez</strong>.</p>
<p>Un programa que copia la entrada en la salida, carácter a carácter. Puede usarse, con redirección, para crear o copiar archivos, como un clon del comando de UNIX.</p>
<pre><code>#include &lt;stdio.h&gt;
main()
{
    int a;
    while((a = getchar()) != EOF)
        putchar(a);
}</code></pre>
<h2 id="subsec:esstandardlineas">E/S standard de líneas</h2>
<p>Las funciones y leen de teclado e imprimen, respectivamente, <strong>líneas de caracteres</strong> terminadas por la señal de fin de línea . La función debe recibir como argumento <strong>la dirección de un buffer o zona de memoria</strong> donde depositar los caracteres provenientes de entrada standard. Éstos pueden ser tipeados por el usuario, o, gracias a la redirección, provenir de archivos, o ser resultado de la ejecución –eventualmente concurrente– de otros programas.</p>
<p>Es un error muy frecuente ofrecer a un puntero no inicializado. La función ha sido descripta en la unidad sobre apuntadores y direcciones (ver Sección [sec:lafunciongets]).</p>
<p>El mismo programa, pero orientado a copiar un stream de texto línea por línea. La constante está definida en y es el tamaño del buffer de estas funciones. Se puede sugerir esta elección para el buffer del programa, salvo que haya motivos para proporcionar otro tamaño.</p>
<pre><code>#include &lt;stdio.h&gt;
main()
{
    char area[BUFSIZ];
    while(gets(area) != NULL)
        puts(area);
}</code></pre>
<p>La función elimina el final con que termina la línea antes de almacenarla en su buffer. La función lo repone.</p>
<h2 id="subsec:esstandardformato">E/S standard con formato</h2>
<p>Las funciones y permiten imprimir e ingresar, respectivamente, <strong>conjuntos de datos en formato legible, descriptos por cadenas de formato</strong>. Las cadenas se componen de especificaciones de conversión y son simétricamente las mismas para ambas funciones. La función y las cadenas de formato han sido descriptas en la unidad correspondiente a tipos de datos (ver sección [sec:lafuncionprintf]).</p>
<p>Inversamente a , la función buscará en la entrada standard <strong>patrones de caracteres</strong> que estén de acuerdo con las especificaciones de conversión. Generará representaciones internas para los datos leídos, y los almacenará en variables. Para esto debe recibir las <strong>direcciones</strong> de dichas variables donde almacenar los elementos detectados en la entrada standard. Es un error frecuente ofrecerle, como argumentos, <strong>las variables, y no las referencias</strong> a las mismas.</p>
<p>Leer de entrada standard un valor entero y un , e imprimirlos. Controlar que efectivamente se haya logrado leer ambos valores antes de imprimir las variables.</p>
<pre><code>main() 
{
    int a, long b;
    if(scanf(&quot;%d %ld&quot;, &amp;a, &amp;b) != 2)
        exit(1);
    printf(&quot;a=%d, b=%ld\n&quot;, a, b);
}</code></pre>
<p>El uso de es con frecuencia problemático. La función consumirá toda la entrada posible, pero se detendrá al encontrar un error (una entrada que no corresponda a lo descripto por la especificación de conversión) y <strong>dejará el resto de la entrada sin procesar</strong>, en el buffer de entrada. Si luego otra función de entrada intenta leer, se encontrará con esta entrada no consumida, lo cual puede dar origen a problemas de ejecución difíciles de diagnosticar. El error parecerá producirse en una instrucción <strong>posterior</strong> a la invocación de culpable.</p>
<p>Por esta razón suele ser difícil combinar el uso de con el de otras funciones de entrada/salida. Además, no hay manera directa de validar que la entrada quede en el rango del tipo de datos destino.</p>
<p>El uso más recomendable de es cuando se la utiliza para leer, mediante redirección, un flujo <strong>generado automáticamente</strong> por otro programa (y que, por lo tanto, tiene una gramática rigurosa y conocida).</p>
<h2 id="subsec:esstandardstrings">E/S standard sobre strings</h2>
<p>La misma lógica de las funciones de E/S con formato sirve para que otras funciones lean variables con formato de un string, o impriman variables formateadas sobre una cadena. El efecto de sobre su cadena argumento es el mismo que tendría sobre salida standard. Por su parte la función lee de un string en memoria, conteniendo datos en formato legible, y los recoge en representación binaria en variables, lo mismo que si los hubiera leído de entrada standard.</p>
<pre><code>main()
{
    char area[1024];
    int a; long b;
    
	printf(&quot;1: %d %ld\n&quot;, -6534, 1273632);
    sprintf(area, &quot;%d %ld&quot;, -6534, 1273632);
	printf(&quot;2: %s\n&quot;,area);
    sscanf(area, &quot;%d %ld&quot;, &amp;a, &amp;b);
    printf(&quot;3: %d %ld\n&quot;, a, b);
}</code></pre>
<p>El resultado debería ser:</p>
<pre><code>1: -6534 1273632
2: -6534 1273632
3: -6534 1273632</code></pre>
<h1 id="sec:esarchivos">E/S sobre archivos</h1>
<p>Diferentes sistemas operativos tienen diferentes <strong>sistemas de archivos</strong> y diferentes <strong>modelos de archivos</strong>. Los sistemas de archivos son los conjuntos de funciones particulares que cada sistema ofrece para acceder a los archivos y a la estructura de directorios que soporta. Los modelos de archivos son aquellas convenciones de formato u organización que son particulares de un sistema operativo o plataforma.</p>
<p>Por ejemplo, tanto DOS como UNIX soportan la noción de archivo de texto, pero con algunas diferencias a nivel de modelo de archivos. En ambos, un archivo de texto es una secuencia de líneas de texto, donde cada línea es una secuencia de caracteres terminado en fin de línea; pero en DOS, la convención de fin de línea es un par de caracteres (<strong>CR, LF</strong>) (equivalentes a ASCII 13 y 10, respectivamente) mientras que para UNIX, un fin de línea equivale solamente a <strong>LF</strong> (ASCII 10). Además DOS, a diferencia de UNIX, almacena un carácter especial (<strong>EOF</strong> o ASCII 26) al final de los archivos de texto para señalar el fin del archivo.</p>
<p>Por otro lado, diferentes sistemas de archivo proveen diferentes vistas sobre diferentes implementaciones. Un sistema operativo puede soportar o no la noción de directorio, o la de links múltiples; o puede fijar determinadas condiciones sobre los nombres de archivos, todo esto en función de la organización íntima de sus estructuras de datos.</p>
<h2 id="estándares-ansi-y-posix">Estándares ANSI y POSIX</h2>
<p>Siendo uno de sus objetivos de diseño el favorecer la producción de programas portables, el lenguaje C contempla la forma de resolver estos problemas de manera fácil para los programadores. Las funciones de entrada/salida sobre archivos de la Biblioteca Standard están divididas en dos grandes regiones: el conjunto de funciones del C standard, también llamadas funciones de entrada/salida <strong>bufferizada</strong>, definidas por ANSI, y las <strong>funciones POSIX</strong>, también llamadas funciones de entrada/salida <strong>de bajo nivel</strong>.</p>
<p>Las funciones ANSI C tienen el objetivo de ocultar a los programas las particularidades de la plataforma, haciéndolos plenamente portables a pesar de las diferencias conceptuales y de implementación de entrada/salida entre los diferentes sistemas operativos. Estas funciones resuelven, por ejemplo, el clásico problema de las diferentes convenciones sobre los delimitadores de un archivo de texto. Es decir, están orientadas a resolver los problemas de incompatibilidad inherentes al modelo de archivos. En cambio, el esfuerzo de estandarización de POSIX apunta a establecer (aunque no solamente en lo referente a los archivos) una interfaz uniforme entre compilador y sistema operativo, proveyendo primitivas de acceso a los archivos con un comportamiento claramente determinado, independientemente de cuál sea el sistema operativo subyacente. Así, las funciones POSIX resuelven problemas de consistencia entre diferentes sistemas de archivos.</p>
<p>Las funciones del ANSI C son las más comúnmente utilizadas por el programador, pero se apoyan en funcionalidad suministrada por las funciones POSIX (de nivel más bajo), que también están disponibles y son las recomendadas cuando las restricciones del problema exceden a las funciones ANSI. La característica fundamental de las funciones ANSI es la entrada/salida bufferizada. Por ejemplo, una operación de escritura solicitada por una instrucción del programa no se efectiviza inmediatamente sino que se realiza sobre un buffer intermedio, administrado por las funciones de Biblioteca Standard y con su política propia de <em>flushing</em> o descarga al dispositivo.</p>
<p>Las funciones de entrada/salida bufferizada reciben argumentos a imprimir y los van depositando en un buffer o zona de memoria intermedia. Cuando el buffer se llena, o cuando aparece un carácter de fin de línea, el buffer se descarga al dispositivo, escribiéndose los contenidos del buffer en pantalla, disco, etc. En cambio, las funciones POSIX hacen E/S directa a los dispositivos (o al menos, al sistema de E/S del sistema operativo) y por esto son las preferidas para la programación de drivers, servidores, etc., donde la performance y otros detalles finos deban ser controlados más directamente por el programa.</p>
<h2 id="subsec:esarchivosansic">Funciones ANSI C de E/S sobre archivos</h2>
<p>Las funciones ANSI realizan todas las operaciones sobre archivos por medio de una estructura o bloque de control cuyo tipo en C se llama . Esta estructura está definida en el header y contiene, entre otras cosas, punteros a buffers para escritura y lectura. La primera operación necesaria es la <strong>apertura</strong> del archivo, que construye una estructura , la inicializa con valores adecuados y <strong>devuelve un apuntador</strong> a la misma (es decir, un valor de tipo ). El apuntador servirá para referenciar esa estructura durante todo el trabajo con el archivo y hasta que deba ser cerrado.</p>
<p>En la apertura del archivo corresponde indicar el <strong>modo de acceso</strong> (la clase de operaciones que se van a hacer sobre él). Como algunos sistemas operativos (notoriamente, el DOS) distinguen entre archivos de texto y binarios, el ANSI C provee dos formas de apertura, para indicar cómo se va a tratar el archivo. Cuando un archivo se abre en <strong>modo de texto</strong>, durante las operaciones de lectura y escritura se aplicarán las conversiones de fines de línea y de fin de archivo propias de la plataforma. Para los archivos abiertos en <strong>modo binario</strong>, no se aplicarán conversiones.</p>
<p>En sistemas conformes a POSIX, como UNIX, no hay realmente diferencia entre los dos modos de apertura. Si se desea especificar una apertura de archivo en <strong>modo binario</strong> (para asegurar la portabilidad) se añade una <strong>b</strong> a la especificación de modo (por ejemplo, como en <code>wb+</code>). En el Cuadro [tab:modos] se resumen las especificaciones de modos de acceso en apertura de archivos.</p>
<p><span>c|l</span> Modo &amp; Operación<br />
</p>
<p>“r”</p>
<p>&amp; Abre un archivo que ya existe para lectura.<br />
&amp; La lectura se realiza al inicio del archivo.<br />
</p>
<p>“w”</p>
<p>&amp; Se crea un nuevo archivo para escribir.<br />
&amp; Si el archivo ya existe, se inicializa y se sobreescribe.<br />
</p>
<p>“a”</p>
<p>&amp; Abre un archivo que ya existe, para agregar información al final.<br />
&amp; Sólo se puede escribir a partir del final del archivo.<br />
</p>
<p>“r+”</p>
<p>&amp; Abre un archivo que ya existe, para actualizarlo<br />
&amp; (tanto para lectura como para escritura).<br />
</p>
<p>“w+”</p>
<p>&amp; Crea un nuevo archivo para actualizarlo (lectura y escritura);<br />
&amp; si ya existe, lo sobreescribe.<br />
</p>
<p>“a+”</p>
<p>&amp; Abre un archivo para añadir información al final.<br />
&amp; Si no existe, lo crea.<br />
</p>
<p>Como en la entrada/salida standard, para manejar archivos tenemos funciones para E/S <strong>de caracteres, de líneas y con formato</strong>.</p>
<h2 id="subsubsec:esarchivosansiccaract">Funciones ANSI C de caracteres sobre archivos</h2>
<p>Las funciones que leen y escriben sobre archivos <strong>un carácter por vez</strong> son y . Ejemplo que copia un archivo:</p>
<pre><code>#include &lt;stdio.h&gt;
main()
{
    FILE *fp1, *fp2;
    int a;
    if(((fp1 = fopen(&quot;ejemplo.txt&quot;,&quot;r&quot;)) == NULL) ||
                    ((fp2 = fopen(&quot;copia.txt&quot;,&quot;w&quot;)) == NULL))
        exit(1);
    while((a = fgetc(fp1)) != EOF)
        fputc(a, fp2);
    fclose(fp1);
    fclose(fp2);
}</code></pre>
<p>Hay otras funciones dentro de esta categoría, como , que <strong>devuelve un carácter</strong> al flujo de donde se leyó.</p>
<h2 id="subsubsec:esarchivosansiclineas">Funciones ANSI C de líneas sobre archivos</h2>
<p>Mismo ejemplo anterior, en base a líneas, usando las funciones y . La declaración de variables y las sentencias de apertura y cierre de archivos son idénticas al caso anterior. Enunciamos solamente el lazo principal.</p>
<pre><code>    char area[BUFSIZ];
    ...
    while(fgets(area, BUFSIZ, fp1) != NULL)
        fputs(area, fp2);</code></pre>
<h2 id="subsubsec:esarchivosansicformato">Funciones ANSI C con formato sobre archivos</h2>
<p>Existen funciones y , casi idénticas a y , pero donde se especifica el stream de entrada o de salida. Las funciones y pueden verse como el caso particular de las primeras donde el stream es <strong>stdout</strong> o <strong>stdin</strong>, respectivamente.</p>
<p>Leer dos variables de un archivo y escribirlas, en el mismo formato, en un segundo archivo.</p>
<pre><code>#include &lt;stdio.h&gt;
main()
{
    FILE *fp1, *fp2;
    int a; long b;
    if(((fp1 = fopen(&quot;ejemplo.txt&quot;,&quot;r&quot;)) == NULL) ||
                    ((fp2 = fopen(&quot;copia.txt&quot;,&quot;w&quot;)) == NULL))
        exit(1);
    if(fscanf(fp1, &quot;%d %ld&quot;, &amp;a, &amp;b) != 2)
        exit(1);
    fprintf(fp2, &quot;%d %ld\n&quot;, a, b);
    fclose(fp1);
    fclose(fp2);
}</code></pre>
<h2 id="subsec:esarchivosansicdirect">Funciones ANSI C de acceso directo</h2>
<p>Un conjunto muy útil de funciones ANSI permite el <strong>acceso directo, aleatorio, o random</strong> sobre archivos, saltando por encima del modelo de E/S secuencial que domina al resto de las funciones. Las funciones básicas de acceso directo son y , que leen bloques de un tamaño dado y en una cantidad dada.</p>
<p>El acceso directo a un archivo se logra manteniendo un dato en su estructura , llamado el <strong>puntero de lectura/escritura</strong>, correspondiente al punto dentro del archivo donde se efectuará la próxima lectura o escritura cuando el programa lo requiera. Cada lectura o escritura de una cierta cantidad de bytes avanza este puntero en esa cantidad de bytes, dejando el puntero listo para la siguiente operación a continuación de la última.</p>
<p>Sin embargo, el valor del puntero de lectura/escritura puede consultarse o modificarse arbitrariamente, con funciones específicas. Cambiando explícitamente el valor de este dato, podemos hacerlo apuntar a cualquier dirección dada, u <em>offset</em>, dentro del archivo. Si hacemos que el puntero de escritura sea igual al tamaño en bytes del archivo, la próxima escritura se hará a partir del final del archivo. Si hacemos que sea igual a 0, la próxima lectura (o escritura) se hará a partir del comienzo del archivo. Del mismo modo se puede modificar un trozo de información, de cualquier tamaño dado, en cualquier lugar del archivo.</p>
<p>Las funciones ANSI de acceso directo utilizan el puntero de lectura/escritura. Son ideales para lectura y escritura directa de estructuras de datos, ya sea que se trate de elementos individuales u organizados en arreglos. Al poder posicionarse el <strong>puntero de lectura o escritura</strong> en zonas arbitrarias de los archivos, se logra la capacidad de <strong>E/S por registros con acceso aleatorio</strong>.</p>
<p>En el ejemplo suponemos que se han grabado en el archivo varios registros cuyo formato está representado por la estructura de la variable . La función posiciona el puntero de lectura en el <em>offset</em> (que debe ser un ), significando que necesitamos acceder al <strong>registro lógico</strong> número 10 del archivo. A continuación se leen tantos bytes como mide un elemento de datos.</p>
<p>Cambiando el tercer argumento de podemos leer en un solo acceso un vector completo de estas estructuras en lugar de un elemento individualmente. Luego de cambiar un valor del registro se lo vuelve a grabar, esta vez en un offset distinto (correspondiente al registro lógico 5).</p>
<pre><code>struct registro {
    int dato1;
    long dato2;
} datos;
...
fseek(fp, 10L * sizeof(struct registro), SEEK_SET);
fread(&amp;datos, sizeof(struct registro), 1, fp);
datos.dato1 = 1;
fseek(fp, 5L * sizeof(struct registro), SEEK_SET);
fwrite(&amp;datos, sizeof(struct registro), 1, fp);</code></pre>
<h3 id="subsubsec:posicionamiento">Constantes de posicionamiento</h3>
<p>Para posicionar el puntero de lectura/escritura en un offset determinado, existe la función . El origen del desplazamiento se expresa con las constantes , y .</p>
<p>La constante indica que el posicionamiento solicitado debe entenderse como absoluto a partir del principio del archivo. La constante indica posicionamiento a partir del offset actual, y , a partir del fin del archivo. El offset proporcionado puede ser negativo.</p>
<h3 id="sincronización-de-es">Sincronización de E/S</h3>
<p>Una restricción importante de la E/S en ANSI C es que no se pueden mezclar instrucciones de entrada y de salida sin que intervenga una operación intermedia de posicionamiento. Es decir, una sucesión de invocaciones a puede ser seguida de uno o más , pero únicamente luego de un entre ambas. La operación de posicionamiento resincroniza ambos punteros y su ausencia puede hacer que se recupere basura.</p>
<p>Este posicionamiento puede ser nulo, como por ejemplo en que no varía en absoluto la posición de los punteros, pero realiza la sincronización buscada.</p>
<h2 id="resumen-de-funciones-ansi-c-de-es">Resumen de funciones ANSI C de E/S</h2>
<p>Podemos resumir lo visto hasta aquí con los prototipos de las funciones ANSI de E/S en el Cuadro [tab:resumenesansicarchivos].</p>
<p><span>l|l|l</span> &amp; E/S Standard &amp; E/S sobre archivos<br />
&amp;</p>
<p>int getchar();</p>
<p>&amp;</p>
<p>int fgetc(FILE *stream);</p>
<p><br />
&amp;</p>
<p>int putchar(int c)</p>
<p>&amp;</p>
<p>int fputc(int c, FILE *stream);</p>
<p><br />
&amp;</p>
<p>char *gets(char *s);</p>
<p>&amp;</p>
<p>char *fgets(char *s, int n, FILE *stream);</p>
<p><br />
&amp;</p>
<p>int puts(const char *s);</p>
<p>&amp;</p>
<p>int fputs(const char *s, FILE *stream);</p>
<p><br />
&amp;</p>
<p>int printf(const char *format, ...);</p>
<p>&amp;</p>
<p>int fprintf(FILE *stream, const char *format, ...);</p>
<p><br />
&amp;</p>
<p>int scanf(const char *format, ...);</p>
<p>&amp;</p>
<p>int fscanf(FILE *stream, const char *format, ...);</p>
<p><br />
&amp;</p>
<p>int sprintf(char *s, const char *format, ...);</p>
<p>&amp;<br />
&amp;</p>
<p>int sscanf(char *s, const char *format, ...);</p>
<p>&amp;<br />
&amp; &amp;</p>
<p>size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream);</p>
<p><br />
&amp; &amp;</p>
<p>size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream);</p>
<p><br />
</p>
<h2 id="subsec:esarchivosposix">Funciones POSIX de E/S sobre archivos</h2>
<p>Las funciones POSIX son la interfaz directa del programa con las llamadas al sistema, o <strong>system calls</strong>. Los programas que utilicen funciones POSIX deben incluir los headers de Biblioteca Standard y .</p>
<h3 id="apertura-de-archivos">Apertura de archivos</h3>
<p>Las funciones POSIX que operan sobre archivos lo hacen a través de descriptores de archivos. Estos pertenecen a una tabla de archivos abiertos que tiene cada proceso o programa en ejecución y se corresponden con estructuras de datos del sistema operativo para manejar la escritura y la lectura en los archivos propiamente dichos.</p>
<p>La tabla de archivos abiertos de un proceso se inicia con tres archivos abiertos (correspondientes a los streams de <strong>entrada standard</strong>, <strong>salida standard</strong> y <strong>salida standard de errores</strong>), que reciben los descriptores números 0, 1 y 2 respectivamente. Estos archivos son automáticamente provistos por el ambiente donde se ejecuta el proceso, y al comenzar a ejecutarse los encuentra ya abiertos.</p>
<p>Además de los tres descriptores standard abiertos por defecto, los programas abren otros archivos usando la función . Los archivos que se abran subsiguientemente irán ocupando los siguientes descriptores de archivo libres en esta tabla, y por lo tanto reciben números de descriptor de 3 en adelante. Cada nueva operación de apertura exitosa de un archivo devuelve un nuevo descriptor. Este número de descriptor se utiliza durante el resto de la actividad sobre el archivo.</p>
<p>Tanto las funciones ANSI C para archivos como las funciones POSIX de archivos manejan referencias obtenidas mediante la apertura y utilizadas durante toda la relación del programa con el archivo, pero las referencias son diferentes. La referencia al bloque de control utilizada por las funciones ANSI es de tipo , mientras que el descriptor de archivo POSIX es un . Por este motivo no se pueden mezclar las llamadas a funciones de uno y otro grupo.</p>
<p>Sin embargo, sí es cierto que las estructuras de tipo , referenciadas por un , como se dijo antes, se apoyan en funcionalidad aportada por funciones POSIX, y por lo tanto contienen un descriptor de archivo. Si se tiene un archivo abierto mediante una función POSIX, es posible, dado su descriptor, obtener directamente el stream bufferizado correspondiente para manipularlo con funciones ANSI. Esto se logra con la función .</p>
<h4 id="flags">Flags</h4>
<p>Las funciones de E/S POSIX permiten controlar varios aspectos de la entrada/salida sobre dispositivos o archivos. Existe un conjunto de <em>flags</em>, u opciones, que modifican la conducta de cada operación. Los flags se expresan como nombres simbólicos para constantes de bits, y se especifican en la apertura del archivo como segundo argumento de la función . Todas las combinaciones válidas de flags pueden expresarse como un de bits (operador ) que acumula las constantes de bits correspondientes. Resumimos los flags más importantes existentes para este segundo argumento de en el Cuadro [tab:flags].</p>
<p><span>l|l</span></p>
<p>O_RDONLY</p>
<p>&amp; El archivo se abre para lectura solamente<br />
</p>
<p>O_RDWR</p>
<p>&amp; Se abre para escritura solamente<br />
</p>
<p>O_APPEND</p>
<p>&amp; El archivo puede ser leído o agregársele contenido<br />
</p>
<p>O_CREAT</p>
<p>&amp; Si el archivo no existe, se lo crea<br />
</p>
<p>O_EXCL</p>
<p>&amp; Si ya existe, se vuelve con indicación de error<br />
</p>
<p>O_WRONLY</p>
<p>&amp; Se abre para escritura solamente<br />
</p>
<p>O_TRUNC</p>
<p>&amp; Si existe, se destruye antes de crearlo<br />
</p>
<p>Este programa copia un archivo sobre otro llamado , usando funciones POSIX y aplicadas a los descriptores obtenidos con .</p>
<ul>
<li><p>Abre el primer archivo en modo de sólo lectura con el <em>flag</em>, u opción, .</p></li>
<li><p>Como necesita escribir sobre el segundo, utiliza el flag .</p></li>
<li><p>Además, para el segundo archivo, especifica otros flags que van agregados al primero, y que son (si no existe, se lo crea) y (si ya existe, se borran todos sus contenidos).</p></li>
</ul>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
main()
{
    char area[1024];
    int fd1, fd2, bytes;
    if((fd1 = open(&quot;ejemplo.txt&quot;, O_RDONLY)) &lt; 0)
        exit(1);
    if((fd2 = open(&quot;copia.txt&quot;, O_WRONLY|O_CREAT|O_TRUNC, 0660)) &lt; 0)
        exit(1);
    while(bytes = read(fd1, area, sizeof(area)))
        write(fd2, area, bytes);
    close(fd1);
    close(fd2);
}</code></pre>
<h4 id="permisos-de-los-archivos">Permisos de los archivos</h4>
<p>El tercer argumento de tiene sentido sólo al <strong>crear</strong> un archivo. Sirve para especificar los permisos con los que será creado, siempre según el concepto de UNIX de permisos de <strong>lectura, escritura y ejecución</strong>, distribuidos en <strong>clases de usuarios</strong>. Para los sistemas operativos que no cuentan con estas nociones, el tercer argumento simplemente se ignora, pero se mantiene en la interfaz POSIX para asegurar la portabilidad de los programas. Nótese que las funciones ANSI C no permiten la especificación de estos permisos de creación.</p>
<p>Como para los flags, hay algunas constantes de bits útiles, que se detallan en el Cuadro [tab:permisos].</p>
<p><span>l|l|l|l</span> &amp; Dueño &amp; Grupo &amp; Otros<br />
Lectura &amp;</p>
<p>S_IRUSR</p>
<p>&amp;</p>
<p>S_IRGRP</p>
<p>&amp;</p>
<p>S_IROTH</p>
<p><br />
Escritura &amp;</p>
<p>S_IWUSR</p>
<p>&amp;</p>
<p>S_IWGRP</p>
<p>&amp;</p>
<p>S_IWOTH</p>
<p><br />
Ejecución &amp;</p>
<p>S_IXUSR</p>
<p>&amp;</p>
<p>S_IXGRP</p>
<p>&amp;</p>
<p>S_IXOTH</p>
<p><br />
Los tres permisos &amp;</p>
<p>S_IRWXU</p>
<p>&amp;</p>
<p>S_IRWXG</p>
<p>&amp;</p>
<p>S_IRWXO</p>
<p><br />
</p>
<p>Si el archivo no existe, se lo crea; se abre para lectura y escritura y con todos los permisos para el creador, pero sólo con permiso de lectura para el grupo del dueño. El resto de los usuarios no tiene ningún permiso sobre el archivo.</p>
<pre><code>int fd = open(&quot;prueba.dat&quot;, O_RDWR|O_CREAT, S_IRWXU|S_IRGRP);	</code></pre>
<h3 id="posicionamiento-en-archivos">Posicionamiento en archivos</h3>
<p>Para posicionar el puntero de lectura/escritura en un offset determinado, existe la función . El origen del desplazamiento se expresa, como en las funciones ANSI C de acceso directo, con las constantes , y (ver [subsubsec:posicionamiento]).</p>
<p>Repetimos el ejemplo dado para las funciones ANSI donde se lee el registro lógico número 10 y tras una modificación se lo copia en el registro lógico 5, esta vez con funciones POSIX.</p>
<pre><code>lseek(fd, 10L * sizeof(struct registro), SEEK_SET);
read(fd, &amp;datos, sizeof(struct registro));
datos.dato1 = 1;
lseek(fd, 5L * sizeof(struct registro), SEEK_SET);
write(fd, &amp;datos, sizeof(struct registro));</code></pre>
<h2 id="sec:tc-esstandard-ej">Ejercicios</h2>
<ol>
<li><p>Escribir una función que copie la entrada en la salida pero eliminando las vocales.</p></li>
<li><p>Escribir una función que reemplace los caracteres no imprimibles por caracteres punto.</p></li>
<li><p>Construir un programa que imprima su entrada invertida, carácter por carácter.</p></li>
<li><p>Construir un programa que imprima su entrada invertida, línea por línea.</p></li>
<li><p>Construir un programa que cuente la cantidad de palabras de un archivo, separadas por blancos, tabuladores o fin de línea.</p></li>
<li><p>Construir un programa que cuente la cantidad de caracteres y de líneas de un archivo.</p></li>
<li><p>Construir un programa que permita eliminar de un archivo las líneas que contengan una cadena dada.</p></li>
<li><p>Escribir una función que reciba como argumento dos enteros y devuelva un string de formato conteniendo una máscara de formato apropiada para imprimir un número en punto flotante. Por ejemplo, si se le dan como argumentos 7 y 2, deberá devolver el string . Aplicar la función para imprimir números en punto flotante.</p></li>
<li><p>Escribir sobre un archivo una variable con valor 1 y una variable con valor 2. Hacerlo primero con funciones de E/S con formato, y luego con funciones de acceso directo. Examinar en cada caso el resultado visualizando el archivo y opcionalmente con un comando como .</p></li>
<li><p>(*) Defina una estructura básica simple para un registro, a su gusto. Puede ser un registro de información personal, bibliográfica, etc. Construya funciones para leer estos datos del teclado e imprimirlos en pantalla. Luego, usando funciones ANSI C, construya funciones para leer y escribir una de estas estructuras en un archivo, dado un número de registro lógico determinado.</p></li>
<li><p>(*) Repita el ejercicio anterior reemplazando las funciones ANSI C por funciones POSIX.</p></li>
<li><p>Construya programas que utilicen las funciones anteriores, ANSI C o POSIX, y ofrezcan un menú de operaciones de administración: cargar un dato en el archivo, imprimir los datos contenidos en una posición determinada, listar la base generada completa, eliminar un registro, etc.</p></li>
<li><p>Construir una función que pida por teclado datos personales (nombre, edad, ...) y los almacene en una estructura. Construir una función que imprima los valores recogidos por la función anterior.</p></li>
<li><p>Construir un programa que lea una cantidad de datos en lote y luego los imprima utilizando las funciones del ejercicio anterior. Generar un archivo de datos usando redirección.</p></li>
<li><p>Realizar el mismo programa del punto anterior pero efectuando toda la E/S sobre archivos. El programa deberá poder leer el archivo de datos del punto anterior.</p></li>
<li><p>Construir un programa que organice la salida de la función anterior para obtener un clon del comando de UNIX.</p></li>
<li><p>Construir un programa que lea el listado de un directorio en formato largo (la salida del comando ) y devuelva la cantidad total de bytes ocupados.</p></li>
<li><p>Construya programas que utilicen las funciones ANSI C o POSIX de los ejercicios anteriores <strong>marcados con un asterisco</strong>, y que ofrezcan un menú de operaciones de administración: cargar un dato en el archivo, imprimir los datos contenidos en una posición determinada, listar la base generada completa, eliminar un registro, etc.</p></li>
</ol>
<h1 id="tc-ambiente">Comunicación con el ambiente</h1>
<p>Entendemos por comunicación con el ambiente todas aquellas formas posibles de <strong>intercambiar datos</strong> entre el programa y el <strong>entorno</strong>, ya sea el sistema operativo, el <em>shell</em> del usuario, u otro programa que lo haya lanzado. Una necesidad evidente de comunicación será recibir parámetros, argumentos u opciones de trabajo. Otras necesidades serán generar archivos con resultados, o comunicar una condición de error a la entidad que puso en marcha el programa.</p>
<h2 id="redirección-y-piping">Redirección y piping</h2>
<p>Esta forma de comunicación en realidad no es específica del C sino que está implementada (hoy, en prácticamente todos los sistemas operativos) por el shell de usuario. Todos los programas en ejecución (o procesos) nacen con tres canales de comunicación abiertos: <strong>entrada standard, salida standard y salida standard de errores</strong>. Cuando el shell lanza un programa, por default le conecta estos tres canales con los dispositivos lógicos teclado, pantalla y pantalla respectivamente. El resultado es que el programa puede recibir caracteres por teclado e imprimir cadenas por pantalla haciendo uso de las funciones de entrada/salida corrientes.</p>
<p>Ahora bien, si el usuario indica al shell, en el momento de lanzar el programa, que desea reconectar alguno de estos canales con otros dispositivos lógicos o archivos, tenemos un fenómeno de <strong>redirección</strong>, que permite que el programa, sin cambio alguno, utilice las mismas funciones de entrada/salida para leer y generar archivos o comunicarse con dispositivos diferentes.</p>
<p>Los procesos reciben tres canales de comunicación abiertos por donde relacionarse con el ambiente. Mediante redirección se pueden crear archivos con el producto de su salida, o alimentarlos con el contenido de archivos preexistentes.</p>
<p>Otra alternativa es el <strong>piping</strong>, o entubamiento, que permite, con un solo comando de shell, el lanzamiento (en forma concurrente, si lo soporta el sistema operativo) de dos o más procesos con sus entradas y salidas interconectadas para funcionar acopladas. El shell se apoya en el sistema operativo para construir un <strong>pipe</strong>, o tubería temporaria, para conducir el flujo de datos entre los procesos que se comunican.</p>
<p>El C adhiere a las convenciones de redirección y piping permitiendo manejar separadamente estos canales con sus funciones de Biblioteca Standard. Poder realizar piping entre procesos permite separar arquitecturalmente las funciones de un programa muy complejo, facilitando el desarrollo, aumentando la mantenibilidad y fomentando la reutilización de los programas escritos sin costo adicional de diseño o programación.</p>
<p>Los procesos pueden comunicarse a través de pipes o tuberías. El sistema operativo UNIX hace uso extensivo de esta capacidad proveyendo una gran cantidad de comandos sencillos que, combinados mediante piping, permiten crear poderosas herramientas sin necesidad de programación.</p>
<p>Para poder aprovechar estas capacidades solamente se requiere un protocolo común entre los programas que se comunicarán. Un medio para lograrlo, en aquellos programas que no son naturalmente cooperativos, es a veces construir adaptadores a nivel de shell. Estos son scripts generalmente sencillos que transforman un formato de datos en otro, facilitando la flexibilidad que no da el C por tratarse de un lenguaje compilado.</p>
<p>Los scripts, siendo interpretados, pueden ejecutarse directamente sin compilación. Pueden modificarse y probarse más rápidamente que los programas compilables, y la programación suele ser más flexible y poderosa. El costo asociado con el scripting es una menor velocidad de ejecución, lo que propone un estudio de cada caso, para optar entre scripting o programación ad hoc. Ambientes como el moderno UNIX ofrecen numerosas herramientas y varios intérpretes de lenguajes de scripting, cada cual con mayores ventajas en un área determinada. Herramientas que es útil conocer son , , , , etc. El shell de usuario es normalmente una buena elección para scripting de tareas simples, poseyendo un lenguaje completo con manejo de variables, estructuras de control, arreglos, etc. Sin embargo, otros como <strong>awk</strong>, <strong>Perl</strong> o <strong>Python</strong> tienen mejores capacidades de manejo de cadenas, esencial para el trabajo que describimos, además de una sintaxis sumamente sintética y poderosa.</p>
<h2 id="variables-de-ambiente">Variables de ambiente</h2>
<p>El shell, responsable de recibir las órdenes del usuario para lanzar nuevos procesos, mantiene áreas de memoria reservadas para <strong>variables de ambiente</strong> que son accesibles a los nuevos procesos. Estas variables son simplemente pares <em>(nombre, valor)</em> de cadenas asociadas.</p>
<p>Las variables de ambiente se pueden establecer y consultar con comandos de shell, desde la línea de comandos o desde un script; y lo mismo con funciones de Biblioteca Standard C desde un programa compilado. Los programas pueden consultar una variable de ambiente y decidir el curso de ejecución en función de su contenido; y pueden establecer sus valores para los procesos hijos que originen.</p>
<p>Las variables de ambiente son una forma flexible de configurar el comportamiento de los programas. Las funciones de manejo de variables de ambiente son y (POSIX). Ver también y (BSD 4.3).</p>
<p>Estos comandos a nivel de shell colocan una variable y su valor en el ambiente. El comando la hace visible a los procesos hijos.</p>
<pre><code>$ DIR=/usr/local/programa
$ export DIR</code></pre>
<p>Para leer la variable desde un programa C:</p>
<pre><code>char directorio[50];
strcpy(directorio, getenv(&quot;DIR&quot;));</code></pre>
<h2 id="argumentos-de-ejecución">Argumentos de ejecución</h2>
<p>Un programa puede recibir argumentos al momento de ejecución, dados en la línea de comandos. El protocolo para recibir argumentos se ha diseñado para ser lo más general posible. Cada argumento en la línea de comandos es una cadena, independientemente del tipo de los datos, y se accede desde el programa como un puntero a carácter. Es responsabilidad del programa hacer las conversiones a los tipos esperados.</p>
<p>Los argumentos son recibidos por la función , con las siguientes convenciones:</p>
<ul>
<li><p>espera dos parámetros, un entero y un arreglo de punteros a carácter.</p></li>
<li><p>El primer parámetro representa la cantidad total de argumentos en la línea de comandos, incluido el nombre del programa.</p></li>
<li><p>Los elementos del segundo parámetro son punteros a cadenas, terminadas en , representando cada argumento recibido (incluyendo el nombre del programa).</p></li>
</ul>
<p>El primer parámetro representa la cantidad total de argumentos en la línea de comandos, incluido el nombre del programa.</p>
<pre><code>main(int argc, char *argv[])
{
    if(argc != 3)
        printf(&quot;Debe dar nombre y edad del usuario\n&quot;);
    else
        printf(&quot;Nombre: %s Edad: %d\n&quot;, argv[1], atoi(argv[2]));
}	</code></pre>
<p>Este programa se invocaría como:</p>
<pre><code>$ programa Alicia 26
Nombre: Alicia Edad: 26</code></pre>
<h2 id="salida-del-programa">Salida del programa</h2>
<p>Cada programa ha sido lanzado por algún otro, por lo común el shell del usuario. El programa puede seguir diferentes caminos de ejecución, encontrar errores, condiciones en las cuales es imposible proseguir, etc. Al momento de finalización del programa, puede ser interesante que el programa que le dio origen recoja alguna indicación de este estado final. El C tiene la capacidad (porque la tiene el sistema operativo) de devolver un entero, cuyo significado queda completamente librado al programador. El programa originador debe interpretar este código de retorno, que es una convención entre ambos programas. Es costumbre, aunque para nada obligatoria, devolver un 0 en caso de terminación exitosa, y números diferentes de cero para diferentes casos de terminación con error, al estilo de los protocolos de las funciones de Biblioteca Standard.</p>
<p>Esta característica es especialmente útil en el contexto de un script donde necesitamos determinar si se debe proseguir la ejecución en base al estado retornado por un programa invocado. La función para terminar el programa devolviendo una señal de estado es . Si no se dan argumentos, el valor devuelto queda indefinido.</p>
<pre><code>main(int argc, char *argv[])
{
    if(argc &lt; 3) {
        printf(&quot;Insuficientes argumentos\n&quot;);
        exit(1);
    }
    procesar(argv[1],argv[2]);
    exit(0);
}</code></pre>
<h2 id="opciones">Opciones</h2>
<p>Es muy común encontrar comandos del sistema operativo que aceptan un conjunto, a veces muy vasto, de opciones. Las opciones, si están presentes, se reconocen por comenzar con guiones, y deben ser los primeros argumentos dados al programa.</p>
<p>La convención usual en UNIX de expresar las opciones con un signo guión y letras, y opcionalmente argumentos numéricos, ha llevado a definir funciones de Biblioteca Standard para manejar conjuntos de opciones.</p>
<p>El siguiente fragmento de programa supone que tenemos escritas las funciones y , y que con una opción dada al momento de ejecución queremos decidir cuál de ellas va a ser utilizada.</p>
<pre><code>#include &lt;getopt.h&gt;
#include &lt;unistd.h&gt;
extern char *optarg;
extern int optind, opterr, optopt;

int debug;

main(int argc, char *argv[])
{
    char *optstring=&quot;RrTtV:v:&quot;;
    int c;

    opterr=0;
    while((c=getopt(argc, argv, optstring)) != EOF)
        switch(c) {
            case &#39;v&#39;:
            case &#39;V&#39;:
                debug=atoi(optarg);
                printf(&quot;Nivel de debugging: %d\n&quot;,debug);
                break;
            case &#39;:&#39;:
                printf(&quot;Falta valor numérico\n&quot;);
                exit(1);
                break;
            case &#39;R&#39;:
            case &#39;r&#39;:
                printf(&quot;Recibiendo\n&quot;);
                recibir(argv[optind]);
                break;
            case &#39;T&#39;:
            case &#39;t&#39;:
                printf(&quot;Transmitiendo\n&quot;);
                transmitir(argv[optind]);
                break;
            case &#39;?&#39;:
                printf(&quot;Mal argumento\n&quot;);
                break;
        }

}	</code></pre>
<p>El programa podría usarse tanto para transmitir como para recibir archivos, observando un nivel de salida de debugging conveniente. Podría invocarse como:</p>
<pre><code>$ transferir -v 2 -T archivo.txt</code></pre>
<p>La función es quien va recogiendo las opciones vistas en la línea de comandos y devolviéndolas como caracteres separados. La variable string contiene las opciones válidas. Para aquellas opciones (como en el ejemplo) que pueden asumir un modificador numérico, se ubica un símbolo a continuación en el string . El valor para la opción numérica se recibe en la variable .</p>
<p>Si ocurre un error sintáctico en el procesamiento de las opciones, la rutina devuelve el carácter y emite un mensaje de error por salida de errores standard. Si no se desea emitir este mensaje, se hace . Las funciones y obtienen el nombre del archivo del arreglo de argumentos , indexándolo con la variable , que queda apuntando al siguiente elemento en la línea de comandos.</p>
<h2 id="sec:ambienteej">Ejercicios</h2>
<ol>
<li><p>Escribir un programa que imprima una secuencia de números consecutivos donde el valor inicial, el valor final y el incremento son dados como argumentos.</p></li>
<li><p>Mismo ejercicio pero donde los parámetros son pasados como variables de ambiente.</p></li>
<li><p>Mismo ejercicio pero donde los parámetros son pasados como opciones.</p></li>
<li><p>Programar una calculadora capaz de resolver cálculos simples como los siguientes:</p>
<pre><code>$ casio 3 + 5
8
$ casio 20 * 6
120
$ casio 5 / 3
1</code></pre></li>
<li><p>Agregar la capacidad de fijar precisión (cantidad de decimales) como una opción:</p>
<pre><code>$ casio -d2  5 / 3
1.66</code></pre></li>
<li><p>Manteniendo la capacidad anterior, agregar la posibilidad de leer una variable de ambiente que establezca la precisión default. Si no se da la precisión como opción, se tomará la establecida por la variable de ambiente, pero si se la especifica, ésta será la adoptada. Si no hay definida una precisión se tomará 0. Ejemplo:</p>
<pre><code>$ casio 10 / 7
1
$ PRECISION_CASIO=5
$ export PRECISION_CASIO
$ casio 10 / 7
1.42857
$ casio -d2 10 / 7
1.42</code></pre></li>
<li><p>Retomar ejercicios de programación de prácticas anteriores, agregándoles opciones. Por ejemplo, el programa para eliminar líneas de un archivo (Ejercicios [sec:tc-esstandard-ej]) admite una opción para elegir líneas conteniendo o no conteniendo una cadena. El programa que cuenta palabras de un archivo (misma práctica) puede recibir opciones o variables de ambiente especificando cuáles serán los separadores entre palabras.</p></li>
</ol>
<h1 id="tc-bstandard">La Biblioteca Standard</h1>
<p>La Biblioteca Standard no forma parte del lenguaje C, estrictamente hablando, pero todos los compiladores contienen una implementación de ella, a veces con agregados o pequeñas variantes. Desde la oficialización del ANSI C, los contenidos de la Biblioteca Standard se han estabilizado y se puede contar con el mismo conjunto de funciones en todas las plataformas.</p>
<p>Las funciones de la Biblioteca Standard están agrupadas en varias categorías, cada una representada en un header, según el Cuadro [tab:catbs]. Una implementación de C puede, sin embargo, aportar muchísimos otros headers, más específicos.</p>
<p>Para poder utilizar cualquiera de las funciones de cada categoría, es necesario incluir en el fuente el header asociado con la categoría. Esto no implica incluir los textos de las funciones en la unidad de traducción, sino simplemente incorporar los prototipos de las funciones de la biblioteca. Es decir, incluir un header de Biblioteca Standard no <strong>define</strong> las funciones que se van a usar, sino que las <strong>declara</strong>. La resolución de las referencias a las funciones o variables de Biblioteca Standard quedan pendientes hasta la linkedición.</p>
<p>Ya hemos visitado la mayoría de las funciones de la categoría de funciones de E/S. Nos quedan por explorar algunas otras de importancia. Con esta información no pretendemos reemplazar al manual del compilador, sino orientar a los primeros pasos en el uso de la Biblioteca Standard.</p>
<h2 id="cadenas-o-strings">Cadenas o strings</h2>
<p>No existiendo un tipo de datos string en C, se lo implementa como un arreglo de caracteres, dado por su dirección inicial, y terminado en el carácter especial . Todas las funciones de strings de Biblioteca Standard, declaradas en el header , hacen uso de este protocolo de fin de string. Muchas de ellas han sido implementada en las prácticas de capítulos anteriores.</p>
<p>En el Cuadro [tab:strings] aparecen las más utilizadas. Es importante consultar también el manual de las funciones , , , , .</p>
<h2 id="listas-de-argumentos-variables">Listas de argumentos variables</h2>
<p>En C es posible definir funciones con una lista de argumentos de una longitud variable, es decir, funciones que reciban una cantidad arbitraria de parámetros reales. La función de Biblioteca Standard es un claro ejemplo de esta clase de funciones, y el usuario puede definir las propias. Para esto se prepara un encabezado de la función con los parámetros reales fijos que se desee y se indican los restantes, variables, mediante puntos suspensivos. Se recuperan los demás con macros especiales definidas en este header.</p>
<p>Lamentablemente las macros declaradas en el header no permiten la creación de funciones sin argumentos fijos. Existe otro paquete de argumentos variables, definido en <strong>varargs.h</strong>, que sí lo permite; pero que no está comprendido en el estándar ANSI C y que no es compatible con .</p>
<pre><code>#include &lt;stdarg.h&gt;
int sumar(int cuantos, ...)
{
	va_list ap;
	int suma=0;

	va_start(ap, cuantos);
	for(i=0; i&lt;cuantos; i++)
		suma += va_arg(ap, int);
	va_end(ap);
	return suma;
}</code></pre>
<p>Que se utilizaría como:</p>
<pre><code>main()
{
	printf(&quot;Resultado 1: %d\n&quot;, sumar(3, 4, 5, 6));
	printf(&quot;Resultado 2: %d\n&quot;, sumar(2, 100, 2336));
}</code></pre>
<h2 id="tratamiento-de-errores">Tratamiento de errores</h2>
<p>Esta zona de la Biblioteca, declarada en los headers y , provee indispensables herramientas de <em>debugging</em>. La variable externa es un entero que toma un valor de acuerdo a condiciones de error provocadas por cualquiera de las funciones de la Biblioteca Standard, y de acuerdo a una catalogación de errores que depende de la función. Si una función ANSI C devuelve un valor indicador de error (como NULL donde debería devolver un puntero, o negativo donde debería devolver un positivo), la variable contendrá más explicación sobre el motivo del error. Se consulta con las funciones o . La función admite una cadena arbitraria para indicar, por ejemplo, el lugar del programa donde se produce el error. Imprimirá esta cadena más la descripción del problema.</p>
<pre><code>#include &lt;errno.h&gt;
    if(open(&quot;noexiste&quot;, O_RDONLY) &lt; 0)
        perror(&quot;Error en apertura&quot;);	</code></pre>
<p>La macro sirve para detener la ejecución cuando se alcanza un estado imposible para la lógica del programa. Para usarla adecuadamente es necesario identificar <strong>invariantes</strong> en el programa (condiciones que jamás deban ser falsas). Si al evaluarse la macro resulta que su condición argumento es falsa, aborta el programa indicando nombre del archivo fuente y línea donde estaba originalmente la llamada. Un programa en producción no debería fallar debido a .</p>
<pre><code>#include &lt;assert.h&gt;
    ...
    assert(restantes &gt;= 0);</code></pre>
<h2 id="funciones-de-fecha-y-hora">Funciones de fecha y hora</h2>
<p>Existen dos tipos de datos definidos en el header para manejar datos de fechas. Por un lado, se tiene el tipo , que contiene los siguientes elementos que describen un momento en el tiempo:</p>
<pre><code>struct tm {
int tm_sec,    /* segundos 0..59 */
    tm_min,    /* minutos 0..59 */
    tm_hour,   /* horas 0..23 */
    tm_mday,   /* día del mes 1..31 */
    tm_mon,    /* meses desde enero 0..11 */
    tm_year,   /* años desde 1900 */
    tm_wday,   /* días desde el domingo 0..6 */
    tm_yday,   /* días desde enero 0..365 */
    tm_isdst;  /* flag de ahorro diurno de luz */
};	</code></pre>
<p>Por otro lado, existe un segundo formato de representación interna de fechas, , que es simplemente un entero conteniendo la cantidad de segundos desde el principio de la <strong>era UNIX</strong> (), acaecido el 1/1/1970 a la hora 0 UTC. Este formato es el usado por la función que da la hora actual. Este formato entero puede convertirse a y viceversa con funciones definidas en esta zona de la Biblioteca Standard, como y .</p>
<p>El contenido de una estructura se puede imprimir en una gran variedad de formatos, con la función , que acepta una cantidad de especificaciones al estilo de . Las funciones y son más sencillas. Devuelven una cadena conteniendo una fecha en formato normalizado (como el que aparece en los mensajes de correo electrónico). La primera recibe un puntero a ; la segunda, un puntero a .</p>
<pre><code>time_t t;
struct tm *stm;

t = time(NULL);                                 /* recoge la hora actual */
printf(&quot;%s\n&quot;,ctime(&amp;t));                       /* la imprime en formato standard */

char area[100];
stm = gmtime(&amp;t);                               /* convierte t a struct tm */
strftime(area,sizeof(area),&quot;%A %b %d %H&quot;,stm);  /* prepara string según formato del usuario */
printf(&quot;%s\n&quot;,area);                            /* lo imprime */</code></pre>
<h2 id="funciones-matemáticas">Funciones matemáticas</h2>
<p>El header declara las habituales funciones aritméticas avanzadas, trigonométricas y logarítmicas. Todas ellas se presentan en <strong>tres versiones</strong>, que reciben y devuelven diferentes tipos de datos, y cuyos nombres están estructurados de acuerdo a dichos tipos de datos:</p>
<ul>
<li><p>La versión básica recibe argumentos , y devuelve un valor . Por ejemplo, .</p></li>
<li><p>Una versión de precisión limitada, donde se agrega una al nombre de la función, que recibe argumentos , y devuelve un valor . Por ejemplo, .</p></li>
<li><p>Una versión de precisión extendida, donde se agrega una al nombre de la función, que recibe argumentos , y devuelve un valor . Por ejemplo, .</p></li>
</ul>
<p>En el Cuadro [tab:trig] se enumeran las versiones básicas. Aunque sólo se ejemplifica para <span class="math inline"><em>s</em><em>i</em><em>n</em>(<em>x</em>)</span>, todas las funciones matemáticas de la Biblioteca Standard presentan las tres versiones. Como siempre, se recomienda consultar los manuales de estas funciones.</p>
<h2 id="funciones-utilitarias">Funciones utilitarias</h2>
<p>El header agrupa las declaraciones de varias funciones no relacionadas entre sí, y que sirven a varios fines. Solamente las nombramos, y encarecemos la lectura del manual.</p>
<ul>
<li><p>Funciones de conversión: las funciones , , , , , , toman cadenas representando números y generan los elementos de datos del tipo correspondiente.</p></li>
<li><p>Se pueden generar números aleatorios con y .</p></li>
<li><p>Aquí también se declaran las funciones de asignación de memoria como , , , .</p></li>
<li><p>Para manejar datos en memoria con eficiencia se puede recurrir a y , que ordenan una tabla y realizan búsqueda binaria en la tabla ordenada.</p></li>
</ul>
<h2 id="clasificación-de-caracteres">Clasificación de caracteres</h2>
<p>El header contiene declaraciones de macros para averiguar la pertenencia de un carácter a determinados conjuntos (Cuadro [tab:macros]). Son todas booleanas, salvo las últimas, que devuelven ints.</p>
<h2 id="sec:bstandardej">Ejercicios</h2>
<ol>
<li><p>Utilizar la función de cantidad variable de argumentos definida más arriba para obtener los promedios de los 2, 3, ..., n primeros elementos de un arreglo.</p></li>
<li><p>Construir una función de lista variable de argumentos que efectúe la concatenación de una cantidad arbitraria de cadenas en una zona de memoria provista por la función que llama.</p></li>
<li><p>Construir una función de cantidad variable de argumentos que sirva para imprimir, con un formato especificado, mensajes de debugging, conteniendo nombres y valores de variables.</p></li>
<li><p>Construir un programa que separe la entrada standard en palabras, usando las macros de clasificación de caracteres. Debe considerar como delimitadores a los caracteres espacio, tabulador, signos de puntuación, etc.</p></li>
<li><p>Dadas dos fechas y horas del día, calcular su diferencia. Utilizar las funciones de Biblioteca Standard para convertir a tipos de datos convenientes e imprimir la diferencia en años, meses, días, horas, etc.</p></li>
<li><p>Generar fechas al azar dentro de un período de tiempo dado.</p></li>
</ol>
<h2 id="ejercicios-avanzados">Ejercicios avanzados</h2>
<ol>
<li><p>Construir un paquete de administración de archivos en formato <strong>CSV</strong>, escribiendo:</p>
<ul>
<li><p>Una función de inicialización que lea la cabecera del archivo, reconozca los nombres de campos y construya una lista con ellos; y prepare una tabla de registros en memoria, vacía.</p></li>
<li><p>Una función que lea la siguiente línea del archivo y asigne los valores a un nuevo registro en la tabla de registros en memoria.</p></li>
<li><p>Una función que ordene alfabéticamente la tabla de registros en memoria según un campo, dado por su nombre.</p></li>
<li><p>Una modificación a la función anterior que permita diferenciar entre campos alfanuméricos y numéricos según el nombre del campo (por ejemplo, si el nombre del campo comienza con , determinar que se trata de un campo numérico), y ordene la tabla aplicando la comparación adecuada entre registros.</p></li>
<li><p>Una función que busque una cadena en un campo alfanumérico y devuelva el índice del registro donde se la encuentre.</p></li>
<li><p>Una función que sume los contenidos en un campo numérico.</p></li>
<li><p>Una función que reciba un nombre de campo y un parámetro numérico o alfabético, y devuelva el índice del primer registro donde se halle un valor mayor o igual que el parámetro para ese campo, asumiendo que la tabla de registros está ordenada.</p></li>
<li><p>Una función que grabe el archivo con las modificaciones a los registros que hubieran ocurrido.</p></li>
</ul>
<p>Una vez probadas las funciones, escriba un programa que pueda funcionar como utilitario de línea de comandos para que el usuario administre sus archivos CSV.</p>
<p>Dedique algo de tiempo a considerar la mejor estructura de datos posible de acuerdo a las funciones que debe contener el paquete (por ejemplo, considere si es preferible un arreglo bidimensional definido estáticamente, un arreglo lineal definido estáticamente de punteros a espacio asignado dinámicamente, una lista asignada dinámicamente de punteros a espacio asignado dinámicamente, etc.).</p></li>
</ol>
</body>
</html>
